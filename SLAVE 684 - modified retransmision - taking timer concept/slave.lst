CCS PCM C Compiler, Version 5.015, 5967               17-Jun-21 14:49

               Filename:   D:\home automation codes\curtain slave\curtain slave\SLAVE 684 - modified retransmision - taking timer concept\slave.lst

               ROM used:   1575 words (77%)
                           Largest free fragment is 473
               RAM used:   74 (58%) at main() level
                           91 (71%) worst case
               Stack used: 5 locations (3 in main + 2 for interrupts)
               Stack size: 8

*
0000:  MOVLW  05
0001:  MOVWF  0A
0002:  GOTO   5B3
0003:  NOP
0004:  BTFSC  03.5
0005:  GOTO   00A
0006:  MOVWF  24
0007:  SWAPF  03,W
0008:  MOVWF  25
0009:  GOTO   00F
000A:  BCF    03.5
000B:  MOVWF  24
000C:  SWAPF  03,W
000D:  MOVWF  25
000E:  BSF    25.1
000F:  MOVF   0A,W
0010:  MOVWF  2B
0011:  CLRF   0A
0012:  BCF    03.7
0013:  SWAPF  24,F
0014:  MOVF   04,W
0015:  MOVWF  26
0016:  MOVF   20,W
0017:  MOVWF  27
0018:  MOVF   21,W
0019:  MOVWF  28
001A:  MOVF   22,W
001B:  MOVWF  29
001C:  MOVF   23,W
001D:  MOVWF  2A
001E:  BCF    03.5
001F:  BTFSS  0B.5
0020:  GOTO   023
0021:  BTFSC  0B.2
0022:  GOTO   139
0023:  BTFSS  0B.4
0024:  GOTO   027
0025:  BTFSC  0B.1
0026:  GOTO   046
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.0
002A:  GOTO   02D
002B:  BTFSC  0C.0
002C:  GOTO   080
002D:  MOVLW  8C
002E:  MOVWF  04
002F:  BTFSS  00.1
0030:  GOTO   033
0031:  BTFSC  0C.1
0032:  GOTO   145
0033:  MOVF   26,W
0034:  MOVWF  04
0035:  MOVF   27,W
0036:  MOVWF  20
0037:  MOVF   28,W
0038:  MOVWF  21
0039:  MOVF   29,W
003A:  MOVWF  22
003B:  MOVF   2A,W
003C:  MOVWF  23
003D:  MOVF   2B,W
003E:  MOVWF  0A
003F:  SWAPF  25,W
0040:  MOVWF  03
0041:  BCF    03.5
0042:  SWAPF  24,W
0043:  BTFSC  25.1
0044:  BSF    03.5
0045:  RETFIE
.................... #include <slave.h> 
.................... #include <16F684.h> 
.................... //////////// Standard Header file for the PIC16F684 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F684 
....................  
.................... #list 
....................  
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES INTRC_IO                     	//Crystal osc <= 4mhz for PCM/PCH , 3mhz to 10 mhz for PCD 
.................... //#FUSES XT 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES BROWNOUT              	//Reset when brownout detected 
.................... #FUSES NOMCLR                  	//Master Clear pin enabled 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOIESO                	//Internal External Switch Over mode disabled 
.................... #FUSES NOFCMEN               	//Fail-safe clock monitor disabled 
....................  
.................... #use delay(clock=4000000) 
....................  
.................... #include<math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  #include <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
05D5:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #use delay(clock=4000000) 
*
0274:  MOVLW  6B
0275:  MOVWF  04
0276:  MOVF   00,W
0277:  BTFSC  03.2
0278:  GOTO   287
0279:  MOVLW  01
027A:  MOVWF  21
027B:  CLRF   20
027C:  DECFSZ 20,F
027D:  GOTO   27C
027E:  DECFSZ 21,F
027F:  GOTO   27B
0280:  MOVLW  4A
0281:  MOVWF  20
0282:  DECFSZ 20,F
0283:  GOTO   282
0284:  GOTO   285
0285:  DECFSZ 00,F
0286:  GOTO   279
0287:  RETURN
*
0337:  MOVLW  12
0338:  SUBWF  6B,F
0339:  BTFSS  03.0
033A:  GOTO   349
033B:  MOVLW  6B
033C:  MOVWF  04
033D:  MOVLW  FC
033E:  ANDWF  00,F
033F:  BCF    03.0
0340:  RRF    00,F
0341:  RRF    00,F
0342:  MOVF   00,W
0343:  BTFSC  03.2
0344:  GOTO   349
0345:  GOTO   347
0346:  NOP
0347:  DECFSZ 00,F
0348:  GOTO   346
....................  
.................... /////////// Driver details /////////////////// 
.................... /* 
.................... fan driver 
....................  
.................... */ 
.................... ///////////////////////////////////////////////// 
....................  
.................... #define device_type 3 /////////// setting device type  
....................  
.................... #define curtain_open_pin pin_c3 
.................... #define curtain_close_pin pin_c2 
....................  
....................  
.................... #define Fixlampid 65                  // LAMP ADDRESS // 
.................... #define zoneid_init   255 // zone address // 1-6 192//,5-8 193//,9-12 194//,13-16 195// 
.................... #define G1 0b00000001 
.................... #define G2 0b00000000 
.................... #define rx pin_a2 
.................... #define tx pin_a0 
.................... #define self 0x01 
....................  
.................... #define MaxDuty  100 //254 1 led 53,2- 58,3-95 
.................... #define MinDuty  0//10  
....................  
....................  
.................... /////////////////////////////////////////////////////////////// 
....................  
.................... #define PowerOnLevelStore    		0           //[0] 
.................... #define SystemFailureLevelStore  	    1           //[1] 
.................... #define MinimumLevelStore           	2			// [2] 
.................... #define MaximumLevelStore  			3 			// [3] 
.................... #define FadeRateStore      			4  			//[4] 
.................... #define FadeTimeStore       			5			//[5] 
.................... #define ShortAddressStore  			6  			//[6] 
.................... #define Group_07Store    			7			//[7] 
.................... #define Group_815Store  			8			///15 [8] 
.................... #define SceneStore  				9			//15 [9-24]/ 
.................... #define RandomAddressStore0  			25			//[25-27] 
.................... #define RandomAddressStore1  			26			//[25-27] 
.................... #define RandomAddressStore2  			27			//[25-27] 
.................... #define FastFadeTimeStore  			28			//[28] 
.................... #define FailureStatusStore  			29			//[29] 
.................... #define OperatingModeStore  30 //[30] 
.................... #define DimmingCurveStore  31   //[31]      
.................... #define ZoneIDStore 32 
....................  
....................  
....................  
.................... ////////////////// Device types //////////////////////// 
.................... /* 
.................... 	lamp =1 
.................... 	fan=2 
.................... 	curtain=3 
.................... 	strip=4 
.................... */ 
.................... //////////////////////////////////////////////////////// 
....................  
.................... #byte dutyreg = 0x15 
....................   
.................... #bit intf = 0x0b.1 
.................... #bit timerOnOff =0x10.0 
....................  
.................... int1 oddevenbit,a,atmp,b,error_flag,over_flowflag; 
.................... unsigned int8 dataCount; 
.................... char data[3],bitcount,tout; 
....................  
....................  
.................... unsigned char curtain_duty=0; 
.................... int16 curtain_time=0;	 
....................  
....................  
.................... char settling_time,i,dly=4,j; 
.................... int1 txmit_error; 
.................... char tx_buffer[3]; 
.................... char r_a,currentSceen; 
.................... char command_st,RetryCount; 
.................... char FadeRateCount=1; 
....................  
.................... char zoneid=zoneid_init; 
....................  
....................  
.................... char stopBitCount,address ,command,databyte; 
.................... int1 dataready,forwrdFrameFlag,backwardFrameFlag ,masterFlag ; 
.................... int16 readDly=300; 
.................... int16 GroupSelectReg; 
.................... char gindex; 
.................... /////// new  ////// 
.................... int txmit_count=0; 
.................... int error_value=0; 
.................... /////////////////// 
....................  
.................... char MinimumLevel; 
.................... char MaximumLevel; 
.................... char SystemFailureLevel; 
.................... int16 FadeRate; 
.................... char FadeTime; 
.................... char RandomAddress0; 
.................... char RandomAddress1; 
.................... char RandomAddress2; 
.................... char FastFadeTime; 
.................... char FailureStatus; 
.................... char OperatingMode; 
.................... char DimmingCurv; 
.................... char PowerOnLevel; 
.................... char DTR,DwriteLocation,DTR_Ready; 
....................  
.................... char lampid  = Fixlampid; 
....................  
.................... void readData(void); 
.................... void init(void); 
.................... void handle(void ); 
.................... void copyData(void); 
.................... void commands(void); 
.................... void txmit(char priority,char length); 
.................... void txmit1(void); 
.................... void txmit0(void); 
.................... void stopbit(void); 
.................... void lamp_on(void); 
.................... void lamp_off(void); 
.................... void startBit(void); 
.................... void init_from_eeprom(void); 
.................... void goto_position(int16); 
....................  
.................... int1 pos_flag=0; 
.................... int16 curtain_counter; 
....................  
....................  
....................  
....................  
.................... #rom  0x2100={MaxDuty,50,MinDuty,Maxduty,5,6,Fixlampid,G1,G2,6,7,8} 
....................  
.................... #rom  0x2120={zoneid_init} 
....................  
....................  
.................... #int_EXT 
.................... EXT_isr()  
.................... { 
.................... 		restart_wdt(); 	 
*
0046:  CLRWDT
.................... 			disable_interrupts(int_TIMER2);	 
0047:  BSF    03.5
0048:  BCF    0C.1
....................             disable_interrupts(int_ext); 
0049:  BCF    03.5
004A:  BCF    0B.4
....................             disable_interrupts(INT_RTCC); 
004B:  BCF    0B.5
....................             bitcount=0; 
004C:  CLRF   36
....................             setup_timer_1(T1_internal|T1_div_by_1); 
004D:  MOVLW  05
004E:  MOVWF  10
....................             set_timer1(0xffff-840); //858  880///old value 923 
004F:  CLRF   0E
0050:  MOVLW  FC
0051:  MOVWF  0F
0052:  MOVLW  B7
0053:  MOVWF  0E
....................             enable_interrupts(int_timer1); 
0054:  BSF    03.5
0055:  BSF    0C.0
....................             stopBitCount = 0; 
0056:  BCF    03.5
0057:  CLRF   48
....................             oddevenbit=1; 
0058:  BSF    31.0
....................             data[0]=0; 
0059:  CLRF   33
....................             data[1]=0; 
005A:  CLRF   34
....................             data[2]=0; 
005B:  CLRF   35
....................             tout=0 ; 
005C:  CLRF   37
....................             datacount = 0;    
005D:  CLRF   32
.................... 			settling_time = 0;  
005E:  CLRF   3B
.................... } 
....................  
....................  
....................  
....................  
005F:  BCF    0B.1
0060:  BCF    0A.3
0061:  GOTO   033
.................... #int_TIMER1 
.................... TIMER1_isr() 
.................... { 
....................  
....................  
.................... readDly=20; 
*
0080:  CLRF   4E
0081:  MOVLW  14
0082:  MOVWF  4D
.................... error_flag=0; 
0083:  BCF    31.4
.................... 	if(oddevenbit==1) 
0084:  BTFSS  31.0
0085:  GOTO   0C1
.................... 	{ 
.................... 	//	output_high( ); 
.................... 		a=input(rx);  
0086:  BSF    03.5
0087:  BSF    05.2
0088:  BCF    03.5
0089:  BCF    31.1
008A:  BTFSC  05.2
008B:  BSF    31.1
.................... 		atmp=a ;           
008C:  BCF    31.2
008D:  BTFSC  31.1
008E:  BSF    31.2
.................... 		oddevenbit=0 ; 
008F:  BCF    31.0
.................... 		 
.................... 				if(atmp) 
0090:  BTFSS  31.2
0091:  GOTO   0A8
.................... 				{ 
.................... 					while(atmp) 
0092:  BTFSS  31.2
0093:  GOTO   0A7
.................... 						{ 
.................... 							atmp=input(rx); 
0094:  BSF    03.5
0095:  BSF    05.2
0096:  BCF    03.5
0097:  BCF    31.2
0098:  BTFSC  05.2
0099:  BSF    31.2
.................... 							if(readDly>0) 
009A:  MOVF   4D,F
009B:  BTFSS  03.2
009C:  GOTO   0A0
009D:  MOVF   4E,F
009E:  BTFSC  03.2
009F:  GOTO   0A5
.................... 								readDly--; 
00A0:  MOVF   4D,W
00A1:  BTFSC  03.2
00A2:  DECF   4E,F
00A3:  DECF   4D,F
00A4:  GOTO   0A6
.................... 							else 
.................... 								atmp=0; 
00A5:  BCF    31.2
00A6:  GOTO   092
.................... 								 
.................... 						} 
.................... 				}          
00A7:  GOTO   0B9
.................... 				else 
.................... 				{ 
.................... 					while(!atmp) 
00A8:  BTFSC  31.2
00A9:  GOTO   0B9
.................... 						{ 
.................... 							atmp=input(rx); 
00AA:  BSF    03.5
00AB:  BSF    05.2
00AC:  BCF    03.5
00AD:  BCF    31.2
00AE:  BTFSC  05.2
00AF:  BSF    31.2
.................... 							readDly--; 
00B0:  MOVF   4D,W
00B1:  BTFSC  03.2
00B2:  DECF   4E,F
00B3:  DECFSZ 4D,F
.................... 								if(readdly==0) 
00B4:  GOTO   0B8
00B5:  MOVF   4E,F
00B6:  BTFSC  03.2
.................... 									{ 
.................... 									atmp=1; 
00B7:  BSF    31.2
.................... 									}	 
00B8:  GOTO   0A8
.................... 						} 
.................... 				} 
....................  
.................... 			setup_timer_1(T1_internal|T1_div_by_1);//settimer1with1us least count 
00B9:  MOVLW  05
00BA:  MOVWF  10
.................... 			set_timer1(0xffff-150);  //374  //  355             350////old value 150 
00BB:  CLRF   0E
00BC:  MOVLW  FF
00BD:  MOVWF  0F
00BE:  MOVLW  69
00BF:  MOVWF  0E
.................... 	} 
00C0:  GOTO   134
.................... 	else 
.................... 	{  
.................... 	//	output_low(pin_c3); 
.................... 		b=input(rx) ; // store data line status in the second half 
00C1:  BSF    03.5
00C2:  BSF    05.2
00C3:  BCF    03.5
00C4:  BCF    31.3
00C5:  BTFSC  05.2
00C6:  BSF    31.3
.................... 		oddevenbit=1; 
00C7:  BSF    31.0
.................... 		setup_timer_1(T1_internal|T1_div_by_1); 
00C8:  MOVLW  05
00C9:  MOVWF  10
.................... 		set_timer1(0xffff-350);  // delay  till the next call st to 73 us/////old value 350 
00CA:  CLRF   0E
00CB:  MOVLW  FE
00CC:  MOVWF  0F
00CD:  MOVLW  A1
00CE:  MOVWF  0E
.................... 		readData();  // function  get the dat from the conditions of a and b 
.................... 					 
.................... 	} 
.................... return(0); 
*
0134:  MOVLW  00
0135:  MOVWF  21
....................  
....................  
....................  
....................  
....................  
.................... } 
....................  
0136:  BCF    0C.0
0137:  BCF    0A.3
0138:  GOTO   033
.................... #int_RTCC 
.................... RTCC_isr() 
.................... {	 
....................  
.................... 	restart_wdt();  
0139:  CLRWDT
.................... 	dly--; 
013A:  DECFSZ 3D,F
....................   	if (dly == 0) 
013B:  GOTO   142
....................   	{	 
....................       dly = 4; 
013C:  MOVLW  04
013D:  MOVWF  3D
....................       if(settling_time < 25) 
013E:  MOVF   3B,W
013F:  SUBLW  18
0140:  BTFSC  03.0
....................       { 
....................           settling_time++; 
0141:  INCF   3B,F
....................       }               
....................    }    
....................  
.................... } 
....................  
0142:  BCF    0B.2
0143:  BCF    0A.3
0144:  GOTO   033
.................... #int_TIMER2 
.................... timer2_isr() 
.................... { 
.................... 	if((curtain_counter++)==curtain_duty && pos_flag==1) 
0145:  MOVF   67,W
0146:  MOVWF  23
0147:  MOVF   66,W
0148:  INCF   66,F
0149:  BTFSC  03.2
014A:  INCF   67,F
014B:  MOVWF  6C
014C:  MOVF   23,W
014D:  MOVWF  6D
014E:  MOVF   38,W
014F:  SUBWF  6C,W
0150:  BTFSS  03.2
0151:  GOTO   15C
0152:  MOVF   6D,F
0153:  BTFSS  03.2
0154:  GOTO   15C
0155:  BTFSS  4C.3
0156:  GOTO   15C
.................... 	{		 
.................... 		output_high(curtain_open_pin); 
0157:  BSF    03.5
0158:  BCF    07.3
0159:  BCF    03.5
015A:  BSF    07.3
.................... 	} 
015B:  GOTO   168
.................... 	else if(curtain_counter>curtain_duty) 
015C:  MOVF   67,F
015D:  BTFSS  03.2
015E:  GOTO   163
015F:  MOVF   66,W
0160:  SUBWF  38,W
0161:  BTFSC  03.0
0162:  GOTO   168
.................... 	{ 
.................... 		output_low(curtain_open_pin); 
0163:  BSF    03.5
0164:  BCF    07.3
0165:  BCF    03.5
0166:  BCF    07.3
.................... 		pos_flag=0; 
0167:  BCF    4C.3
.................... 	} 
....................  
0168:  BCF    0C.1
0169:  BCF    0A.3
016A:  GOTO   033
.................... } 
....................  
....................  
.................... void main(void) 
*
05B3:  MOVF   03,W
05B4:  ANDLW  1F
05B5:  MOVWF  03
05B6:  MOVLW  61
05B7:  BSF    03.5
05B8:  MOVWF  0F
05B9:  MOVF   0F,W
05BA:  BCF    03.5
05BB:  CLRF   38
05BC:  CLRF   3A
05BD:  CLRF   39
05BE:  MOVLW  04
05BF:  MOVWF  3D
05C0:  MOVLW  01
05C1:  MOVWF  46
05C2:  MOVLW  FF
05C3:  MOVWF  47
05C4:  MOVLW  01
05C5:  MOVWF  4E
05C6:  MOVLW  2C
05C7:  MOVWF  4D
05C8:  CLRF   52
05C9:  CLRF   53
05CA:  MOVLW  41
05CB:  MOVWF  65
05CC:  BCF    4C.3
05CD:  BCF    1F.6
05CE:  MOVLW  00
05CF:  BSF    03.5
05D0:  MOVWF  11
05D1:  BCF    03.5
05D2:  CLRF   1A
05D3:  MOVLW  07
05D4:  MOVWF  19
....................  
.................... { 
.................... 	init_from_eeprom(); 
*
05D6:  CALL   16B
.................... 	init();		 
05D7:  GOTO   252
.................... 	GroupSelectReg = MAKE16(read_EEPROM (Group_815Store ),read_EEPROM (Group_07Store));	 
05D8:  MOVLW  08
05D9:  BSF    03.5
05DA:  MOVWF  1B
05DB:  BCF    1C.7
05DC:  BSF    1C.0
05DD:  MOVF   1A,W
05DE:  BCF    03.5
05DF:  MOVWF  68
05E0:  MOVLW  07
05E1:  BSF    03.5
05E2:  MOVWF  1B
05E3:  BCF    1C.7
05E4:  BSF    1C.0
05E5:  MOVF   1A,W
05E6:  BCF    03.5
05E7:  MOVWF  69
05E8:  MOVF   68,W
05E9:  MOVWF  50
05EA:  MOVF   69,W
05EB:  MOVWF  4F
....................  
.................... PowerOnLevel = read_EEPROM (PowerOnLevelStore); 
05EC:  BSF    03.5
05ED:  CLRF   1B
05EE:  BCF    1C.7
05EF:  BSF    1C.0
05F0:  MOVF   1A,W
05F1:  BCF    03.5
05F2:  MOVWF  61
....................  
.................... /*	if(PowerOnLevel<= 2) 
.................... 	{ 
.................... 	 	curtain_duty=0;	 
.................... 	 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		curtain_duty = PowerOnLevel;		 
.................... 	} 
.................... */ 
.................... faderate=3; 
05F3:  CLRF   58
05F4:  MOVLW  03
05F5:  MOVWF  57
.................... start: 
.................... //output_toggle(pin_C3); 
.................... 	restart_wdt(); 	 
05F6:  CLRWDT
.................... 	if (dataReady ==1) 
05F7:  BTFSS  31.7
05F8:  GOTO   625
.................... 	{ 
.................... 		if(address == 0xff) 
05F9:  INCFSZ 49,W
05FA:  GOTO   5FD
.................... 		{ 
.................... 			handle();  
05FB:  CALL   3BF
.................... 		}		 
05FC:  GOTO   624
.................... 		else if(address==lampid)		{ 
05FD:  MOVF   65,W
05FE:  SUBWF  49,W
05FF:  BTFSS  03.2
0600:  GOTO   603
.................... 			 
.................... 			handle();  
0601:  CALL   3BF
.................... 		}		 
0602:  GOTO   624
....................     	else if(address == zoneid) 
0603:  MOVF   47,W
0604:  SUBWF  49,W
0605:  BTFSS  03.2
0606:  GOTO   609
.................... 		{ 
.................... 			handle();	 
0607:  CALL   3BF
.................... 		} 
0608:  GOTO   624
.................... 		else if(address>191 && address<209) 
0609:  MOVF   49,W
060A:  SUBLW  BF
060B:  BTFSC  03.0
060C:  GOTO   624
060D:  MOVF   49,W
060E:  SUBLW  D0
060F:  BTFSS  03.0
0610:  GOTO   624
.................... 		{	 
.................... 			gindex = address &0x0F; 
0611:  MOVF   49,W
0612:  ANDLW  0F
0613:  MOVWF  51
.................... 			if ( bit_test (GroupSelectReg, gindex)==1) 
0614:  MOVF   50,W
0615:  MOVWF  23
0616:  MOVF   4F,W
0617:  MOVWF  22
0618:  MOVF   51,W
0619:  MOVWF  20
061A:  BTFSC  03.2
061B:  GOTO   621
061C:  BCF    03.0
061D:  RRF    23,F
061E:  RRF    22,F
061F:  DECFSZ 20,F
0620:  GOTO   61C
0621:  MOVF   22,W
0622:  BTFSC  22.0
.................... 			{ 				 
.................... 				handle(); 
0623:  CALL   3BF
.................... 			}	 
.................... 		} 
.................... 		dataReady =0; 
0624:  BCF    31.7
.................... 	} 
.................... /*	if(txmit_error==1&&txmit_count<64) 
.................... 	{ 
.................... 		txmit_count++; 
.................... 		txmit(2,2); 
.................... 	}	 
.................... 	else 
.................... 	{ 
.................... 		txmit_count=0; 
.................... 	} 
.................... */ 
.................... 	goto start; 
0625:  GOTO   5F6
.................... } 
....................  
0626:  SLEEP
.................... void init(void) 
....................  
.................... { 
.................... //	setup_timer_2(T2_OFF);		//26.0 us overflow, 26.0 us interrupt 
....................  	setup_ccp1(CCP_OFF); 
*
0252:  MOVLW  F0
0253:  ANDWF  15,F
.................... 	setup_timer_2(T2_DIV_BY_16,116,16);		//1.8 ms overflow, 29.9 ms interrupt 
0254:  MOVLW  78
0255:  MOVWF  21
0256:  IORLW  06
0257:  MOVWF  12
0258:  MOVLW  74
0259:  BSF    03.5
025A:  MOVWF  12
.................... //	set_pwm1_duty((int16)10);	 
.................... 	setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1); 
025B:  MOVF   01,W
025C:  ANDLW  C7
025D:  IORLW  08
025E:  MOVWF  01
.................... 	//setup_wdt(WDT_2304MS|WDT_DIV_16); 
.................... 	setup_timer_1(T1_internal|T1_div_by_1); 
025F:  MOVLW  05
0260:  BCF    03.5
0261:  MOVWF  10
.................... 	timerOnOff=0; 
0262:  BCF    10.0
.................... 	ext_int_edge( H_TO_L ); 
0263:  BSF    03.5
0264:  BCF    01.6
.................... 	enable_interrupts(INT_EXT); 
0265:  BCF    03.5
0266:  BSF    0B.4
.................... 	enable_interrupts(INT_RTCC); 
0267:  BSF    0B.5
.................... 	enable_interrupts(INT_TIMER2); 
0268:  BSF    03.5
0269:  BSF    0C.1
.................... 	enable_interrupts(global);	 
026A:  MOVLW  C0
026B:  BCF    03.5
026C:  IORWF  0B,F
.................... 	settling_time =23; 
026D:  MOVLW  17
026E:  MOVWF  3B
.................... 	dataReady =0; 
026F:  BCF    31.7
.................... 	//set_pwm1_duty(0); 
.................... 	     
.................... 	faderate=3; 
0270:  CLRF   58
0271:  MOVLW  03
0272:  MOVWF  57
.................... /* 
.................... 	output_high(curtain_open_pin); 
.................... 	delay_ms(500); 
.................... 	output_low(curtain_open_pin); 
.................... 	delay_ms(2000); 
.................... 	output_high(curtain_close_pin); 
.................... 	delay_ms(500); 
.................... 	output_low(curtain_close_pin); 
.................... 	delay_ms(500); 
.................... */	 
.................... 	return; 
0273:  GOTO   5D8 (RETURN)
.................... } 
....................  
....................  
....................  
.................... void handle(void ) 
....................  
.................... { 
.................... 	commands(); 
.................... 	delay_ms(2); 
*
05AE:  MOVLW  02
05AF:  MOVWF  6B
05B0:  CALL   274
.................... 	RetryCount =0; 
05B1:  CLRF   45
....................  
.................... return; 
05B2:  RETURN
....................  
.................... } 
....................  
....................  
.................... //				trnsmission of  bit 1			// 
.................... /********************************************************************* 
....................  * Function:       void txmit0(void); 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          transmission of  bit 1 to the bus	 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
.................... **********************************************************************/ 
....................  
.................... void txmit1(void) 
....................  
.................... {      
....................   	txmit_error = 0; 
*
02DB:  BCF    31.6
.................... 	if (input(rx)==1) 
02DC:  BSF    03.5
02DD:  BSF    05.2
02DE:  BCF    03.5
02DF:  BTFSS  05.2
02E0:  GOTO   2E5
.................... 	{   
.................... 		output_bit(tx,0); 
02E1:  BCF    05.0
02E2:  BSF    03.5
02E3:  BCF    05.0
02E4:  BCF    03.5
.................... 	} 
.................... 	delay_us(79); 
02E5:  MOVLW  19
02E6:  MOVWF  20
02E7:  DECFSZ 20,F
02E8:  GOTO   2E7
02E9:  GOTO   2EA
02EA:  NOP
.................... 	if (input(rx)==1) 
02EB:  BSF    03.5
02EC:  BSF    05.2
02ED:  BCF    03.5
02EE:  BTFSS  05.2
02EF:  GOTO   2F6
.................... 	{ 
.................... 		output_bit(tx,1); 
02F0:  BSF    05.0
02F1:  BSF    03.5
02F2:  BCF    05.0
.................... 		txmit_error = 1; 
02F3:  BCF    03.5
02F4:  BSF    31.6
.................... 		return; 
02F5:  GOTO   32D
.................... 	}			   
.................... 	delay_us(290);//345 
02F6:  MOVLW  60
02F7:  MOVWF  20
02F8:  DECFSZ 20,F
02F9:  GOTO   2F8
02FA:  NOP
.................... 	if (input(rx)==0) 
02FB:  BSF    03.5
02FC:  BSF    05.2
02FD:  BCF    03.5
02FE:  BTFSC  05.2
02FF:  GOTO   305
.................... 	{ 
.................... 		output_bit(tx,1); 
0300:  BSF    05.0
0301:  BSF    03.5
0302:  BCF    05.0
.................... 	} 
0303:  GOTO   30C
0304:  BCF    03.5
.................... 	else 
.................... 	{ 
.................... 		output_bit(tx,1); 
0305:  BSF    05.0
0306:  BSF    03.5
0307:  BCF    05.0
.................... 		txmit_error = 1; 
0308:  BCF    03.5
0309:  BSF    31.6
.................... 		return; 
030A:  GOTO   32D
030B:  BSF    03.5
.................... 	} 
.................... 	delay_us(79); 
030C:  MOVLW  19
030D:  BCF    03.5
030E:  MOVWF  20
030F:  DECFSZ 20,F
0310:  GOTO   30F
0311:  GOTO   312
0312:  NOP
.................... 	if (input(rx)==0) 
0313:  BSF    03.5
0314:  BSF    05.2
0315:  BCF    03.5
0316:  BTFSC  05.2
0317:  GOTO   31E
.................... 	{ 
.................... 		output_bit(tx,1); 
0318:  BSF    05.0
0319:  BSF    03.5
031A:  BCF    05.0
.................... 		txmit_error = 1; 
031B:  BCF    03.5
031C:  BSF    31.6
.................... 		return; 
031D:  GOTO   32D
.................... 	} 
....................     delay_us(290); 
031E:  MOVLW  60
031F:  MOVWF  20
0320:  DECFSZ 20,F
0321:  GOTO   320
0322:  NOP
.................... 	if (input(rx)==0) 
0323:  BSF    03.5
0324:  BSF    05.2
0325:  BCF    03.5
0326:  BTFSC  05.2
0327:  GOTO   32D
.................... 	{ 
.................... 		output_bit(tx,1); 
0328:  BSF    05.0
0329:  BSF    03.5
032A:  BCF    05.0
.................... 		txmit_error = 1; 
032B:  BCF    03.5
032C:  BSF    31.6
.................... 		return; 
.................... 	} 
....................     return; 
032D:  RETURN
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... //         transmission of 0 to the bus      // 
.................... /********************************************************************* 
....................  * Function:       void txmit0(void); 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          transmission of  0 bit to the bus	 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
.................... **********************************************************************/ 
....................  
.................... void txmit0(void) 
....................  
.................... { 
.................... 	txmit_error = 0;	 
*
0369:  BCF    31.6
.................... 	output_bit(tx,1); 
036A:  BSF    05.0
036B:  BSF    03.5
036C:  BCF    05.0
.................... 	delay_us(79); 
036D:  MOVLW  19
036E:  BCF    03.5
036F:  MOVWF  20
0370:  DECFSZ 20,F
0371:  GOTO   370
0372:  GOTO   373
0373:  NOP
.................... 	if (input(rx)!=1) 
0374:  BSF    03.5
0375:  BSF    05.2
0376:  BCF    03.5
0377:  BTFSC  05.2
0378:  GOTO   37B
.................... 	{		 
.................... 		txmit_error = 1; 
0379:  BSF    31.6
.................... 		return; 
037A:  GOTO   3AA
.................... 	}    
.................... 	delay_us(290); 
037B:  MOVLW  60
037C:  MOVWF  20
037D:  DECFSZ 20,F
037E:  GOTO   37D
037F:  NOP
.................... 	if (input(rx)==1) 
0380:  BSF    03.5
0381:  BSF    05.2
0382:  BCF    03.5
0383:  BTFSS  05.2
0384:  GOTO   38A
.................... 	{ 
.................... 		output_bit(tx,0); 
0385:  BCF    05.0
0386:  BSF    03.5
0387:  BCF    05.0
.................... 	} 
0388:  GOTO   391
0389:  BCF    03.5
....................     else 
.................... 	{ 
.................... 		output_bit(tx,1); 
038A:  BSF    05.0
038B:  BSF    03.5
038C:  BCF    05.0
.................... 		txmit_error = 1; 
038D:  BCF    03.5
038E:  BSF    31.6
.................... 		return; 
038F:  GOTO   3AA
0390:  BSF    03.5
.................... 	} 
....................     delay_us(79); 
0391:  MOVLW  19
0392:  BCF    03.5
0393:  MOVWF  20
0394:  DECFSZ 20,F
0395:  GOTO   394
0396:  GOTO   397
0397:  NOP
....................     if (input(rx)==1) 
0398:  BSF    03.5
0399:  BSF    05.2
039A:  BCF    03.5
039B:  BTFSS  05.2
039C:  GOTO   39F
.................... 	{		 
.................... 		txmit_error = 1; 
039D:  BSF    31.6
.................... 		return; 
039E:  GOTO   3AA
.................... 	} 
....................     delay_us(290); 
039F:  MOVLW  60
03A0:  MOVWF  20
03A1:  DECFSZ 20,F
03A2:  GOTO   3A1
03A3:  NOP
.................... 	if (input(rx)==1) 
03A4:  BSF    03.5
03A5:  BSF    05.2
03A6:  BCF    03.5
03A7:  BTFSS  05.2
03A8:  GOTO   3AA
.................... 	{		 
.................... 		txmit_error = 1; 
03A9:  BSF    31.6
.................... 		return; 
.................... 	} 
....................     return; 
.................... } 
.................... //----------------------------------------------------------------------------- 
....................                    // txmit2 bit 
.................... //----------------------------------------------------------------------------- 
....................  
.................... void txmit(char priority,char length) 
.................... {  
....................      j= 8*length; 
*
034C:  RLF    69,W
034D:  MOVWF  3E
034E:  RLF    3E,F
034F:  RLF    3E,F
0350:  MOVLW  F8
0351:  ANDWF  3E,F
.................... 	 while (settling_time < 12+priority);      // priority 
0352:  MOVLW  0C
0353:  ADDWF  68,W
0354:  SUBWF  3B,W
0355:  BTFSS  03.0
0356:  GOTO   352
....................      disable_interrupts(global); 
0357:  BCF    0B.6
0358:  BCF    0B.7
0359:  BTFSC  0B.7
035A:  GOTO   358
....................      txmit1();        // start bit   
035B:  CALL   2DB
....................      for(i=0;i<j;i++) 
035C:  CLRF   3C
035D:  MOVF   3E,W
035E:  SUBWF  3C,W
035F:  BTFSC  03.0
0360:  GOTO   3AE
....................          { 
....................             if (shift_left(tx_buffer,3,1)==1) 
0361:  BSF    03.0
0362:  RLF    3F,F
0363:  RLF    40,F
0364:  RLF    41,F
0365:  BTFSS  03.0
0366:  GOTO   369
....................             { 
....................                  txmit1(); 
0367:  CALL   2DB
....................             } 
0368:  GOTO   3AA
....................             else 
....................             { 
....................                   txmit0(); 
....................             } 
....................             if (txmit_error ==1) 
*
03AA:  BTFSC  31.6
....................             { 
....................                goto rr; 
03AB:  GOTO   3B2
....................             }		 
03AC:  INCF   3C,F
03AD:  GOTO   35D
....................          }         
....................      stopbit();     
03AE:  CALL   32E
....................      stopbit();  
03AF:  CALL   32E
.................... 	stopbit(); stopbit(); 
03B0:  CALL   32E
03B1:  CALL   32E
.................... rr:  output_bit(tx,1); 
03B2:  BSF    05.0
03B3:  BSF    03.5
03B4:  BCF    05.0
.................... 	 settling_time = 0; 
03B5:  BCF    03.5
03B6:  CLRF   3B
....................      intf =0; 
03B7:  BCF    0B.1
....................      enable_interrupts(global);	 
03B8:  MOVLW  C0
03B9:  IORWF  0B,F
.................... 	 enable_interrupts(INT_RTCC); 
03BA:  BSF    0B.5
....................     enable_interrupts(int_timer2); 
03BB:  BSF    03.5
03BC:  BSF    0C.1
....................      return; 
03BD:  BCF    03.5
03BE:  RETURN
.................... } 
....................  
.................... //-------------------------------------------------------------------------- 
....................           // stop bit function // 
.................... //-------------------------------------------------------------------------- 
.................... void  stopbit(void) 
.................... { 
....................       output_bit(tx,1); 
*
032E:  BSF    05.0
032F:  BSF    03.5
0330:  BCF    05.0
.................... 	  restart_wdt();  
0331:  CLRWDT
....................       delay_us(830); 
0332:  MOVLW  05
0333:  BCF    03.5
0334:  MOVWF  6A
0335:  MOVLW  A3
0336:  MOVWF  6B
*
0349:  DECFSZ 6A,F
034A:  GOTO   335
....................       return; 
034B:  RETURN
.................... } 
....................  
.................... //-------------------------------------------------------------------------- 
....................  
....................  
.................... void readData(void) 
.................... { 
.................... 	restart_wdt();  
*
00CF:  CLRWDT
....................       error_flag=0; 
00D0:  BCF    31.4
....................       datacount++; 
00D1:  INCF   32,F
....................       forwrdFrameFlag = 0; 
00D2:  BCF    4C.0
.................... 	  backwardFrameFlag =0; 
00D3:  BCF    4C.1
....................       if(datacount< 27) 
00D4:  MOVF   32,W
00D5:  SUBLW  1A
00D6:  BTFSS  03.0
00D7:  GOTO   12C
....................       { 
....................          if((a==0 )&& (b==1)) 
00D8:  BTFSC  31.1
00D9:  GOTO   0E1
00DA:  BTFSS  31.3
00DB:  GOTO   0E1
....................          { 
....................             shift_left(data,3,1);  // a one  detewcted on bus  
00DC:  BSF    03.0
00DD:  RLF    33,F
00DE:  RLF    34,F
00DF:  RLF    35,F
....................          } 
00E0:  GOTO   12B
....................          else if((a==1)&&(b==0)) 
00E1:  BTFSS  31.1
00E2:  GOTO   0EA
00E3:  BTFSC  31.3
00E4:  GOTO   0EA
....................          { 
....................             shift_left(data,3,0);  // a zero is  deted on the bus  
00E5:  BCF    03.0
00E6:  RLF    33,F
00E7:  RLF    34,F
00E8:  RLF    35,F
....................          } 
00E9:  GOTO   12B
....................          else if ( a==1 && b==1) 
00EA:  BTFSS  31.1
00EB:  GOTO   123
00EC:  BTFSS  31.3
00ED:  GOTO   123
....................          { 
....................             switch (datacount) 
00EE:  MOVF   32,W
00EF:  XORLW  11
00F0:  BTFSC  03.2
00F1:  GOTO   0FC
00F2:  XORLW  03
00F3:  BTFSC  03.2
00F4:  GOTO   0FE
00F5:  XORLW  0B
00F6:  BTFSC  03.2
00F7:  GOTO   10C
00F8:  XORLW  03
00F9:  BTFSC  03.2
00FA:  GOTO   10E
00FB:  GOTO   11B
....................             { 
....................                case 17: 
....................                { 
....................                      stopBitCount ++; 
00FC:  INCF   48,F
....................                      break; 
00FD:  GOTO   122
....................                } 
....................                case 18: 
....................                { 
....................                   stopBitCount ++; 
00FE:  INCF   48,F
....................                   if(stopBitCount == 2) 
00FF:  MOVF   48,W
0100:  SUBLW  02
0101:  BTFSS  03.2
0102:  GOTO   10A
....................                   { 
....................                         r_a=1;  
0103:  MOVLW  01
0104:  MOVWF  42
....................                         copyData(); 
0105:  CALL   062
....................                         forwrdFrameFlag = 1; 
0106:  BSF    4C.0
....................                         masterflag = 0; 
0107:  BCF    4C.2
....................                         backwardFrameFlag =0; 
0108:  BCF    4C.1
....................  
....................                   } 
0109:  GOTO   10B
....................                   else 
....................                   { 
.................... 						error_flag =1; 
010A:  BSF    31.4
....................                   } 
....................                   break; 
010B:  GOTO   122
....................                } 
....................               	case 25: 
.................... 				{ 
.................... 					stopBitCount ++; 
010C:  INCF   48,F
.................... 					break; 
010D:  GOTO   122
.................... 				} 
....................               	case 26:  
.................... 				{ 
.................... 					stopBitCount ++; 
010E:  INCF   48,F
.................... 					if(stopBitCount == 2) 
010F:  MOVF   48,W
0110:  SUBLW  02
0111:  BTFSS  03.2
0112:  GOTO   119
.................... 					{ 
.................... 						r_a=0;  
0113:  CLRF   42
.................... 						copyData(); 
0114:  CALL   062
.................... 						forwrdFrameFlag =0; 
0115:  BCF    4C.0
.................... 						masterflag = 1; 
0116:  BSF    4C.2
.................... 						backwardFrameFlag =0; 
0117:  BCF    4C.1
.................... 					} 
0118:  GOTO   11A
.................... 					else 
.................... 					{ 
.................... 						error_flag =1; 
0119:  BSF    31.4
.................... 					} 
.................... 					break; 
011A:  GOTO   122
.................... 				} 
....................                 default: 
....................                 { 
....................                       error_flag=1; 
011B:  BSF    31.4
....................                       timerOnOff=0; 
011C:  BCF    10.0
....................                       enable_interrupts(INT_EXT); 
011D:  BSF    0B.4
.................... 					  enable_interrupts(int_timer2); 
011E:  BSF    03.5
011F:  BSF    0C.1
....................                       settling_time = 0; 
0120:  BCF    03.5
0121:  CLRF   3B
....................                       break; 
....................                 } 
....................              }    
....................           }  
0122:  GOTO   12B
.................... 		else 
.................... 		{ 
.................... 			error_flag=1;     
0123:  BSF    31.4
.................... 			settling_time = 0; 
0124:  CLRF   3B
.................... 			timerOnOff=0;        
0125:  BCF    10.0
.................... 			enable_interrupts(INT_EXT);       
0126:  BSF    0B.4
.................... 			enable_interrupts(int_timer2);  
0127:  BSF    03.5
0128:  BSF    0C.1
.................... 			enable_interrupts(INT_RTCC);          
0129:  BCF    03.5
012A:  BSF    0B.5
.................... 		} 
....................       } 
012B:  GOTO   134
.................... 	else  // the  data count grater than 27  
.................... 	{ 
.................... 		over_flowflag =1 ; 
012C:  BSF    31.5
.................... 		settling_time = 0; 
012D:  CLRF   3B
.................... 		timerOnOff=0;        
012E:  BCF    10.0
.................... 		enable_interrupts(INT_EXT);        
012F:  BSF    0B.4
.................... 		enable_interrupts(INT_RTCC); 
0130:  BSF    0B.5
.................... 		enable_interrupts(int_timer2);          
0131:  BSF    03.5
0132:  BSF    0C.1
0133:  BCF    03.5
.................... 	} 
....................     return; 
.................... } 
....................  
....................  
....................  
....................  
.................... void copyData(void) 
.................... {  
.................... 	restart_wdt();  
*
0062:  CLRWDT
.................... 	dataReady =1;     
0063:  BSF    31.7
.................... 	if( r_a==1) 
0064:  DECFSZ 42,W
0065:  GOTO   06B
.................... 	{ 
.................... 		address = data[1]; 
0066:  MOVF   34,W
0067:  MOVWF  49
.................... 		command =data[0];						 
0068:  MOVF   33,W
0069:  MOVWF  4A
.................... 	} 
006A:  GOTO   074
.................... 	else if( r_a==0) 
006B:  MOVF   42,F
006C:  BTFSS  03.2
006D:  GOTO   074
.................... 	{	 
.................... 		address = data[2]; 
006E:  MOVF   35,W
006F:  MOVWF  49
.................... 		command =data[1]; 
0070:  MOVF   34,W
0071:  MOVWF  4A
.................... 		databyte=data[0];  
0072:  MOVF   33,W
0073:  MOVWF  4B
.................... 	}        
....................     timerOnOff=0; 
0074:  BCF    10.0
....................     intf =0; 
0075:  BCF    0B.1
....................     enable_interrupts(INT_EXT); 
0076:  BSF    0B.4
....................     disable_interrupts(int_timer1); 
0077:  BSF    03.5
0078:  BCF    0C.0
....................     enable_interrupts(INT_RTCC); 
0079:  BCF    03.5
007A:  BSF    0B.5
.................... 	enable_interrupts(int_timer2); 
007B:  BSF    03.5
007C:  BSF    0C.1
....................     settling_time = 0; 
007D:  BCF    03.5
007E:  CLRF   3B
....................     return; 
007F:  RETURN
.................... } 
....................  
....................  
.................... void commands(void) 
.................... {  
.................... 	command_st =0;	 
*
03BF:  CLRF   44
.................... 	switch(command) 
03C0:  MOVF   4A,W
03C1:  XORLW  2A
03C2:  BTFSC  03.2
03C3:  GOTO   3E9
03C4:  XORLW  02
03C5:  BTFSC  03.2
03C6:  GOTO   3FF
03C7:  XORLW  01
03C8:  BTFSC  03.2
03C9:  GOTO   407
03CA:  XORLW  C3
03CB:  BTFSC  03.2
03CC:  GOTO   40E
03CD:  XORLW  0D
03CE:  BTFSC  03.2
03CF:  GOTO   429
03D0:  XORLW  EE
03D1:  BTFSC  03.2
03D2:  GOTO   451
03D3:  XORLW  2B
03D4:  BTFSC  03.2
03D5:  GOTO   514
03D6:  XORLW  01
03D7:  BTFSC  03.2
03D8:  GOTO   538
03D9:  XORLW  07
03DA:  BTFSC  03.2
03DB:  GOTO   53D
03DC:  XORLW  01
03DD:  BTFSC  03.2
03DE:  GOTO   564
03DF:  XORLW  03
03E0:  BTFSC  03.2
03E1:  GOTO   56D
03E2:  XORLW  01
03E3:  BTFSC  03.2
03E4:  GOTO   57C
03E5:  XORLW  16
03E6:  BTFSC  03.2
03E7:  GOTO   58A
03E8:  GOTO   593
.................... 	{ 
.................... 		 
.................... 	   	case 42:	// goto  level  
.................... 		{   
.................... 			pos_flag=0; 
03E9:  BCF    4C.3
.................... 			if(databyte > MaximumLevel ) 
03EA:  MOVF   4B,W
03EB:  SUBWF  55,W
03EC:  BTFSC  03.0
03ED:  GOTO   3F1
.................... 			{ 
....................  
....................                 curtain_duty=MaximumLevel; 
03EE:  MOVF   55,W
03EF:  MOVWF  38
.................... 			} 
03F0:  GOTO   3FA
.................... 			else if(databyte< MinimumLevel ) 
03F1:  MOVF   54,W
03F2:  SUBWF  4B,W
03F3:  BTFSC  03.0
03F4:  GOTO   3F8
.................... 		    { 
.................... 			 
....................                 curtain_duty=MinimumLevel; 
03F5:  MOVF   54,W
03F6:  MOVWF  38
.................... 			} 
03F7:  GOTO   3FA
.................... 			else 
.................... 			{ 
.................... 		 
....................                 curtain_duty=databyte; 
03F8:  MOVF   4B,W
03F9:  MOVWF  38
.................... 			} 		 
.................... 			goto_position(curtain_duty);	 
03FA:  CLRF   69
03FB:  MOVF   38,W
03FC:  MOVWF  68
03FD:  CALL   288
.................... 										 
.................... 			break; 
03FE:  GOTO   595
.................... 		} 
.................... 		case 40:	// on 
.................... 		{  		 
.................... 			pos_flag=0; 
03FF:  BCF    4C.3
....................             curtain_duty=100;			 
0400:  MOVLW  64
0401:  MOVWF  38
.................... 			goto_position(curtain_duty);						 
0402:  CLRF   69
0403:  MOVF   38,W
0404:  MOVWF  68
0405:  CALL   288
.................... 			break; 
0406:  GOTO   595
.................... 		} 
.................... 		case 41:	//off 
.................... 		{  	 
.................... 		pos_flag=0; 
0407:  BCF    4C.3
....................          curtain_duty=0; 
0408:  CLRF   38
.................... 		goto_position(curtain_duty); 
0409:  CLRF   69
040A:  MOVF   38,W
040B:  MOVWF  68
040C:  CALL   288
.................... 			break; 
040D:  GOTO   595
.................... 		}	 
.................... 		case 234: // scene select  
.................... 		{			 
.................... 			if(databyte < 17) 
040E:  MOVF   4B,W
040F:  SUBLW  10
0410:  BTFSS  03.0
0411:  GOTO   424
.................... 			{				 
.................... 				currentSceen = databyte;			 
0412:  MOVF   4B,W
0413:  MOVWF  43
.................... 		        curtain_duty = read_EEPROM (currentSceen+SceneStore);	 
0414:  MOVLW  09
0415:  ADDWF  43,W
0416:  MOVWF  68
0417:  MOVF   68,W
0418:  BSF    03.5
0419:  MOVWF  1B
041A:  BCF    1C.7
041B:  BSF    1C.0
041C:  MOVF   1A,W
041D:  BCF    03.5
041E:  MOVWF  38
.................... 			     	if(curtain_duty<=MinimumLevel) 
041F:  MOVF   38,W
0420:  SUBWF  54,W
0421:  BTFSS  03.0
0422:  GOTO   424
.................... 					{ 
.................... 					   	curtain_duty=0;					 
0423:  CLRF   38
.................... 					 
.................... 					} 
.................... 					else 
.................... 					{								 
.................... 							 
.................... 					}			 
.................... 			} 
.................... 			goto_position(curtain_duty); 
0424:  CLRF   69
0425:  MOVF   38,W
0426:  MOVWF  68
0427:  CALL   288
.................... 			break; 
0428:  GOTO   595
.................... 		 } 
.................... 		case 231:  // store sceen  
.................... 		{ 
....................  
.................... 			if(databyte < 17) 
0429:  MOVF   4B,W
042A:  SUBLW  10
042B:  BTFSS  03.0
042C:  GOTO   450
.................... 			{				 
.................... 				disable_interrupts (global); 
042D:  BCF    0B.6
042E:  BCF    0B.7
042F:  BTFSC  0B.7
0430:  GOTO   42E
.................... 				write_eeprom(databyte+SceneStore,curtain_duty); 
0431:  MOVLW  09
0432:  ADDWF  4B,W
0433:  MOVWF  68
0434:  MOVF   0B,W
0435:  MOVWF  20
0436:  BCF    0B.7
0437:  MOVF   68,W
0438:  BSF    03.5
0439:  MOVWF  1B
043A:  BCF    03.5
043B:  MOVF   38,W
043C:  BSF    03.5
043D:  MOVWF  1A
043E:  BCF    1C.7
043F:  BSF    1C.2
0440:  MOVLW  55
0441:  MOVWF  1D
0442:  MOVLW  AA
0443:  MOVWF  1D
0444:  BSF    1C.1
0445:  BTFSC  1C.1
0446:  GOTO   445
0447:  BCF    1C.2
0448:  BCF    03.5
0449:  MOVF   20,W
044A:  IORWF  0B,F
.................... 				delay_us(5);			 
044B:  GOTO   44C
044C:  GOTO   44D
044D:  NOP
.................... 				enable_interrupts(global);	 
044E:  MOVLW  C0
044F:  IORWF  0B,F
.................... 			} 
.................... 			 
.................... 			break; 
0450:  GOTO   595
.................... 		} 
.................... 		case 0x09: 
.................... 		{		 
.................... 				GroupSelectReg = MAKE16(read_EEPROM (Group_815Store ),read_EEPROM (Group_07Store));	 
0451:  MOVLW  08
0452:  BSF    03.5
0453:  MOVWF  1B
0454:  BCF    1C.7
0455:  BSF    1C.0
0456:  MOVF   1A,W
0457:  BCF    03.5
0458:  MOVWF  68
0459:  MOVLW  07
045A:  BSF    03.5
045B:  MOVWF  1B
045C:  BCF    1C.7
045D:  BSF    1C.0
045E:  MOVF   1A,W
045F:  BCF    03.5
0460:  MOVWF  69
0461:  MOVF   68,W
0462:  MOVWF  50
0463:  MOVF   69,W
0464:  MOVWF  4F
.................... 				gindex = databyte &0x0f;				 
0465:  MOVF   4B,W
0466:  ANDLW  0F
0467:  MOVWF  51
.................... 				switch (databyte & 0x10) 
0468:  MOVF   4B,W
0469:  ANDLW  10
046A:  BTFSC  03.2
046B:  GOTO   470
046C:  XORLW  10
046D:  BTFSC  03.2
046E:  GOTO   4C4
046F:  GOTO   513
.................... 				{ 
.................... 					case 0: 
.................... 						{ 
.................... 							bit_clear(GroupSelectReg,gindex); 
0470:  CLRF   23
0471:  MOVLW  01
0472:  MOVWF  22
0473:  MOVF   51,W
0474:  MOVWF  20
0475:  BTFSC  03.2
0476:  GOTO   47C
0477:  BCF    03.0
0478:  RLF    22,F
0479:  RLF    23,F
047A:  DECFSZ 20,F
047B:  GOTO   477
047C:  MOVF   22,W
047D:  XORLW  FF
047E:  MOVWF  20
047F:  MOVLW  FF
0480:  XORWF  23,F
0481:  MOVF   20,W
0482:  ANDWF  4F,F
0483:  MOVF   23,W
0484:  ANDWF  50,F
.................... 							write_eeprom(Group_07Store  ,make8(GroupSelectReg,0)); 
0485:  MOVF   4F,W
0486:  MOVWF  68
0487:  MOVF   0B,W
0488:  MOVWF  20
0489:  BCF    0B.7
048A:  MOVLW  07
048B:  BSF    03.5
048C:  MOVWF  1B
048D:  BCF    03.5
048E:  MOVF   4F,W
048F:  BSF    03.5
0490:  MOVWF  1A
0491:  BCF    1C.7
0492:  BSF    1C.2
0493:  MOVLW  55
0494:  MOVWF  1D
0495:  MOVLW  AA
0496:  MOVWF  1D
0497:  BSF    1C.1
0498:  BTFSC  1C.1
0499:  GOTO   498
049A:  BCF    1C.2
049B:  BCF    03.5
049C:  MOVF   20,W
049D:  IORWF  0B,F
.................... 							delay_us(10); 
049E:  MOVLW  02
049F:  MOVWF  20
04A0:  DECFSZ 20,F
04A1:  GOTO   4A0
04A2:  GOTO   4A3
04A3:  NOP
.................... 							write_eeprom(Group_815Store,make8(GroupSelectReg,1)); 
04A4:  MOVF   50,W
04A5:  MOVWF  68
04A6:  MOVF   0B,W
04A7:  MOVWF  20
04A8:  BCF    0B.7
04A9:  MOVLW  08
04AA:  BSF    03.5
04AB:  MOVWF  1B
04AC:  BCF    03.5
04AD:  MOVF   50,W
04AE:  BSF    03.5
04AF:  MOVWF  1A
04B0:  BCF    1C.7
04B1:  BSF    1C.2
04B2:  MOVLW  55
04B3:  MOVWF  1D
04B4:  MOVLW  AA
04B5:  MOVWF  1D
04B6:  BSF    1C.1
04B7:  BTFSC  1C.1
04B8:  GOTO   4B7
04B9:  BCF    1C.2
04BA:  BCF    03.5
04BB:  MOVF   20,W
04BC:  IORWF  0B,F
....................  							delay_us(10); 
04BD:  MOVLW  02
04BE:  MOVWF  20
04BF:  DECFSZ 20,F
04C0:  GOTO   4BF
04C1:  GOTO   4C2
04C2:  NOP
.................... 							break; 
04C3:  GOTO   513
.................... 						} 
.................... 					case 16: 
.................... 						{ 
.................... 							bit_set(GroupSelectReg,gindex); 
04C4:  CLRF   23
04C5:  MOVLW  01
04C6:  MOVWF  22
04C7:  MOVF   51,W
04C8:  MOVWF  20
04C9:  BTFSC  03.2
04CA:  GOTO   4D0
04CB:  BCF    03.0
04CC:  RLF    22,F
04CD:  RLF    23,F
04CE:  DECFSZ 20,F
04CF:  GOTO   4CB
04D0:  MOVF   22,W
04D1:  IORWF  4F,F
04D2:  MOVF   23,W
04D3:  IORWF  50,F
.................... 							write_eeprom(Group_07Store  ,make8(GroupSelectReg,0)); 
04D4:  MOVF   4F,W
04D5:  MOVWF  68
04D6:  MOVF   0B,W
04D7:  MOVWF  20
04D8:  BCF    0B.7
04D9:  MOVLW  07
04DA:  BSF    03.5
04DB:  MOVWF  1B
04DC:  BCF    03.5
04DD:  MOVF   4F,W
04DE:  BSF    03.5
04DF:  MOVWF  1A
04E0:  BCF    1C.7
04E1:  BSF    1C.2
04E2:  MOVLW  55
04E3:  MOVWF  1D
04E4:  MOVLW  AA
04E5:  MOVWF  1D
04E6:  BSF    1C.1
04E7:  BTFSC  1C.1
04E8:  GOTO   4E7
04E9:  BCF    1C.2
04EA:  BCF    03.5
04EB:  MOVF   20,W
04EC:  IORWF  0B,F
.................... 							delay_us(10); 
04ED:  MOVLW  02
04EE:  MOVWF  20
04EF:  DECFSZ 20,F
04F0:  GOTO   4EF
04F1:  GOTO   4F2
04F2:  NOP
.................... 							write_eeprom(Group_815Store,make8(GroupSelectReg,1)); 
04F3:  MOVF   50,W
04F4:  MOVWF  68
04F5:  MOVF   0B,W
04F6:  MOVWF  20
04F7:  BCF    0B.7
04F8:  MOVLW  08
04F9:  BSF    03.5
04FA:  MOVWF  1B
04FB:  BCF    03.5
04FC:  MOVF   50,W
04FD:  BSF    03.5
04FE:  MOVWF  1A
04FF:  BCF    1C.7
0500:  BSF    1C.2
0501:  MOVLW  55
0502:  MOVWF  1D
0503:  MOVLW  AA
0504:  MOVWF  1D
0505:  BSF    1C.1
0506:  BTFSC  1C.1
0507:  GOTO   506
0508:  BCF    1C.2
0509:  BCF    03.5
050A:  MOVF   20,W
050B:  IORWF  0B,F
....................  							delay_us(10); 
050C:  MOVLW  02
050D:  MOVWF  20
050E:  DECFSZ 20,F
050F:  GOTO   50E
0510:  GOTO   511
0511:  NOP
.................... 							break; 
0512:  GOTO   513
.................... 						} 
.................... 					 
.................... 					default: break; 
....................  
.................... 				} 
.................... 				 
.................... 				break ; 
0513:  GOTO   595
.................... 		} 
.................... 		case 0x22:    // store  short  aress  
.................... 		{ 
.................... 			if(databyte <64) 
0514:  MOVF   4B,W
0515:  SUBLW  3F
0516:  BTFSS  03.0
0517:  GOTO   537
.................... 			{ 
.................... 					lampid = databyte; 
0518:  MOVF   4B,W
0519:  MOVWF  65
.................... 					write_eeprom(ShortAddressStore ,lampid); 
051A:  MOVF   0B,W
051B:  MOVWF  20
051C:  BCF    0B.7
051D:  MOVLW  06
051E:  BSF    03.5
051F:  MOVWF  1B
0520:  BCF    03.5
0521:  MOVF   65,W
0522:  BSF    03.5
0523:  MOVWF  1A
0524:  BCF    1C.7
0525:  BSF    1C.2
0526:  MOVLW  55
0527:  MOVWF  1D
0528:  MOVLW  AA
0529:  MOVWF  1D
052A:  BSF    1C.1
052B:  BTFSC  1C.1
052C:  GOTO   52B
052D:  BCF    1C.2
052E:  BCF    03.5
052F:  MOVF   20,W
0530:  IORWF  0B,F
.................... 					delay_us(10); 
0531:  MOVLW  02
0532:  MOVWF  20
0533:  DECFSZ 20,F
0534:  GOTO   533
0535:  GOTO   536
0536:  NOP
.................... 			} 
.................... 		 
.................... 			break;		 
0537:  GOTO   595
.................... 		} 
.................... 		case 0x23:    // write  DTR  
.................... 		{ 
.................... 					DTR = databyte;	 
0538:  MOVF   4B,W
0539:  MOVWF  62
.................... 					DTR_Ready =1; 
053A:  MOVLW  01
053B:  MOVWF  64
.................... 					break; 
053C:  GOTO   595
.................... 		} 
.................... 		case 0x24:    // write  DTR  to  adress  location  in data  byte  
.................... 		{ 
.................... 					 
.................... 				DwriteLocation = databyte;	 
053D:  MOVF   4B,W
053E:  MOVWF  63
.................... 				if(DTR_Ready ==1 && DwriteLocation<33 ) 
053F:  DECFSZ 64,W
0540:  GOTO   562
0541:  MOVF   63,W
0542:  SUBLW  20
0543:  BTFSS  03.0
0544:  GOTO   562
.................... 				{ 
.................... 					DTR_Ready =0; 
0545:  CLRF   64
.................... 					write_eeprom(DwriteLocation,DTR); 
0546:  MOVF   0B,W
0547:  MOVWF  20
0548:  BCF    0B.7
0549:  MOVF   63,W
054A:  BSF    03.5
054B:  MOVWF  1B
054C:  BCF    03.5
054D:  MOVF   62,W
054E:  BSF    03.5
054F:  MOVWF  1A
0550:  BCF    1C.7
0551:  BSF    1C.2
0552:  MOVLW  55
0553:  MOVWF  1D
0554:  MOVLW  AA
0555:  MOVWF  1D
0556:  BSF    1C.1
0557:  BTFSC  1C.1
0558:  GOTO   557
0559:  BCF    1C.2
055A:  BCF    03.5
055B:  MOVF   20,W
055C:  IORWF  0B,F
.................... 					DELAY_US(20); 
055D:  MOVLW  06
055E:  MOVWF  20
055F:  DECFSZ 20,F
0560:  GOTO   55F
0561:  NOP
.................... 				} 
.................... 			init_from_eeprom(); 
0562:  CALL   16B
.................... 			break; 
0563:  GOTO   595
.................... 		} 
.................... 		case 0x25:    // Read  DTR  to  adress  location  in data  byte  
.................... 		{ 
.................... 				tx_buffer[2]=lampid;tx_buffer[1]=DTR; txmit(2,2);  /////////priority changed 
0564:  MOVF   65,W
0565:  MOVWF  41
0566:  MOVF   62,W
0567:  MOVWF  40
0568:  MOVLW  02
0569:  MOVWF  68
056A:  MOVWF  69
056B:  CALL   34C
.................... 				break;			 
056C:  GOTO   595
.................... 		} 
.................... 		case 0x26:    // Read  eeprom  and  store  in dtr   to  adress  location  in data  byte  
.................... 		{ 
.................... 				DwriteLocation = databyte;	 
056D:  MOVF   4B,W
056E:  MOVWF  63
.................... 				if( DwriteLocation<33 ) 
056F:  MOVF   63,W
0570:  SUBLW  20
0571:  BTFSS  03.0
0572:  GOTO   57B
.................... 				{ 
.................... 					DTR=Read_eeprom(DwriteLocation); 
0573:  MOVF   63,W
0574:  BSF    03.5
0575:  MOVWF  1B
0576:  BCF    1C.7
0577:  BSF    1C.0
0578:  MOVF   1A,W
0579:  BCF    03.5
057A:  MOVWF  62
.................... 				}	 
.................... 				break;				 
057B:  GOTO   595
.................... 		} 
.................... 		case 0x27: 
.................... 		{ 
.................... 			tx_buffer[2]=lampid;tx_buffer[1]=Read_eeprom(0);  
057C:  MOVF   65,W
057D:  MOVWF  41
057E:  BSF    03.5
057F:  CLRF   1B
0580:  BCF    1C.7
0581:  BSF    1C.0
0582:  MOVF   1A,W
0583:  BCF    03.5
0584:  MOVWF  40
.................... 	    	txmit(2,2); 
0585:  MOVLW  02
0586:  MOVWF  68
0587:  MOVWF  69
0588:  CALL   34C
.................... 		 
.................... 			break; 
0589:  GOTO   595
....................  
.................... 		} 
.................... 		case 0x31: //////////////// case for device type query ///////////////// 
.................... 		{ 
.................... 			tx_buffer[2]=lampid;tx_buffer[1]=device_type;  
058A:  MOVF   65,W
058B:  MOVWF  41
058C:  MOVLW  03
058D:  MOVWF  40
.................... 			txmit(2,2); 
058E:  MOVLW  02
058F:  MOVWF  68
0590:  MOVWF  69
0591:  CALL   34C
.................... 					 
.................... 			 
.................... 			break; 
0592:  GOTO   595
....................  
.................... 		} 
.................... 		default: 
.................... 		{ 
.................... 			command_st=1; 
0593:  MOVLW  01
0594:  MOVWF  44
.................... 			break; 
.................... 		} 
.................... 	} 
.................... 	if(command_st==0) 
0595:  MOVF   44,F
0596:  BTFSS  03.2
0597:  GOTO   5AE
.................... 	{ 		 
.................... 		  write_eeprom(PowerOnLevelStore,curtain_duty);		 
0598:  MOVF   0B,W
0599:  MOVWF  20
059A:  BCF    0B.7
059B:  BSF    03.5
059C:  CLRF   1B
059D:  BCF    03.5
059E:  MOVF   38,W
059F:  BSF    03.5
05A0:  MOVWF  1A
05A1:  BCF    1C.7
05A2:  BSF    1C.2
05A3:  MOVLW  55
05A4:  MOVWF  1D
05A5:  MOVLW  AA
05A6:  MOVWF  1D
05A7:  BSF    1C.1
05A8:  BTFSC  1C.1
05A9:  GOTO   5A8
05AA:  BCF    1C.2
05AB:  BCF    03.5
05AC:  MOVF   20,W
05AD:  IORWF  0B,F
.................... 	} 
....................  
....................  
.................... return; 
.................... } 
....................  
....................  
....................  
.................... void goto_position(int16 position) 
.................... {	 
.................... 	if(position == 0) 
*
0288:  MOVF   68,F
0289:  BTFSS  03.2
028A:  GOTO   29A
028B:  MOVF   69,F
028C:  BTFSS  03.2
028D:  GOTO   29A
.................... 	{ 
.................... 	output_high(curtain_close_pin); 
028E:  BSF    03.5
028F:  BCF    07.2
0290:  BCF    03.5
0291:  BSF    07.2
.................... 	delay_ms(100); 
0292:  MOVLW  64
0293:  MOVWF  6B
0294:  CALL   274
.................... 	output_low(curtain_close_pin); 
0295:  BSF    03.5
0296:  BCF    07.2
0297:  BCF    03.5
0298:  BCF    07.2
.................... 	} 
0299:  GOTO   2DA
.................... 	else if(position==100) 
029A:  MOVF   68,W
029B:  SUBLW  64
029C:  BTFSS  03.2
029D:  GOTO   2AD
029E:  MOVF   69,F
029F:  BTFSS  03.2
02A0:  GOTO   2AD
.................... 	{ 
.................... 	output_high(curtain_open_pin); 
02A1:  BSF    03.5
02A2:  BCF    07.3
02A3:  BCF    03.5
02A4:  BSF    07.3
.................... 	delay_ms(100); 
02A5:  MOVLW  64
02A6:  MOVWF  6B
02A7:  CALL   274
.................... 	output_low(curtain_open_pin); 
02A8:  BSF    03.5
02A9:  BCF    07.3
02AA:  BCF    03.5
02AB:  BCF    07.3
.................... 	} 
02AC:  GOTO   2DA
.................... 	else if(position>0 && position <100) 
02AD:  MOVF   68,F
02AE:  BTFSS  03.2
02AF:  GOTO   2B3
02B0:  MOVF   69,F
02B1:  BTFSC  03.2
02B2:  GOTO   2CF
02B3:  MOVF   69,F
02B4:  BTFSS  03.2
02B5:  GOTO   2CF
02B6:  MOVF   68,W
02B7:  SUBLW  63
02B8:  BTFSS  03.0
02B9:  GOTO   2CF
.................... 	{ 
.................... 	// code to go to position 0 
.................... 	pos_flag=0; 
02BA:  BCF    4C.3
.................... 	output_high(curtain_close_pin); 
02BB:  BSF    03.5
02BC:  BCF    07.2
02BD:  BCF    03.5
02BE:  BSF    07.2
.................... 	delay_ms(100); 
02BF:  MOVLW  64
02C0:  MOVWF  6B
02C1:  CALL   274
.................... 	output_low(curtain_close_pin); 
02C2:  BSF    03.5
02C3:  BCF    07.2
02C4:  BCF    03.5
02C5:  BCF    07.2
.................... 	delay_ms(3000); 
02C6:  MOVLW  0C
02C7:  MOVWF  6A
02C8:  MOVLW  FA
02C9:  MOVWF  6B
02CA:  CALL   274
02CB:  DECFSZ 6A,F
02CC:  GOTO   2C8
.................... 	pos_flag=1; 
02CD:  BSF    4C.3
.................... 	} 
02CE:  GOTO   2DA
.................... 	else 
.................... 	{ 
.................... 	output_high(curtain_close_pin); 
02CF:  BSF    03.5
02D0:  BCF    07.2
02D1:  BCF    03.5
02D2:  BSF    07.2
.................... 	delay_ms(100); 
02D3:  MOVLW  64
02D4:  MOVWF  6B
02D5:  CALL   274
.................... 	output_low(curtain_close_pin); 
02D6:  BSF    03.5
02D7:  BCF    07.2
02D8:  BCF    03.5
02D9:  BCF    07.2
.................... 	} 
.................... 	 
.................... 	return; 
02DA:  RETURN
....................  
....................  
.................... } 
....................  
.................... void init_from_eeprom(void) 
.................... { 
.................... GroupSelectReg = MAKE16(read_EEPROM (Group_815Store ),read_EEPROM (Group_07Store));	 
*
016B:  MOVLW  08
016C:  BSF    03.5
016D:  MOVWF  1B
016E:  BCF    1C.7
016F:  BSF    1C.0
0170:  MOVF   1A,W
0171:  BCF    03.5
0172:  MOVWF  68
0173:  MOVLW  07
0174:  BSF    03.5
0175:  MOVWF  1B
0176:  BCF    1C.7
0177:  BSF    1C.0
0178:  MOVF   1A,W
0179:  BCF    03.5
017A:  MOVWF  69
017B:  MOVF   68,W
017C:  MOVWF  50
017D:  MOVF   69,W
017E:  MOVWF  4F
.................... delay_us(10); 
017F:  MOVLW  02
0180:  MOVWF  20
0181:  DECFSZ 20,F
0182:  GOTO   181
0183:  GOTO   184
0184:  NOP
.................... PowerOnLevel 		= read_EEPROM (PowerOnLevelStore); 
0185:  BSF    03.5
0186:  CLRF   1B
0187:  BCF    1C.7
0188:  BSF    1C.0
0189:  MOVF   1A,W
018A:  BCF    03.5
018B:  MOVWF  61
.................... delay_us(10);  
018C:  MOVLW  02
018D:  MOVWF  20
018E:  DECFSZ 20,F
018F:  GOTO   18E
0190:  GOTO   191
0191:  NOP
.................... SystemFailureLevel	= read_EEPROM ( SystemFailureLevelStore );  
0192:  MOVLW  01
0193:  BSF    03.5
0194:  MOVWF  1B
0195:  BCF    1C.7
0196:  BSF    1C.0
0197:  MOVF   1A,W
0198:  BCF    03.5
0199:  MOVWF  56
.................... delay_us(10);	     
019A:  MOVLW  02
019B:  MOVWF  20
019C:  DECFSZ 20,F
019D:  GOTO   19C
019E:  GOTO   19F
019F:  NOP
.................... MinimumLevel		= read_EEPROM ( MinimumLevelStore );    
01A0:  MOVLW  02
01A1:  BSF    03.5
01A2:  MOVWF  1B
01A3:  BCF    1C.7
01A4:  BSF    1C.0
01A5:  MOVF   1A,W
01A6:  BCF    03.5
01A7:  MOVWF  54
.................... delay_us(10);       	 
01A8:  MOVLW  02
01A9:  MOVWF  20
01AA:  DECFSZ 20,F
01AB:  GOTO   1AA
01AC:  GOTO   1AD
01AD:  NOP
.................... MaximumLevel 		= read_EEPROM ( MaximumLevelStore);  
01AE:  MOVLW  03
01AF:  BSF    03.5
01B0:  MOVWF  1B
01B1:  BCF    1C.7
01B2:  BSF    1C.0
01B3:  MOVF   1A,W
01B4:  BCF    03.5
01B5:  MOVWF  55
.................... delay_us(10);  		 
01B6:  MOVLW  02
01B7:  MOVWF  20
01B8:  DECFSZ 20,F
01B9:  GOTO   1B8
01BA:  GOTO   1BB
01BB:  NOP
.................... FadeRate 			= read_EEPROM ( FadeRateStore); 
01BC:  MOVLW  04
01BD:  BSF    03.5
01BE:  MOVWF  1B
01BF:  BCF    1C.7
01C0:  BSF    1C.0
01C1:  MOVF   1A,W
01C2:  BCF    03.5
01C3:  CLRF   58
01C4:  MOVWF  57
.................... delay_us(10); 
01C5:  MOVLW  02
01C6:  MOVWF  20
01C7:  DECFSZ 20,F
01C8:  GOTO   1C7
01C9:  GOTO   1CA
01CA:  NOP
.................... FadeTime 			= read_EEPROM ( FadeTimeStore ); 
01CB:  MOVLW  05
01CC:  BSF    03.5
01CD:  MOVWF  1B
01CE:  BCF    1C.7
01CF:  BSF    1C.0
01D0:  MOVF   1A,W
01D1:  BCF    03.5
01D2:  MOVWF  59
.................... delay_us(10); 
01D3:  MOVLW  02
01D4:  MOVWF  20
01D5:  DECFSZ 20,F
01D6:  GOTO   1D5
01D7:  GOTO   1D8
01D8:  NOP
.................... lampid 				= read_EEPROM ( ShortAddressStore ); 
01D9:  MOVLW  06
01DA:  BSF    03.5
01DB:  MOVWF  1B
01DC:  BCF    1C.7
01DD:  BSF    1C.0
01DE:  MOVF   1A,W
01DF:  BCF    03.5
01E0:  MOVWF  65
.................... delay_us(10); 
01E1:  MOVLW  02
01E2:  MOVWF  20
01E3:  DECFSZ 20,F
01E4:  GOTO   1E3
01E5:  GOTO   1E6
01E6:  NOP
....................  
.................... RandomAddress0 		= read_EEPROM ( RandomAddressStore0);  
01E7:  MOVLW  19
01E8:  BSF    03.5
01E9:  MOVWF  1B
01EA:  BCF    1C.7
01EB:  BSF    1C.0
01EC:  MOVF   1A,W
01ED:  BCF    03.5
01EE:  MOVWF  5A
.................... delay_us(10);   
01EF:  MOVLW  02
01F0:  MOVWF  20
01F1:  DECFSZ 20,F
01F2:  GOTO   1F1
01F3:  GOTO   1F4
01F4:  NOP
.................... RandomAddress1 		= read_EEPROM ( RandomAddressStore1);  
01F5:  MOVLW  1A
01F6:  BSF    03.5
01F7:  MOVWF  1B
01F8:  BCF    1C.7
01F9:  BSF    1C.0
01FA:  MOVF   1A,W
01FB:  BCF    03.5
01FC:  MOVWF  5B
.................... delay_us(10); 
01FD:  MOVLW  02
01FE:  MOVWF  20
01FF:  DECFSZ 20,F
0200:  GOTO   1FF
0201:  GOTO   202
0202:  NOP
.................... RandomAddress2 		= read_EEPROM ( RandomAddressStore2); 
0203:  MOVLW  1B
0204:  BSF    03.5
0205:  MOVWF  1B
0206:  BCF    1C.7
0207:  BSF    1C.0
0208:  MOVF   1A,W
0209:  BCF    03.5
020A:  MOVWF  5C
.................... delay_us(10); 
020B:  MOVLW  02
020C:  MOVWF  20
020D:  DECFSZ 20,F
020E:  GOTO   20D
020F:  GOTO   210
0210:  NOP
....................   		 
.................... FastFadeTime 		= read_EEPROM ( FastFadeTimeStore);  
0211:  MOVLW  1C
0212:  BSF    03.5
0213:  MOVWF  1B
0214:  BCF    1C.7
0215:  BSF    1C.0
0216:  MOVF   1A,W
0217:  BCF    03.5
0218:  MOVWF  5D
.................... delay_us(10); 		 
0219:  MOVLW  02
021A:  MOVWF  20
021B:  DECFSZ 20,F
021C:  GOTO   21B
021D:  GOTO   21E
021E:  NOP
.................... FailureStatus 		= read_EEPROM ( FailureStatusStore);  
021F:  MOVLW  1D
0220:  BSF    03.5
0221:  MOVWF  1B
0222:  BCF    1C.7
0223:  BSF    1C.0
0224:  MOVF   1A,W
0225:  BCF    03.5
0226:  MOVWF  5E
.................... delay_us(10);  
0227:  MOVLW  02
0228:  MOVWF  20
0229:  DECFSZ 20,F
022A:  GOTO   229
022B:  GOTO   22C
022C:  NOP
.................... OperatingMode 		= read_EEPROM ( OperatingModeStore);  
022D:  MOVLW  1E
022E:  BSF    03.5
022F:  MOVWF  1B
0230:  BCF    1C.7
0231:  BSF    1C.0
0232:  MOVF   1A,W
0233:  BCF    03.5
0234:  MOVWF  5F
.................... delay_us(10); 
0235:  MOVLW  02
0236:  MOVWF  20
0237:  DECFSZ 20,F
0238:  GOTO   237
0239:  GOTO   23A
023A:  NOP
.................... DimmingCurv 		= read_EEPROM ( DimmingCurveStore); 
023B:  MOVLW  1F
023C:  BSF    03.5
023D:  MOVWF  1B
023E:  BCF    1C.7
023F:  BSF    1C.0
0240:  MOVF   1A,W
0241:  BCF    03.5
0242:  MOVWF  60
.................... delay_us(10);  
0243:  MOVLW  02
0244:  MOVWF  20
0245:  DECFSZ 20,F
0246:  GOTO   245
0247:  GOTO   248
0248:  NOP
.................... zoneid=read_EEPROM(zoneidstore); 
0249:  MOVLW  20
024A:  BSF    03.5
024B:  MOVWF  1B
024C:  BCF    1C.7
024D:  BSF    1C.0
024E:  MOVF   1A,W
024F:  BCF    03.5
0250:  MOVWF  47
0251:  RETURN
....................  
.................... } 
....................  
....................  

Configuration Fuses:
   Word  1: 33D4   INTRC_IO NOWDT NOPUT NOMCLR NOPROTECT NOCPD BROWNOUT NOIESO NOFCMEN

ROM data:
002100: 0064 0032 0000 0064 0005 0006 0041 0001 
002108: 0000 0006 0007 0008 

002120: 00FF 
