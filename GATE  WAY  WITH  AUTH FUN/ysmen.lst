CCS PCM C Compiler, Version 5.015, 5967               08-Jun-21 13:25

               Filename:   D:\home automation codes\nisar house\gateway 628a - modified retransmission\GATE  WAY  WITH  AUTH FUN\ysmen.lst

               ROM used:   930 words (45%)
                           Largest free fragment is 1118
               RAM used:   101 (45%) at main() level
                           106 (47%) worst case
               Stack used: 4 locations (2 in main + 2 for interrupts)
               Stack size: 8

*
0000:  MOVLW  02
0001:  MOVWF  0A
0002:  GOTO   2A0
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   7F,W
0009:  MOVWF  20
000A:  MOVF   0A,W
000B:  MOVWF  27
000C:  CLRF   0A
000D:  SWAPF  20,F
000E:  MOVF   04,W
000F:  MOVWF  22
0010:  MOVF   77,W
0011:  MOVWF  23
0012:  MOVF   78,W
0013:  MOVWF  24
0014:  MOVF   79,W
0015:  MOVWF  25
0016:  MOVF   7A,W
0017:  MOVWF  26
0018:  BCF    03.7
0019:  BCF    03.5
001A:  BTFSS  0B.5
001B:  GOTO   01E
001C:  BTFSC  0B.2
001D:  GOTO   149
001E:  BTFSS  0B.4
001F:  GOTO   022
0020:  BTFSC  0B.1
0021:  GOTO   04E
0022:  MOVLW  8C
0023:  MOVWF  04
0024:  BTFSS  00.5
0025:  GOTO   028
0026:  BTFSC  0C.5
0027:  GOTO   181
0028:  MOVLW  8C
0029:  MOVWF  04
002A:  BTFSS  00.0
002B:  GOTO   02E
002C:  BTFSC  0C.0
002D:  GOTO   087
002E:  MOVLW  8C
002F:  MOVWF  04
0030:  BTFSS  00.2
0031:  GOTO   034
0032:  BTFSC  0C.2
0033:  GOTO   17E
0034:  MOVF   22,W
0035:  MOVWF  04
0036:  MOVF   23,W
0037:  MOVWF  77
0038:  MOVF   24,W
0039:  MOVWF  78
003A:  MOVF   25,W
003B:  MOVWF  79
003C:  MOVF   26,W
003D:  MOVWF  7A
003E:  MOVF   27,W
003F:  MOVWF  0A
0040:  SWAPF  21,W
0041:  MOVWF  03
0042:  SWAPF  7F,F
0043:  SWAPF  7F,W
0044:  RETFIE
....................  
.................... #include <ysmen.h> 
.................... #include <16F628A.h> 
.................... //////////// Standard Header file for the PIC16F628A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F628A 
0045:  BCF    0A.0
0046:  BCF    0A.1
0047:  BCF    0A.2
0048:  ADDWF  02,F
0049:  RETLW  7E
004A:  RETLW  7E
004B:  RETLW  7E
004C:  RETLW  7E
004D:  RETLW  00
....................  
.................... #list 
....................  
....................  
.................... //#FUSES WDT                 	//No Watch Dog Timer 
.................... //#FUSES xt 
.................... #FUSES INTRC_IO                      	//Crystal osc <= 4mhz for PCM/PCH , 3mhz to 10 mhz for PCD 
.................... #FUSES PUT                 	//No Power Up Timer 
.................... #FUSES PROTECT             	//Code not protected from reading 
.................... #FUSES BROWNOUT            	//No brownout reset 
.................... #FUSES MCLR                  	//Master Clear pin enabled 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOCPD                 	//No EE protection 
....................  
.................... #use delay(clock=4000000,RESTART_WDT) 
*
020F:  MOVLW  12
0210:  SUBWF  26,F
0211:  BTFSS  03.0
0212:  GOTO   222
0213:  MOVLW  A6
0214:  MOVWF  04
0215:  BCF    03.7
0216:  MOVLW  FC
0217:  ANDWF  00,F
0218:  BCF    03.0
0219:  RRF    00,F
021A:  RRF    00,F
021B:  MOVF   00,W
021C:  BTFSC  03.2
021D:  GOTO   222
021E:  GOTO   220
021F:  CLRWDT
0220:  DECFSZ 00,F
0221:  GOTO   21F
....................  
.................... #use rs232(baud=9600,parity=N,xmit=PIN_b2,rcv=PIN_b1,bits=8,DISABLE_INTS,ERRORS) 
*
0183:  BTFSS  0C.5
0184:  GOTO   183
0185:  MOVF   18,W
0186:  MOVWF  28
0187:  MOVF   1A,W
0188:  MOVWF  78
0189:  BTFSS  28.1
018A:  GOTO   18D
018B:  BCF    18.4
018C:  BSF    18.4
*
01AB:  BTFSS  0C.4
01AC:  GOTO   1AB
01AD:  BSF    03.5
01AE:  MOVF   23,W
01AF:  BCF    03.5
01B0:  MOVWF  19
01B1:  RETURN
....................  
.................... setup_adc( ADC_OFF ); 
.................... //#use rs232(baud=19200,parity=N,xmit=PIN_b2,rcv=PIN_b1,bits=8,TIMEOUT=X 
....................  
....................  
.................... #include <dali.c> 
....................  
....................  
.................... char DL_dataCount; 
.................... char DL_a,DL_b,oddevenbit,error_flag,over_flowflag,r_a; 
.................... char addr; 
.................... char r_duty; 
.................... char sc; 
.................... char pre_command; 
.................... char rec_count,rec_time; 
.................... char DL_bitcount; 
.................... char settling_time; 
.................... extern char  step,pos; 
....................  
.................... int1 txmit_error; 
....................  
....................  
.................... char DL_data[3], DL_tx_buffer[3];   
.................... char DL_j,DL_n,replay,zoneAdPir; 
....................  
.................... // variables and flags for the function recive dat 
....................  
.................... char stopBitCount,DL_Address ,DL_Databyte,DL_command ;	 
.................... char DL_dataready=0,forwrdFrameFlag,backwardFrameFlag ,masterFlag,zoneAdLight ; 
....................  
....................  
.................... #define  rx pin_B0 
.................... #define  tx pin_A2 
....................  
.................... #bit intf = 0x0b.1 
.................... //#bit timerOnOff =0x10.0 
.................... int1 tx_status=0; 
....................  
....................  
....................  
.................... #define MinIntencity   100 
.................... #define MaxIntencity 150 
....................  
.................... void DL_ReadData(void);  
.................... void stopbit(void); 
.................... int txmit(char priority,char length); 
.................... void DL_copyData(void); 
.................... void txmit0(void); 
.................... void txmit1(void); 
.................... void repalyHandle(void); 
....................  
.................... void lamp_on(char add); 
.................... void lamp_off(char add); 
.................... void bright_lamp (char lamp_add); 
.................... void dim_lamp (char lamp_add); 
.................... void bright_zone(char); 
.................... void dim_zone(char); 
.................... void store(char sc); 
.................... void scene(int sce); 
.................... void setAutoSensorEnable(void); 
.................... void setAutoSensorDisable(void); 
.................... void replaysensorLight(void); 
.................... void replaysensorPIR(void); 
.................... void fan_pos(char); 
....................  
....................  
....................  
....................  
....................  
....................  
.................... //				trnsmission of  bit 1			// 
.................... /********************************************************************* 
....................  * Function:       void txmit0(void); 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          transmission of  bit 1 to the bus	 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
.................... **********************************************************************/ 
.................... void txmit1(void) 
.................... {    
....................  
....................   	txmit_error = 0; 
01B2:  BCF    3A.0
.................... 	if (input(rx)==1) 
01B3:  BSF    03.5
01B4:  BSF    06.0
01B5:  BCF    03.5
01B6:  BTFSS  06.0
01B7:  GOTO   1BC
.................... 	{   
.................... 		output_bit(tx,0); 
01B8:  BCF    05.2
01B9:  BSF    03.5
01BA:  BCF    05.2
01BB:  BCF    03.5
.................... 	} 
.................... 	delay_us(79); 
01BC:  CLRWDT
01BD:  MOVLW  19
01BE:  MOVWF  77
01BF:  DECFSZ 77,F
01C0:  GOTO   1BF
01C1:  GOTO   1C2
.................... 	if (input(rx)==1) 
01C2:  BSF    03.5
01C3:  BSF    06.0
01C4:  BCF    03.5
01C5:  BTFSS  06.0
01C6:  GOTO   1CD
.................... 	{ 
.................... 		output_bit(tx,1); 
01C7:  BSF    05.2
01C8:  BSF    03.5
01C9:  BCF    05.2
.................... 		txmit_error = 1; 
01CA:  BCF    03.5
01CB:  BSF    3A.0
.................... 		return; 
01CC:  GOTO   206
.................... 	}			   
.................... 	delay_us(290);///old value 340 
01CD:  CLRWDT
01CE:  MOVLW  5F
01CF:  MOVWF  77
01D0:  DECFSZ 77,F
01D1:  GOTO   1D0
01D2:  GOTO   1D3
01D3:  NOP
.................... 	if (input(rx)==0) 
01D4:  BSF    03.5
01D5:  BSF    06.0
01D6:  BCF    03.5
01D7:  BTFSC  06.0
01D8:  GOTO   1DE
.................... 	{ 
.................... 		output_bit(tx,1); 
01D9:  BSF    05.2
01DA:  BSF    03.5
01DB:  BCF    05.2
.................... 	} 
01DC:  GOTO   1E5
01DD:  BCF    03.5
.................... 	else 
.................... 	{ 
.................... 		output_bit(tx,1); 
01DE:  BSF    05.2
01DF:  BSF    03.5
01E0:  BCF    05.2
.................... 		txmit_error = 1; 
01E1:  BCF    03.5
01E2:  BSF    3A.0
.................... 		return; 
01E3:  GOTO   206
01E4:  BSF    03.5
.................... 	} 
.................... 	delay_us(79); 
01E5:  CLRWDT
01E6:  MOVLW  19
01E7:  MOVWF  77
01E8:  DECFSZ 77,F
01E9:  GOTO   1E8
01EA:  GOTO   1EB
.................... 	if (input(rx)==0) 
01EB:  BSF    06.0
01EC:  BCF    03.5
01ED:  BTFSC  06.0
01EE:  GOTO   1F5
.................... 	{ 
.................... 		output_bit(tx,1); 
01EF:  BSF    05.2
01F0:  BSF    03.5
01F1:  BCF    05.2
.................... 		txmit_error = 1; 
01F2:  BCF    03.5
01F3:  BSF    3A.0
.................... 		return; 
01F4:  GOTO   206
.................... 	} 
....................     delay_us(290); ///old value 270 
01F5:  CLRWDT
01F6:  MOVLW  5F
01F7:  MOVWF  77
01F8:  DECFSZ 77,F
01F9:  GOTO   1F8
01FA:  GOTO   1FB
01FB:  NOP
.................... 	if (input(rx)==0) 
01FC:  BSF    03.5
01FD:  BSF    06.0
01FE:  BCF    03.5
01FF:  BTFSC  06.0
0200:  GOTO   206
.................... 	{ 
.................... 		output_bit(tx,1); 
0201:  BSF    05.2
0202:  BSF    03.5
0203:  BCF    05.2
.................... 		txmit_error = 1; 
0204:  BCF    03.5
0205:  BSF    3A.0
.................... 		return; 
.................... 	} 
....................     return; 
0206:  RETURN
.................... } 
....................  
.................... //         transmission of 0 to the bus      // 
.................... /********************************************************************* 
....................  * Function:       void txmit0(void); 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          transmission of  0 bit to the bus	 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
.................... **********************************************************************/ 
.................... void txmit0(void) 
.................... { 
.................... 	txmit_error = 0;	 
*
0247:  BCF    3A.0
.................... 	output_bit(tx,1); 
0248:  BSF    05.2
0249:  BSF    03.5
024A:  BCF    05.2
.................... 	delay_us(79); 
024B:  CLRWDT
024C:  MOVLW  19
024D:  MOVWF  77
024E:  DECFSZ 77,F
024F:  GOTO   24E
0250:  GOTO   251
.................... 	if (input(rx)!=1) 
0251:  BSF    06.0
0252:  BCF    03.5
0253:  BTFSC  06.0
0254:  GOTO   257
.................... 	{		 
.................... 		txmit_error = 1; 
0255:  BSF    3A.0
.................... 		return; 
0256:  GOTO   288
.................... 	}    
.................... 	delay_us(290); 
0257:  CLRWDT
0258:  MOVLW  5F
0259:  MOVWF  77
025A:  DECFSZ 77,F
025B:  GOTO   25A
025C:  GOTO   25D
025D:  NOP
.................... 	if (input(rx)==1) 
025E:  BSF    03.5
025F:  BSF    06.0
0260:  BCF    03.5
0261:  BTFSS  06.0
0262:  GOTO   268
.................... 	{ 
.................... 		output_bit(tx,0); 
0263:  BCF    05.2
0264:  BSF    03.5
0265:  BCF    05.2
.................... 	} 
0266:  GOTO   26F
0267:  BCF    03.5
....................     else 
.................... 	{ 
.................... 		output_bit(tx,1); 
0268:  BSF    05.2
0269:  BSF    03.5
026A:  BCF    05.2
.................... 		txmit_error = 1; 
026B:  BCF    03.5
026C:  BSF    3A.0
.................... 		return; 
026D:  GOTO   288
026E:  BSF    03.5
.................... 	} 
....................     delay_us(79);  
026F:  CLRWDT
0270:  MOVLW  19
0271:  MOVWF  77
0272:  DECFSZ 77,F
0273:  GOTO   272
0274:  GOTO   275
....................     if (input(rx)==1) 
0275:  BSF    06.0
0276:  BCF    03.5
0277:  BTFSS  06.0
0278:  GOTO   27B
.................... 	{		 
.................... 		txmit_error = 1; 
0279:  BSF    3A.0
.................... 		return; 
027A:  GOTO   288
.................... 	} 
....................     delay_us(290); ///old value 334 
027B:  CLRWDT
027C:  MOVLW  5F
027D:  MOVWF  77
027E:  DECFSZ 77,F
027F:  GOTO   27E
0280:  GOTO   281
0281:  NOP
.................... 	if (input(rx)==1) 
0282:  BSF    03.5
0283:  BSF    06.0
0284:  BCF    03.5
0285:  BTFSS  06.0
0286:  GOTO   288
.................... 	{		 
.................... 		txmit_error = 1; 
0287:  BSF    3A.0
.................... 		return; 
.................... 	} 
....................     return; 
.................... } 
.................... //         transmission of 2 bits to the bus		// 
.................... /********************************************************************* 
....................  * Function:       void txmit(char priority,char length); 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          transmission of  2 bits to the bus	 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
.................... **********************************************************************/ 
.................... int txmit(char priority,char length) 
.................... { 
....................  
.................... 	DL_j= 8*length; 
*
0226:  BSF    03.5
0227:  RLF    24,W
0228:  BCF    03.5
0229:  MOVWF  41
022A:  RLF    41,F
022B:  RLF    41,F
022C:  MOVLW  F8
022D:  ANDWF  41,F
.................... 	while (settling_time < 12+priority);      // priority	 
022E:  MOVLW  0C
022F:  BSF    03.5
0230:  ADDWF  23,W
0231:  BCF    03.5
0232:  SUBWF  37,W
0233:  BTFSS  03.0
0234:  GOTO   22E
....................     disable_interrupts(global);	 
0235:  BCF    0B.6
0236:  BCF    0B.7
0237:  BTFSC  0B.7
0238:  GOTO   236
.................... 	txmit1();         // start bit 
0239:  CALL   1B2
.................... 	for(DL_n=0;DL_n<DL_j;DL_n++) 
023A:  CLRF   42
023B:  MOVF   41,W
023C:  SUBWF  42,W
023D:  BTFSC  03.0
023E:  GOTO   28C
.................... 	{ 
.................... 		if (shift_left(DL_tx_buffer,3,1)==1) 
023F:  BSF    03.0
0240:  RLF    3E,F
0241:  RLF    3F,F
0242:  RLF    40,F
0243:  BTFSS  03.0
0244:  GOTO   247
.................... 		{ 
.................... 			txmit1(); 
0245:  CALL   1B2
.................... 		} 
0246:  GOTO   288
.................... 		else 
.................... 		{ 
.................... 			txmit0(); 
.................... 		} 
.................... 		if (txmit_error ==1) 
*
0288:  BTFSC  3A.0
.................... 		{ 
.................... 			goto endx; 
0289:  GOTO   290
.................... 		} 
028A:  INCF   42,F
028B:  GOTO   23B
.................... 	}  
.................... 	stopbit(); stopbit();	 
028C:  CALL   207
028D:  CALL   207
.................... 	stopbit(); stopbit();	 
028E:  CALL   207
028F:  CALL   207
.................... 	endx:output_bit(tx,1); 
0290:  BSF    05.2
0291:  BSF    03.5
0292:  BCF    05.2
.................... 	settling_time = 0; 
0293:  BCF    03.5
0294:  CLRF   37
.................... 	intf = 0; 
0295:  BCF    0B.1
.................... 	DL_dataCount=0; 
0296:  CLRF   29
.................... 	tx_status=1;	 
0297:  BSF    3A.1
.................... 	enable_interrupts(global);	 
0298:  MOVLW  C0
0299:  IORWF  0B,F
.................... 	enable_interrupts(INT_RTCC); 
029A:  BSF    0B.5
....................  
.................... 	return txmit_error; 
029B:  MOVLW  00
029C:  BTFSC  3A.0
029D:  MOVLW  01
029E:  MOVWF  78
029F:  RETURN
.................... } 
....................  
.................... //   transmission of stopbit to the bus		// 
.................... /********************************************************************* 
....................  * Function:       void  stopbit(void); 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          transmission of stopbit to the bus	 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
.................... **********************************************************************/ 
....................  
.................... void  stopbit(void) 
.................... { 
.................... output_bit(tx,1); 
*
0207:  BSF    05.2
0208:  BSF    03.5
0209:  BCF    05.2
.................... delay_us(830); 
020A:  CLRWDT
020B:  MOVLW  04
020C:  MOVWF  25
020D:  MOVLW  CC
020E:  MOVWF  26
*
0222:  DECFSZ 25,F
0223:  GOTO   20D
.................... return; 
0224:  BCF    03.5
0225:  RETURN
.................... } 
.................... //***************************************************************************** 
....................  
.................... // dali recive functions /////////// 
.................... /********************************************************************* 
....................  * Function:       void  readData(void)); 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          reception function 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
.................... **********************************************************************/ 
....................  
.................... void DL_ReadData(void) 
.................... { 
....................  
.................... 	error_flag=0; 
*
00DF:  CLRF   2D
.................... 	DL_dataCount++; 
00E0:  INCF   29,F
....................       forwrdFrameFlag = 0; 
00E1:  CLRF   4A
.................... 	  backwardFrameFlag =0; 
00E2:  CLRF   4B
.................... 	if(DL_dataCount < 27) 
00E3:  MOVF   29,W
00E4:  SUBLW  1A
00E5:  BTFSS  03.0
00E6:  GOTO   13E
.................... 	{ 
.................... 		if((DL_a==0 )&& (DL_b==1)) 
00E7:  MOVF   2A,F
00E8:  BTFSS  03.2
00E9:  GOTO   0F1
00EA:  DECFSZ 2B,W
00EB:  GOTO   0F1
.................... 	    { 
.................... 			shift_left(DL_data,3,1); 
00EC:  BSF    03.0
00ED:  RLF    3B,F
00EE:  RLF    3C,F
00EF:  RLF    3D,F
.................... 		} 
00F0:  GOTO   13D
.................... 		else if((DL_a==1)&&(DL_b==0)) 
00F1:  DECFSZ 2A,W
00F2:  GOTO   0FB
00F3:  MOVF   2B,F
00F4:  BTFSS  03.2
00F5:  GOTO   0FB
.................... 		{ 
.................... 			shift_left(DL_data,3,0); 
00F6:  BCF    03.0
00F7:  RLF    3B,F
00F8:  RLF    3C,F
00F9:  RLF    3D,F
.................... 		} 
00FA:  GOTO   13D
.................... 		else if ( DL_a==1 && DL_b==1) 
00FB:  DECFSZ 2A,W
00FC:  GOTO   137
00FD:  DECFSZ 2B,W
00FE:  GOTO   137
.................... 		{ 
....................  
.................... 			switch (DL_dataCount) 
00FF:  MOVF   29,W
0100:  XORLW  11
0101:  BTFSC  03.2
0102:  GOTO   10D
0103:  XORLW  03
0104:  BTFSC  03.2
0105:  GOTO   10F
0106:  XORLW  0B
0107:  BTFSC  03.2
0108:  GOTO   11F
0109:  XORLW  03
010A:  BTFSC  03.2
010B:  GOTO   121
010C:  GOTO   130
.................... 			{ 
.................... 			case 17: 
....................                { 
....................                      stopBitCount ++; 
010D:  INCF   45,F
....................                      break; 
010E:  GOTO   136
....................                } 
....................                case 18: 
....................                { 
....................                   stopBitCount ++; 
010F:  INCF   45,F
....................                   if(stopBitCount == 2) 
0110:  MOVF   45,W
0111:  SUBLW  02
0112:  BTFSS  03.2
0113:  GOTO   11C
....................                   { 
....................                         r_a=1;  
0114:  MOVLW  01
0115:  MOVWF  2F
....................                         dl_copyData(); 
0116:  CALL   06C
....................                         forwrdFrameFlag = 1; 
0117:  MOVLW  01
0118:  MOVWF  4A
....................                         masterflag = 0; 
0119:  CLRF   4C
....................                         backwardFrameFlag =0; 
011A:  CLRF   4B
....................  
....................                   } 
011B:  GOTO   11E
....................                   else 
....................                   { 
.................... 						error_flag =1; 
011C:  MOVLW  01
011D:  MOVWF  2D
....................                   } 
....................                   break; 
011E:  GOTO   136
....................                } 
....................               	case 25: 
.................... 				{ 
.................... 					stopBitCount ++; 
011F:  INCF   45,F
.................... 					break; 
0120:  GOTO   136
.................... 				} 
....................               	case 26:  
.................... 				{ 
.................... 					stopBitCount ++; 
0121:  INCF   45,F
.................... 					if(stopBitCount == 2) 
0122:  MOVF   45,W
0123:  SUBLW  02
0124:  BTFSS  03.2
0125:  GOTO   12D
.................... 					{ 
.................... 						r_a=0;  
0126:  CLRF   2F
.................... 						dl_copyData(); 
0127:  CALL   06C
.................... 						forwrdFrameFlag =0; 
0128:  CLRF   4A
.................... 						masterflag = 1; 
0129:  MOVLW  01
012A:  MOVWF  4C
.................... 						backwardFrameFlag =0; 
012B:  CLRF   4B
.................... 					} 
012C:  GOTO   12F
.................... 					else 
.................... 					{ 
.................... 						error_flag =1; 
012D:  MOVLW  01
012E:  MOVWF  2D
.................... 					} 
.................... 					break; 
012F:  GOTO   136
.................... 				} 
....................                 default: 
....................                 { 
....................                       error_flag=1; 
0130:  MOVLW  01
0131:  MOVWF  2D
....................                       setup_timer_1(T1_disabled); 
0132:  CLRF   10
....................                       enable_interrupts(INT_EXT); 
0133:  BSF    0B.4
.................... 					  enable_interrupts(INT_RTCC);  
0134:  BSF    0B.5
....................                       settling_time = 0; 
0135:  CLRF   37
....................                       break; 
....................                 } 
....................              }    
....................           }  
0136:  GOTO   13D
.................... 		else 
.................... 		{ 
.................... 			error_flag=1;     
0137:  MOVLW  01
0138:  MOVWF  2D
.................... 			settling_time = 0; 
0139:  CLRF   37
.................... 			setup_timer_1(T1_disabled);        
013A:  CLRF   10
.................... 			enable_interrupts(INT_EXT);        
013B:  BSF    0B.4
.................... 			enable_interrupts(INT_RTCC);          
013C:  BSF    0B.5
.................... 		} 
....................       } 
013D:  GOTO   144
.................... 	else  // the  data count grater than 27  
.................... 	{ 
.................... 		over_flowflag =1 ; 
013E:  MOVLW  01
013F:  MOVWF  2E
.................... 		settling_time = 0; 
0140:  CLRF   37
.................... 		setup_timer_1(T1_disabled);        
0141:  CLRF   10
.................... 		enable_interrupts(INT_EXT);        
0142:  BSF    0B.4
.................... 		enable_interrupts(INT_RTCC);          
0143:  BSF    0B.5
.................... 	} 
....................  
....................     return; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void DL_copyData(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:			storing of data into buffer 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
....................  
.................... void DL_copyData(void) 
.................... { 
....................  
.................... 	DL_dataReady =1; 
*
006C:  MOVLW  01
006D:  MOVWF  49
.................... 	if( r_a==1) 
006E:  DECFSZ 2F,W
006F:  GOTO   075
.................... 	{ 
.................... 		DL_Address = DL_data[1]; 
0070:  MOVF   3C,W
0071:  MOVWF  46
.................... 		DL_command =DL_data[0]; 
0072:  MOVF   3B,W
0073:  MOVWF  48
.................... 	} 
0074:  GOTO   07E
....................  
.................... 	else if( r_a==0) 
0075:  MOVF   2F,F
0076:  BTFSS  03.2
0077:  GOTO   07E
.................... 	{	  
.................... 		DL_address = DL_data[2]; 
0078:  MOVF   3D,W
0079:  MOVWF  46
.................... 		DL_command =DL_data[1]; 
007A:  MOVF   3C,W
007B:  MOVWF  48
.................... 		DL_databyte=DL_data[0];  
007C:  MOVF   3B,W
007D:  MOVWF  47
.................... 		 
.................... 	}        
....................     setup_timer_1(T1_disabled); 
007E:  CLRF   10
....................     intf =0; 
007F:  BCF    0B.1
....................     enable_interrupts(INT_EXT); 
0080:  BSF    0B.4
....................     disable_interrupts(int_timer1); 
0081:  BSF    03.5
0082:  BCF    0C.0
....................     enable_interrupts(INT_RTCC); 
0083:  BCF    03.5
0084:  BSF    0B.5
....................     settling_time = 0; 
0085:  CLRF   37
....................     return; 
0086:  RETURN
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:       replay(); 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          replay handling 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
.................... **********************************************************************/ 
.................... void repalyHandle(void) 
.................... {   
.................... 	if(forwrdFrameFlag==1) 
.................... 		{			 
.................... 			 
....................          	if(DL_Address>0x70&&DL_Address<=0x79) 
.................... 			{ 
.................... 				//if(replay==1) 
.................... 				//{ 
.................... 					zoneAdPir =  DL_Address +79; 
.................... 					replaysensorPIR();					 
.................... 				//}			 
.................... 			} 
.................... 			 else if(DL_Address>0x80&&DL_Address<=0x89) 
.................... 			{ 
.................... 				//if(replay==1) 
.................... 				//{ 
.................... 					zoneAdLight =  DL_Address +64; 
.................... 					replaysensorLight(); 
.................... 				//}			 
.................... 			} 
.................... 			else 
.................... 			{ 
.................... 	 
.................... 				switch (pre_command) 
.................... 				{ 
.................... 					case 234: // sccen  
.................... 					{ 
.................... 						if(DL_Databyte==sc) 
.................... 							{ 
.................... 							rec_count++;						 
.................... 						    } 
.................... 					break; 
.................... 					} 
.................... 					case 208: // lam on  
.................... 					{ 
.................... 				     	if( bit_test(DL_Databyte,7)==1)  
.................... 							{ 
.................... 							r_duty=DL_Databyte&0x7f; 
.................... 							set_pwm1_duty(r_duty); 
.................... 							} 
.................... 						else 
.................... 							{ 
.................... 								delay_ms(30); 
.................... 								lamp_on(addr); 
.................... 							} 
.................... 					break; 
.................... 					} 
.................... 					case 212: //lamp off 
.................... 					{ 
.................... 		                if( bit_test(DL_Databyte,7)==0)  
.................... 							{ 
.................... 							set_pwm1_duty(00); 
.................... 							} 
.................... 						else 
.................... 							{ 
.................... 								delay_ms(30); 
.................... 								lamp_off(addr); 
.................... 							} 
.................... 					 
.................... 					break; 
.................... 					} 
.................... 					case 220: 
.................... 					{ 
.................... 	                if( bit_test(DL_Databyte,7)==1)  
.................... 							{ 
.................... 							r_duty=DL_Databyte&0x7f; 
.................... 							set_pwm1_duty(r_duty); 
.................... 							} 
.................... 					break; 
.................... 					} 
.................... 					case 216: 
.................... 					{ 
.................... 					if( bit_test(DL_Databyte,7)==1)  
.................... 							{ 
.................... 							r_duty=DL_Databyte&0x7f; 
.................... 							set_pwm1_duty(r_duty); 
.................... 							} 
.................... 					break; 
.................... 					} 
.................... 				} 
.................... 			} 
.................... 		} 
....................  
.................... 	else if(backwardFrameFlag ==1) 
.................... 	{} 
.................... 	else if(masterFlag ==1) 
.................... 	{} 
.................... return; 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:       void lamp_on(char addr); 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:         transmitting the data to make the lamp on 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
.................... ***********************************************************************/ 
.................... void lamp_on(char addr) 
.................... { 
.................... //printf("\n \r LAMP ON"); 
.................... pre_command=208; 
.................... DL_tx_buffer[2] = addr; 
.................... DL_tx_buffer[1] =208; //command 
.................... DL_tx_buffer[0] = addr;// addreass 
.................... txmit(0,2); 
.................... return; 
.................... } 
.................... /********************************************************************* 
....................  * Function:       void lamp_off(char addr); 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:         transmitting the data to make the lamp off 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
.................... ***********************************************************************/ 
.................... void lamp_off(char addr) 
.................... { 
.................... //printf("\n \r LAMP Off"); 
.................... pre_command=212; 
.................... DL_tx_buffer[2] = addr; 
.................... DL_tx_buffer[1] =212; //command 
.................... DL_tx_buffer[0] = addr;// addreass 
.................... txmit(1,2); 
.................... return; 
.................... } 
....................  
.................... // ....both single and group dim.../// 
.................... /********************************************************************* 
....................  * Function:       void dim_lamp(char lamp_addr); 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:         transmitting the data to dim the lamp 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
.................... ***********************************************************************/ 
....................  
.................... void dim_lamp (char lamp_add) 
.................... { 
....................    //printf("\n \r LAMP dim"); 
....................  
....................    pre_command=216; 
....................    DL_tx_buffer[2] = lamp_add;// addreass 
....................    DL_tx_buffer[1] =216; //command 
....................    DL_tx_buffer[0] = step; 
....................    txmit(0,3); 
....................    return; 
....................  
.................... } 
.................... /********************************************************************* 
....................  * Function:       void bright_lamp(char addr); 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:         transmitting the data to bright the lamp 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
.................... ***********************************************************************/ 
.................... void bright_lamp (char lamp_add) 
.................... { 
.................... 	//printf("\n \r LAMP bright"); 
.................... 	pre_command=220; 
.................... 	DL_tx_buffer[2] = lamp_add; 
.................... 	DL_tx_buffer[1] =220; //command 
.................... 	DL_tx_buffer[0] = step; 
.................... 	txmit(0,3); 
.................... 	return; 
.................... } 
....................  
.................... void fan_pos(char fan_addr) 
.................... { 
.................... 	 
.................... 	pre_command=220; 
.................... 	DL_tx_buffer[2] = fan_addr; 
.................... 	DL_tx_buffer[1] =100; //command 
.................... 	DL_tx_buffer[0] = pos; 
.................... 	txmit(0,3); 
.................... 	return; 
.................... } 
....................  
....................  
.................... void bright_zone(char zone_add) 
.................... { 
.................... //	printf("\n \r zone bright"); 
.................... 	pre_command=240; 
.................... 	DL_tx_buffer[2] = zone_add; 
.................... 	DL_tx_buffer[1] =240; //command 
.................... 	DL_tx_buffer[0] = zone_add;// addreass 
.................... 	txmit(0,2); 
....................     return; 
.................... } 
....................  
....................  
.................... void dim_zone(char zone_add) 
.................... {   
....................   // printf("\n \r zone dim");  
....................    pre_command=241; 
....................    DL_tx_buffer[2] = zone_add; 
....................    DL_tx_buffer[1] =241; //command 
....................    DL_tx_buffer[0] = zone_add;// addreass 
....................    txmit(0,2); 
....................    return; 
.................... } 
....................  
.................... void store(char sc) 
.................... { 
.................... //	printf("\n \r store");	 
.................... 	DL_tx_buffer[0] = sc; 
.................... 	DL_tx_buffer[1] = 231; 
.................... 	DL_tx_buffer[2] = 255; 
.................... 	txmit(1,3); 
.................... } 
....................  
.................... void scene(sc) 
.................... { 
.................... 	//	printf("\n \r scene");			 
.................... 		pre_command=234; 
.................... 		rec_time=5;  
.................... 		rec_count=0; 
.................... 		DL_tx_buffer[0] =sc ; 
.................... 		DL_tx_buffer[1] = 234; 
.................... 		DL_tx_buffer[2] = 255; 
.................... 		txmit(1,3); 
.................... } 
....................  
.................... void scene2(sc) 
.................... { 
.................... 	//	printf("\n \r scene");			 
.................... 		pre_command=234; 
.................... 		rec_time=5;  
.................... 		rec_count=0; 
.................... 		DL_tx_buffer[0] =sc ; 
.................... 		DL_tx_buffer[1] = 234; 
.................... 		DL_tx_buffer[2] = 255; 
.................... 		txmit(1,3); 
.................... } 
....................  
....................  
.................... void setAutoSensorEnable() 
.................... {	 
.................... 	replay=1;	 
.................... 	DL_tx_buffer[2] = 127; 
.................... 	DL_tx_buffer[1] =242; //command 
.................... 	DL_tx_buffer[0] = 127;// addreass 
.................... 	txmit(0,2); 
....................  
.................... } 
.................... void setAutoSensorDisable() 
.................... {	 
.................... 	replay=0;	 
.................... 	DL_tx_buffer[2] = 127; 
.................... 	DL_tx_buffer[1] =243; //command 
.................... 	DL_tx_buffer[0] = 127;// addreass 
.................... 	txmit(0,2); 
.................... } 
....................  
.................... void replaysensorPIR(void) 
.................... { 
....................  
.................... 	if(DL_Databyte==0xff) 
.................... 	{		 
.................... 		DL_tx_buffer[2] = zoneAdPir ; 
.................... 		DL_tx_buffer[1] = 222; //command 
.................... 		DL_tx_buffer[0] = zoneAdPir ;// addreass 
.................... 		txmit(0,2); 
.................... 		 
.................... 	} 
.................... 	else if(DL_Databyte==0) 
.................... 	{	 
.................... 		DL_tx_buffer[2] = zoneAdPir ; 
.................... 		DL_tx_buffer[1] =241; //command 
.................... 		DL_tx_buffer[0] = zoneAdPir ;// addreass 
.................... 		txmit(1,2); 
.................... 		txmit(1,2);	 
.................... 	} 
.................... } 
....................  
.................... void replaysensorLight(void) 
.................... { 
.................... if(DL_Databyte > MaxIntencity) 
.................... 	{		 
.................... 		DL_tx_buffer[2] = zoneAdLight; 
.................... 		DL_tx_buffer[1] =241; //command    // icrease intencityzone 
.................... 		DL_tx_buffer[0] = zoneAdLight;// addreass 
.................... 		txmit(0,2); 
.................... 	} 
.................... else if(DL_Databyte< MinIntencity) 
.................... 	{		 
.................... 		DL_tx_buffer[2] = zoneAdLight; 
.................... 		DL_tx_buffer[1] =240; //command  Dicease intencity  
.................... 		DL_tx_buffer[0] = zoneAdLight;// addreass 
.................... 		txmit(1,2); 
.................... 	} 
.................... } 
....................  
....................  
.................... /* 
.................... #define led1 PIN_a2 
.................... #define led2 PIN_a3 
.................... */ 
.................... char tempi =	16; 
....................  
.................... char answer; 
.................... char lampondelay; 
....................   
.................... char  step=2,pos; 
.................... char redCMD[8]; 
.................... char frameDelay; 
.................... char DatPoint; 
.................... char frameError; 
.................... char h; 
.................... char SeenNo; 
.................... char address; 
.................... char DataReady =0; 
.................... char dataRxd[10],rxv[10]; 
.................... int xindex,bufferIndex=0; 
.................... int datavalied=0; 
.................... char temp; 
....................  
.................... char count=0; 
.................... ///////////////// 
.................... int16 readDly=300; 
.................... int1 atmp; 
....................  
.................... ////////////// 
.................... int tx_error_check=0; 
.................... //////////// 
....................  
.................... char KB_delay=1; 
....................  
.................... int value; 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... #int_EXT 
.................... EXT_isr() 
.................... { 
.................... 	output_low(pin_a3); 
*
004E:  BSF    03.5
004F:  BCF    05.3
0050:  BCF    03.5
0051:  BCF    05.3
....................    disable_interrupts(int_ext); 
0052:  BCF    0B.4
....................    disable_interrupts(INT_RTCC);    
0053:  BCF    0B.5
....................    DL_bitcount=0; 
0054:  CLRF   36
....................    enable_interrupts(INT_TIMER1);    
0055:  BSF    03.5
0056:  BSF    0C.0
....................    setup_timer_1(T1_internal|T1_div_by_1);//settimer1with1us least count 
0057:  MOVLW  85
0058:  BCF    03.5
0059:  MOVWF  10
....................    set_timer1(0xffff-840);//928//5100//923 
005A:  CLRF   0E
005B:  MOVLW  FC
005C:  MOVWF  0F
005D:  MOVLW  B7
005E:  MOVWF  0E
....................    stopBitCount = 0; 
005F:  CLRF   45
....................    oddevenbit=1; 
0060:  MOVLW  01
0061:  MOVWF  2C
....................    DL_data[0]=0; 
0062:  CLRF   3B
....................    DL_data[1]=0; 
0063:  CLRF   3C
....................    DL_data[2]=0;    
0064:  CLRF   3D
....................    forwrdFrameFlag = 0; 
0065:  CLRF   4A
....................    masterflag = 0; 
0066:  CLRF   4C
....................    backwardFrameFlag =0;    
0067:  CLRF   4B
....................    DL_DataCount =0;	 
0068:  CLRF   29
.................... } 
0069:  BCF    0B.1
006A:  BCF    0A.3
006B:  GOTO   034
.................... #int_TIMER1 
.................... TIMER1_isr() 
.................... { 
.................... 	 
.................... readDly=20; 
*
0087:  CLRF   7E
0088:  MOVLW  14
0089:  MOVWF  7D
.................... error_flag=0; 
008A:  CLRF   2D
.................... 	if(oddevenbit==1) 
008B:  DECFSZ 2C,W
008C:  GOTO   0CC
.................... 	{ 
.................... 		output_high(pin_a3); 
008D:  BSF    03.5
008E:  BCF    05.3
008F:  BCF    03.5
0090:  BSF    05.3
.................... 		DL_a=input(rx);  
0091:  BSF    03.5
0092:  BSF    06.0
0093:  BCF    03.5
0094:  CLRF   2A
0095:  BTFSC  06.0
0096:  INCF   2A,F
.................... 		atmp=DL_a ;           
0097:  BCF    3A.2
0098:  BTFSC  2A.0
0099:  BSF    3A.2
.................... 		oddevenbit=0 ; 
009A:  CLRF   2C
.................... 		 
.................... 				if(atmp) 
009B:  BTFSS  3A.2
009C:  GOTO   0B3
.................... 				{ 
.................... 					while(atmp) 
009D:  BTFSS  3A.2
009E:  GOTO   0B2
.................... 						{ 
.................... 							atmp=input(rx); 
009F:  BSF    03.5
00A0:  BSF    06.0
00A1:  BCF    03.5
00A2:  BCF    3A.2
00A3:  BTFSC  06.0
00A4:  BSF    3A.2
.................... 							if(readDly>0) 
00A5:  MOVF   7D,F
00A6:  BTFSS  03.2
00A7:  GOTO   0AB
00A8:  MOVF   7E,F
00A9:  BTFSC  03.2
00AA:  GOTO   0B0
.................... 								readDly--; 
00AB:  MOVF   7D,W
00AC:  BTFSC  03.2
00AD:  DECF   7E,F
00AE:  DECF   7D,F
00AF:  GOTO   0B1
.................... 							else 
.................... 								atmp=0; 
00B0:  BCF    3A.2
00B1:  GOTO   09D
.................... 								 
.................... 						} 
.................... 				}          
00B2:  GOTO   0C4
.................... 				else 
.................... 				{ 
.................... 					while(!atmp) 
00B3:  BTFSC  3A.2
00B4:  GOTO   0C4
.................... 						{ 
.................... 							atmp=input(rx); 
00B5:  BSF    03.5
00B6:  BSF    06.0
00B7:  BCF    03.5
00B8:  BCF    3A.2
00B9:  BTFSC  06.0
00BA:  BSF    3A.2
.................... 							readDly--; 
00BB:  MOVF   7D,W
00BC:  BTFSC  03.2
00BD:  DECF   7E,F
00BE:  DECFSZ 7D,F
.................... 								if(readdly==0) 
00BF:  GOTO   0C3
00C0:  MOVF   7E,F
00C1:  BTFSC  03.2
.................... 									{ 
.................... 									atmp=1; 
00C2:  BSF    3A.2
.................... 									}	 
00C3:  GOTO   0B3
.................... 						} 
.................... 				} 
....................  
.................... 			setup_timer_1(T1_internal|T1_div_by_1);//settimer1with1us least count 
00C4:  MOVLW  85
00C5:  MOVWF  10
.................... 			set_timer1(0xffff-150);  //374  //  355             350////old value 150 
00C6:  CLRF   0E
00C7:  MOVLW  FF
00C8:  MOVWF  0F
00C9:  MOVLW  69
00CA:  MOVWF  0E
.................... 	} 
00CB:  GOTO   144
.................... 	else 
.................... 	{  
.................... 		output_low(pin_a3); 
00CC:  BSF    03.5
00CD:  BCF    05.3
00CE:  BCF    03.5
00CF:  BCF    05.3
.................... 		DL_b=input(rx) ; // store data line status in the second half 
00D0:  BSF    03.5
00D1:  BSF    06.0
00D2:  BCF    03.5
00D3:  CLRF   2B
00D4:  BTFSC  06.0
00D5:  INCF   2B,F
.................... 		oddevenbit=1; 
00D6:  MOVLW  01
00D7:  MOVWF  2C
.................... 		setup_timer_1(T1_internal|T1_div_by_1); 
00D8:  MOVLW  85
00D9:  MOVWF  10
.................... 		set_timer1(0xffff-350);  // delay  till the next call st to 73 us/////old value 350 
00DA:  CLRF   0E
00DB:  MOVLW  FE
00DC:  MOVWF  0F
00DD:  MOVLW  A1
00DE:  MOVWF  0E
.................... 		DL_ReadData();  // function  get the dat from the conditions of a and b 
.................... 					 
.................... 	} 
.................... return(0); 
*
0144:  MOVLW  00
0145:  MOVWF  78
....................   
....................  
.................... } 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
0146:  BCF    0C.0
0147:  BCF    0A.3
0148:  GOTO   034
.................... #int_RTCC 
....................   RTCC_isr(void)  
.................... {	//restart_wdt(); 
.................... //	output_toggle(PIN_C4); 
....................  
....................  
.................... 	if(frameDelay>0){frameDelay --;} 
0149:  MOVF   59,F
014A:  BTFSC  03.2
014B:  GOTO   14E
014C:  DECF   59,F
014D:  GOTO   175
.................... 	else if(bufferIndex >3 ) 
014E:  MOVF   75,W
014F:  SUBLW  03
0150:  BTFSC  03.0
0151:  GOTO   175
.................... 	{ 
.................... 		datavalied = 1; 
0152:  MOVLW  01
0153:  MOVWF  76
.................... 		for(xindex =0;xindex<9;xindex++) 
0154:  CLRF   74
0155:  MOVF   74,W
0156:  SUBLW  08
0157:  BTFSS  03.0
0158:  GOTO   174
.................... 		{ 
.................... 			dataRxd[xindex]= rxv[xindex]; 
0159:  MOVLW  60
015A:  ADDWF  74,W
015B:  MOVWF  78
015C:  CLRF   7A
015D:  BTFSC  03.0
015E:  INCF   7A,F
015F:  MOVF   78,W
0160:  BSF    03.5
0161:  MOVWF  27
0162:  MOVF   7A,W
0163:  MOVWF  28
0164:  MOVLW  6A
0165:  ADDWF  74,W
0166:  MOVWF  04
0167:  BCF    03.7
0168:  MOVF   00,W
0169:  MOVWF  29
016A:  MOVF   27,W
016B:  MOVWF  04
016C:  BCF    03.7
016D:  BTFSC  28.0
016E:  BSF    03.7
016F:  MOVF   29,W
0170:  MOVWF  00
0171:  INCF   74,F
0172:  BCF    03.5
0173:  GOTO   155
.................... 		} 
....................            bufferIndex=0; 
0174:  CLRF   75
.................... 	} 
....................    	if(settling_time< 24) 
0175:  MOVF   37,W
0176:  SUBLW  17
0177:  BTFSC  03.0
....................    	{		 
....................     	settling_time++; 
0178:  INCF   37,F
....................    	} 
.................... RETURN(1); 
0179:  MOVLW  01
017A:  MOVWF  78
.................... } 
....................  
....................  
017B:  BCF    0B.2
017C:  BCF    0A.3
017D:  GOTO   034
.................... #int_CCP1  
.................... void  CCP1_isr(void) 
.................... {  
....................  
....................  
.................... } 
....................  
017E:  BCF    0C.2
017F:  BCF    0A.3
0180:  GOTO   034
.................... #int_rda 
.................... void RDA_isr(void) 
.................... { 
....................  
.................... 		    frameDelay = 50; 
0181:  MOVLW  32
0182:  MOVWF  59
....................         	temp=getc();  
*
018D:  MOVF   78,W
018E:  MOVWF  7B
.................... 			if(temp == '*') 
018F:  MOVF   7B,W
0190:  SUBLW  2A
0191:  BTFSS  03.2
0192:  GOTO   19B
.................... 			{	 
.................... 				bufferIndex=0; 
0193:  CLRF   75
.................... 				rxv[bufferIndex] =temp;			 
0194:  MOVLW  6A
0195:  ADDWF  75,W
0196:  MOVWF  04
0197:  BCF    03.7
0198:  MOVF   7B,W
0199:  MOVWF  00
.................... 			}  
019A:  GOTO   1A8
.................... 			else 
.................... 			{ 
.................... 				if(bufferIndex < 8)	 
019B:  MOVF   75,W
019C:  SUBLW  07
019D:  BTFSS  03.0
019E:  GOTO   1A7
.................... 				{ 					 
.................... 					bufferIndex++;	 
019F:  INCF   75,F
.................... 					rxv[bufferIndex] =temp; 
01A0:  MOVLW  6A
01A1:  ADDWF  75,W
01A2:  MOVWF  04
01A3:  BCF    03.7
01A4:  MOVF   7B,W
01A5:  MOVWF  00
.................... 				} 
01A6:  GOTO   1A8
.................... 				else 
.................... 				{ 
.................... 					bufferIndex= 0; 
01A7:  CLRF   75
....................  
.................... 				} 
.................... 			}  
01A8:  BCF    0C.5
01A9:  BCF    0A.3
01AA:  GOTO   034
.................... } 
....................  
.................... void main() 
*
02A0:  MOVF   03,W
02A1:  ANDLW  1F
02A2:  MOVWF  03
02A3:  BSF    03.5
02A4:  BSF    0E.3
02A5:  BCF    03.5
02A6:  CLRF   28
02A7:  MOVLW  19
02A8:  BSF    03.5
02A9:  MOVWF  19
02AA:  MOVLW  A6
02AB:  MOVWF  18
02AC:  MOVLW  90
02AD:  BCF    03.5
02AE:  MOVWF  18
02AF:  CLRF   49
02B0:  BCF    3A.1
02B1:  MOVLW  10
02B2:  MOVWF  4E
02B3:  MOVLW  02
02B4:  MOVWF  38
02B5:  CLRF   5F
02B6:  CLRF   75
02B7:  CLRF   76
02B8:  CLRF   7C
02B9:  MOVLW  01
02BA:  MOVWF  7E
02BB:  MOVLW  2C
02BC:  MOVWF  7D
02BD:  BSF    03.5
02BE:  CLRF   20
02BF:  MOVLW  01
02C0:  MOVWF  21
02C1:  MOVLW  07
02C2:  BCF    03.5
02C3:  MOVWF  1F
02C4:  BCF    03.7
.................... { 
.................... 	rxv="~~~~"; 
02C5:  BSF    03.5
02C6:  CLRF   23
02C7:  CLRF   24
02C8:  MOVLW  6A
02C9:  MOVWF  04
02CA:  BCF    03.7
02CB:  MOVF   23,W
02CC:  ADDWF  04,F
02CD:  MOVF   24,W
02CE:  BCF    03.5
02CF:  CALL   045
02D0:  MOVWF  00
02D1:  IORLW  00
02D2:  BTFSC  03.2
02D3:  GOTO   2D9
02D4:  BSF    03.5
02D5:  INCF   24,F
02D6:  INCF   23,F
02D7:  GOTO   2C8
02D8:  BCF    03.5
.................... 	tempi =16; 
02D9:  MOVLW  10
02DA:  MOVWF  4E
.................... 	setup_comparator(NC_NC_NC_NC); 
02DB:  MOVLW  07
02DC:  MOVWF  1F
02DD:  BSF    03.5
02DE:  MOVF   05,W
02DF:  MOVWF  05
02E0:  CLRWDT
02E1:  MOVLW  02
02E2:  MOVWF  77
02E3:  DECFSZ 77,F
02E4:  GOTO   2E3
02E5:  GOTO   2E6
02E6:  BCF    03.5
02E7:  MOVF   1F,W
02E8:  BCF    0C.6
.................... 	setup_vref(FALSE); 
02E9:  BSF    03.5
02EA:  CLRF   1F
.................... 	setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1); 
02EB:  MOVF   01,W
02EC:  ANDLW  C7
02ED:  IORLW  08
02EE:  MOVWF  01
.................... //	setup_wdt(WDT_18MS); 
.................... 	setup_timer_1(T1_INTERNAL|T1_DIV_BY_1);     
02EF:  MOVLW  85
02F0:  BCF    03.5
02F1:  MOVWF  10
....................    setup_timer_2(T2_DISABLED,0,1); 
02F2:  MOVLW  00
02F3:  MOVWF  78
02F4:  MOVWF  12
02F5:  MOVLW  00
02F6:  BSF    03.5
02F7:  MOVWF  12
.................... 	//setup_ccp1(CCP_CAPTURE_FE);	; 
.................... 	ext_int_edge( H_TO_L );  
02F8:  BCF    01.6
.................... 	 
....................    disable_interrupts(INT_RB);   
02F9:  BCF    03.5
02FA:  BCF    0B.3
....................    disable_interrupts(INT_TBE); 
02FB:  BSF    03.5
02FC:  BCF    0C.4
....................    //disable_interrupts(INT_RDA); 
....................    disable_interrupts(INT_TIMER1); 
02FD:  BCF    0C.0
....................    disable_interrupts(INT_TIMER2);    
02FE:  BCF    0C.1
....................    disable_interrupts(INT_COMP); 
02FF:  BCF    0C.6
....................    //enable_interrupts(INT_TIMER0); 
....................    disable_interrupts(INT_EEPROM); 
0300:  BCF    0C.7
....................    	disable_interrupts(INT_CCP1); 
0301:  BCF    0C.2
.................... 	enable_interrupts(int_rtcc); 
0302:  BCF    03.5
0303:  BSF    0B.5
.................... 	enable_interrupts(INT_RDA); 
0304:  BSF    03.5
0305:  BSF    0C.5
.................... 	enable_interrupts(INT_EXT);  
0306:  BCF    03.5
0307:  BSF    0B.4
.................... 	disable_interrupts(GLOBAL);	 
0308:  BCF    0B.6
0309:  BCF    0B.7
030A:  BTFSC  0B.7
030B:  GOTO   309
.................... 	pos=read_eeprom(0x07); 
030C:  MOVLW  07
030D:  BSF    03.5
030E:  MOVWF  1B
030F:  BCF    1C.7
0310:  BSF    1C.0
0311:  MOVF   1A,W
0312:  BCF    03.5
0313:  MOVWF  39
.................... 	enable_interrupts(global); 
0314:  MOVLW  C0
0315:  IORWF  0B,F
.................... 	 
.................... 	frameDelay =100; 
0316:  MOVLW  64
0317:  MOVWF  59
.................... 	DatPoint=0; 
0318:  CLRF   5A
.................... 	while(1) 
.................... 	{ 
.................... 							/*		lamp_on(255); 
.................... 									delay_ms(2000); 
.................... 								    lamp_off(255);	 
.................... 									delay_ms(2000); 
.................... 					//	delay_ms(1000); 
.................... 							*/		 
.................... 											 
....................  
.................... 		if(DL_dataReady== 1) 
0319:  DECFSZ 49,W
031A:  GOTO   34A
.................... 	{ 
.................... 	 
.................... 	//	disable_interrupts(int_rtcc); 
.................... 	//	disable_interrupts(INT_RDA);	 
.................... 		if(r_a==0) 
031B:  MOVF   2F,F
031C:  BTFSS  03.2
031D:  GOTO   333
.................... 		{ 
.................... 		putc('@'); 
031E:  MOVLW  40
031F:  BSF    03.5
0320:  MOVWF  23
0321:  BCF    03.5
0322:  CALL   1AB
.................... 		putc(DL_command); 
0323:  MOVF   48,W
0324:  BSF    03.5
0325:  MOVWF  23
0326:  BCF    03.5
0327:  CALL   1AB
.................... 		putc(DL_address); 
0328:  MOVF   46,W
0329:  BSF    03.5
032A:  MOVWF  23
032B:  BCF    03.5
032C:  CALL   1AB
.................... 	    putc(DL_databyte); 
032D:  MOVF   47,W
032E:  BSF    03.5
032F:  MOVWF  23
0330:  BCF    03.5
0331:  CALL   1AB
.................... 		}		 
0332:  GOTO   349
.................... 		else if(r_a==1) 
0333:  DECFSZ 2F,W
0334:  GOTO   349
.................... 		{ 
.................... 		putc('@'); 
0335:  MOVLW  40
0336:  BSF    03.5
0337:  MOVWF  23
0338:  BCF    03.5
0339:  CALL   1AB
.................... 		putc(DL_command); 
033A:  MOVF   48,W
033B:  BSF    03.5
033C:  MOVWF  23
033D:  BCF    03.5
033E:  CALL   1AB
.................... 		putc(DL_address); 
033F:  MOVF   46,W
0340:  BSF    03.5
0341:  MOVWF  23
0342:  BCF    03.5
0343:  CALL   1AB
.................... 		putc('#'); 
0344:  MOVLW  23
0345:  BSF    03.5
0346:  MOVWF  23
0347:  BCF    03.5
0348:  CALL   1AB
.................... 		} 
.................... 		 
....................  
.................... 		DL_dataReady =0; 
0349:  CLRF   49
.................... 	//	enable_interrupts(int_rtcc); 
.................... 	//	enable_interrupts(INT_RDA); 
.................... 	} 
.................... 	if(datavalied==1) 
034A:  DECFSZ 76,W
034B:  GOTO   398
.................... 	{  		 
.................... 	//	disable_interrupts(int_rtcc); 
.................... 	//	disable_interrupts(INT_RDA); 
.................... 	//	disable_interrupts(int_ext); 
.................... 		if(	dataRxd[0]=='*') 
034C:  MOVF   60,W
034D:  SUBLW  2A
034E:  BTFSS  03.2
034F:  GOTO   397
.................... 			{			 
.................... 						 
.................... 						 
.................... 				 
.................... 						switch(dataRxd[1]) 
0350:  MOVF   61,W
0351:  XORLW  25
0352:  BTFSC  03.2
0353:  GOTO   358
0354:  XORLW  01
0355:  BTFSC  03.2
0356:  GOTO   376
0357:  GOTO   395
.................... 							{ 
.................... 								case '%' : 
.................... 									count=0; 
0358:  CLRF   7C
.................... 									DL_tx_buffer[0] =dataRxd[4]; //Data 
0359:  MOVF   64,W
035A:  MOVWF  3E
.................... 									DL_tx_buffer[1] =dataRxd[2]; //Command 
035B:  MOVF   62,W
035C:  MOVWF  3F
.................... 									DL_tx_buffer[2] =dataRxd[3] ; //Address	 
035D:  MOVF   63,W
035E:  MOVWF  40
.................... 									do 
.................... 									{ 
.................... 									tx_error_check=txmit(1,3); 
035F:  MOVLW  01
0360:  BSF    03.5
0361:  MOVWF  23
0362:  MOVLW  03
0363:  MOVWF  24
0364:  BCF    03.5
0365:  CALL   226
0366:  MOVF   78,W
0367:  BSF    03.5
0368:  MOVWF  20
.................... 									count++; 
0369:  INCF   7C,F
.................... 									}while(count<5 && tx_error_check==1); 
036A:  MOVF   7C,W
036B:  SUBLW  04
036C:  BTFSS  03.0
036D:  GOTO   373
036E:  DECFSZ 20,W
036F:  GOTO   373
0370:  BCF    03.5
0371:  GOTO   35F
0372:  BSF    03.5
.................... 									count=0; 
0373:  CLRF   7C
.................... 									datavalied=0; 
0374:  CLRF   76
.................... 									break; 
0375:  GOTO   396
.................... 							    case '$' : 
.................... 									count=0; 
0376:  CLRF   7C
.................... 									DL_tx_buffer[0] =dataRxd[3]; //Address as databyte 
0377:  MOVF   63,W
0378:  MOVWF  3E
.................... 									DL_tx_buffer[1] =dataRxd[2]; //Command 
0379:  MOVF   62,W
037A:  MOVWF  3F
.................... 									DL_tx_buffer[2] =dataRxd[3]; //Address as databyte 
037B:  MOVF   63,W
037C:  MOVWF  40
.................... 									do 
.................... 									{ 
.................... 									tx_error_check=txmit(1,3); 
037D:  MOVLW  01
037E:  BSF    03.5
037F:  MOVWF  23
0380:  MOVLW  03
0381:  MOVWF  24
0382:  BCF    03.5
0383:  CALL   226
0384:  MOVF   78,W
0385:  BSF    03.5
0386:  MOVWF  20
.................... 									count++; 
0387:  INCF   7C,F
.................... 									}while(count<5 && tx_error_check==1); 
0388:  MOVF   7C,W
0389:  SUBLW  04
038A:  BTFSS  03.0
038B:  GOTO   391
038C:  DECFSZ 20,W
038D:  GOTO   391
038E:  BCF    03.5
038F:  GOTO   37D
0390:  BSF    03.5
.................... 									count=0;	 
0391:  CLRF   7C
.................... 									//DL_dataReady=0; 
.................... 									datavalied=0; 
0392:  CLRF   76
.................... 									break; 
0393:  GOTO   396
0394:  BCF    03.5
.................... 								default : 	 
.................... 											break; 
0395:  BSF    03.5
0396:  BCF    03.5
.................... 							}	 
.................... 					 
.................... 						 
.................... 								 
.................... 				 
.................... 			 
.................... 	       }  
....................  
.................... 		 
.................... 			datavalied=0; 
0397:  CLRF   76
.................... 	//		enable_interrupts(int_rtcc); 
.................... 	//		enable_interrupts(INT_RDA); 
.................... 	//		enable_interrupts(int_ext); 
....................  
....................  
.................... 	}	 
.................... 	 
.................... 	if(error_flag==1) 
0398:  DECFSZ 2D,W
0399:  GOTO   3A0
.................... 		{ 
.................... 			putc('e'); 
039A:  MOVLW  65
039B:  BSF    03.5
039C:  MOVWF  23
039D:  BCF    03.5
039E:  CALL   1AB
.................... 			error_flag=0; 
039F:  CLRF   2D
.................... 		}	 
03A0:  GOTO   319
.................... 	} 
.................... } 
03A1:  SLEEP

Configuration Fuses:
   Word  1: 1F70   NOWDT PUT INTRC_IO MCLR BROWNOUT NOLVP NOCPD PROTECT
