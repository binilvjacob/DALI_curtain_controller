CCS PCM C Compiler, Version 5.015, 5967               10-Aug-21 23:25

               Filename:   D:\home automation codes\curtain slave\curtain slave\SLAVE 684 - modified retransmision - with timer concept\slave.lst

               ROM used:   1766 words (86%)
                           Largest free fragment is 282
               RAM used:   77 (60%) at main() level
                           94 (73%) worst case
               Stack used: 5 locations (3 in main + 2 for interrupts)
               Stack size: 8

*
0000:  MOVLW  05
0001:  MOVWF  0A
0002:  GOTO   5EF
0003:  NOP
0004:  BTFSC  03.5
0005:  GOTO   00A
0006:  MOVWF  24
0007:  SWAPF  03,W
0008:  MOVWF  25
0009:  GOTO   00F
000A:  BCF    03.5
000B:  MOVWF  24
000C:  SWAPF  03,W
000D:  MOVWF  25
000E:  BSF    25.1
000F:  MOVF   0A,W
0010:  MOVWF  2B
0011:  CLRF   0A
0012:  BCF    03.7
0013:  SWAPF  24,F
0014:  MOVF   04,W
0015:  MOVWF  26
0016:  MOVF   20,W
0017:  MOVWF  27
0018:  MOVF   21,W
0019:  MOVWF  28
001A:  MOVF   22,W
001B:  MOVWF  29
001C:  MOVF   23,W
001D:  MOVWF  2A
001E:  BCF    03.5
001F:  BTFSS  0B.5
0020:  GOTO   023
0021:  BTFSC  0B.2
0022:  GOTO   134
0023:  BTFSS  0B.4
0024:  GOTO   027
0025:  BTFSC  0B.1
0026:  GOTO   046
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.0
002A:  GOTO   02D
002B:  BTFSC  0C.0
002C:  GOTO   07F
002D:  MOVLW  8C
002E:  MOVWF  04
002F:  BTFSS  00.1
0030:  GOTO   033
0031:  BTFSC  0C.1
0032:  GOTO   140
0033:  MOVF   26,W
0034:  MOVWF  04
0035:  MOVF   27,W
0036:  MOVWF  20
0037:  MOVF   28,W
0038:  MOVWF  21
0039:  MOVF   29,W
003A:  MOVWF  22
003B:  MOVF   2A,W
003C:  MOVWF  23
003D:  MOVF   2B,W
003E:  MOVWF  0A
003F:  SWAPF  25,W
0040:  MOVWF  03
0041:  BCF    03.5
0042:  SWAPF  24,W
0043:  BTFSC  25.1
0044:  BSF    03.5
0045:  RETFIE
.................... #include <slave.h> 
.................... #include <16F684.h> 
.................... //////////// Standard Header file for the PIC16F684 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F684 
*
0242:  MOVLW  10
0243:  MOVWF  71
0244:  CLRF   20
0245:  CLRF   23
0246:  RRF    6E,F
0247:  RRF    6D,F
0248:  BTFSS  03.0
0249:  GOTO   250
024A:  MOVF   6F,W
024B:  ADDWF  20,F
024C:  BTFSC  03.0
024D:  INCF   23,F
024E:  MOVF   70,W
024F:  ADDWF  23,F
0250:  RRF    23,F
0251:  RRF    20,F
0252:  RRF    22,F
0253:  RRF    21,F
0254:  DECFSZ 71,F
0255:  GOTO   246
0256:  RETURN
0257:  CLRF   21
0258:  CLRF   22
0259:  CLRF   20
025A:  CLRF   23
025B:  MOVF   72,W
025C:  BTFSS  03.2
025D:  GOTO   261
025E:  MOVF   71,W
025F:  BTFSC  03.2
0260:  GOTO   27B
0261:  MOVLW  10
0262:  MOVWF  73
0263:  BCF    03.0
0264:  RLF    6F,F
0265:  RLF    70,F
0266:  RLF    20,F
0267:  RLF    23,F
0268:  MOVF   72,W
0269:  SUBWF  23,W
026A:  BTFSS  03.2
026B:  GOTO   26E
026C:  MOVF   71,W
026D:  SUBWF  20,W
026E:  BTFSS  03.0
026F:  GOTO   277
0270:  MOVF   71,W
0271:  SUBWF  20,F
0272:  BTFSS  03.0
0273:  DECF   23,F
0274:  MOVF   72,W
0275:  SUBWF  23,F
0276:  BSF    03.0
0277:  RLF    21,F
0278:  RLF    22,F
0279:  DECFSZ 73,F
027A:  GOTO   263
027B:  RETURN
....................  
.................... #list 
....................  
....................  
.................... #device adc=8 
....................  
.................... #FUSES WDT                 	//No Watch Dog Timer 
.................... #FUSES INTRC_IO                     	//Crystal osc <= 4mhz for PCM/PCH , 3mhz to 10 mhz for PCD 
.................... //#FUSES XT 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES BROWNOUT              	//Reset when brownout detected 
.................... #FUSES NOMCLR                  	//Master Clear pin enabled 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES PUT                 	//No Power Up Timer 
.................... #FUSES NOIESO                	//Internal External Switch Over mode disabled 
.................... #FUSES NOFCMEN               	//Fail-safe clock monitor disabled 
....................  
.................... #use delay(clock=4000000) 
....................  
.................... #include<math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  #include <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0616:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #use delay(clock=4000000) 
*
022E:  MOVLW  6D
022F:  MOVWF  04
0230:  MOVF   00,W
0231:  BTFSC  03.2
0232:  GOTO   241
0233:  MOVLW  01
0234:  MOVWF  21
0235:  CLRF   20
0236:  DECFSZ 20,F
0237:  GOTO   236
0238:  DECFSZ 21,F
0239:  GOTO   235
023A:  MOVLW  4A
023B:  MOVWF  20
023C:  DECFSZ 20,F
023D:  GOTO   23C
023E:  GOTO   23F
023F:  DECFSZ 00,F
0240:  GOTO   233
0241:  RETURN
*
037A:  MOVLW  12
037B:  SUBWF  6E,F
037C:  BTFSS  03.0
037D:  GOTO   38C
037E:  MOVLW  6E
037F:  MOVWF  04
0380:  MOVLW  FC
0381:  ANDWF  00,F
0382:  BCF    03.0
0383:  RRF    00,F
0384:  RRF    00,F
0385:  MOVF   00,W
0386:  BTFSC  03.2
0387:  GOTO   38C
0388:  GOTO   38A
0389:  NOP
038A:  DECFSZ 00,F
038B:  GOTO   389
....................  
.................... /////////// Driver details /////////////////// 
.................... /* 
.................... fan driver 
....................  
.................... */ 
.................... ///////////////////////////////////////////////// 
....................  
.................... #define device_type 3 /////////// setting device type  
....................  
.................... #define curtain_open_pin pin_c3 
.................... #define curtain_close_pin pin_c2 
....................  
.................... int16 curt_tot_time =10;			// total time in seconds 
....................  
.................... #define Fixlampid 72                  // LAMP ADDRESS // 
.................... #define zoneid_init   214 // zone address // 1-6 192//,5-8 193//,9-12 194//,13-16 195// 
.................... #define G1 0b00000001 
.................... #define G2 0b00000000 
.................... #define rx pin_a2 
.................... #define tx pin_a0 
.................... #define self 0x01 
....................  
.................... #define MaxDuty  100 //254 1 led 53,2- 58,3-95 
.................... #define MinDuty  0//10  
....................  
....................  
.................... /////////////////////////////////////////////////////////////// 
....................  
.................... #define PowerOnLevelStore    		0           //[0] 
.................... #define SystemFailureLevelStore  	    1           //[1] 
.................... #define MinimumLevelStore           	2			// [2] 
.................... #define MaximumLevelStore  			3 			// [3] 
.................... #define FadeRateStore      			4  			//[4] 
.................... #define FadeTimeStore       			5			//[5] 
.................... #define ShortAddressStore  			6  			//[6] 
.................... #define Group_07Store    			7			//[7] 
.................... #define Group_815Store  			8			///15 [8] 
.................... #define SceneStore  				9			//15 [9-24]/ 
.................... #define RandomAddressStore0  			25			//[25-27] 
.................... #define RandomAddressStore1  			26			//[25-27] 
.................... #define RandomAddressStore2  			27			//[25-27] 
.................... #define FastFadeTimeStore  			28			//[28] 
.................... #define FailureStatusStore  			29			//[29] 
.................... #define OperatingModeStore  30 //[30] 
.................... #define DimmingCurveStore  31   //[31]      
.................... #define ZoneIDStore 32 
....................  
....................  
....................  
.................... ////////////////// Device types //////////////////////// 
.................... /* 
.................... 	lamp =1 
.................... 	fan=2 
.................... 	curtain=3 
.................... 	strip=4 
.................... */ 
.................... //////////////////////////////////////////////////////// 
....................  
.................... #byte dutyreg = 0x15 
....................   
.................... #bit intf = 0x0b.1 
.................... #bit timerOnOff =0x10.0 
....................  
.................... int1 oddevenbit,a,atmp,b,error_flag,over_flowflag; 
.................... unsigned int8 dataCount; 
.................... char data[3],bitcount,tout; 
....................  
....................  
.................... unsigned char curtain_duty=0; 
.................... int16 curtain_time=0;	 
....................  
....................  
.................... char settling_time,i,dly=4,j; 
.................... int1 txmit_error; 
.................... char tx_buffer[3]; 
.................... char r_a,currentSceen; 
.................... char command_st,RetryCount; 
.................... char FadeRateCount=1; 
....................  
.................... char zoneid=zoneid_init; 
....................  
....................  
.................... char stopBitCount,address ,command,databyte; 
.................... int1 dataready,forwrdFrameFlag,backwardFrameFlag ,masterFlag ; 
.................... int16 readDly=300; 
.................... int16 GroupSelectReg; 
.................... char gindex; 
.................... /////// new  ////// 
.................... int txmit_count=0; 
.................... int error_value=0; 
.................... /////////////////// 
....................  
.................... char MinimumLevel; 
.................... char MaximumLevel; 
.................... char SystemFailureLevel; 
.................... int16 FadeRate; 
.................... char FadeTime; 
.................... char RandomAddress0; 
.................... char RandomAddress1; 
.................... char RandomAddress2; 
.................... char FastFadeTime; 
.................... char FailureStatus; 
.................... char OperatingMode; 
.................... char DimmingCurv; 
.................... char PowerOnLevel; 
.................... char DTR,DwriteLocation,DTR_Ready; 
....................  
.................... char lampid  = Fixlampid; 
....................  
.................... int16 curtain_timer=0; 
.................... int curtain_process=0; 
....................  
.................... void readData(void); 
.................... void init(void); 
.................... void handle(void ); 
.................... void copyData(void); 
.................... void commands(void); 
.................... void txmit(char priority,char length); 
.................... void txmit1(void); 
.................... void txmit0(void); 
.................... void stopbit(void); 
.................... void lamp_on(void); 
.................... void lamp_off(void); 
.................... void startBit(void); 
.................... void init_from_eeprom(void); 
.................... void goto_position(int16); 
....................  
....................  
....................  
....................  
.................... #rom  0x2100={MaxDuty,50,MinDuty,Maxduty,5,6,Fixlampid,G1,G2,6,7,8} 
....................  
.................... #rom  0x2120={zoneid_init} 
....................  
....................  
.................... #int_EXT 
.................... EXT_isr()  
.................... { 
.................... 			restart_wdt(); 	 
*
0046:  CLRWDT
.................... 			curtain_timer=0; 
0047:  CLRF   69
0048:  CLRF   68
.................... 			disable_interrupts(int_timer2);	 
0049:  BSF    03.5
004A:  BCF    0C.1
....................             disable_interrupts(int_ext); 
004B:  BCF    03.5
004C:  BCF    0B.4
....................             disable_interrupts(INT_RTCC); 
004D:  BCF    0B.5
....................             bitcount=0; 
004E:  CLRF   38
....................             setup_timer_1(T1_internal|T1_div_by_1); 
004F:  MOVLW  05
0050:  MOVWF  10
....................             set_timer1(0xffff-840); //858  880///old value 923 
0051:  CLRF   0E
0052:  MOVLW  FC
0053:  MOVWF  0F
0054:  MOVLW  B7
0055:  MOVWF  0E
....................             enable_interrupts(int_timer1); 
0056:  BSF    03.5
0057:  BSF    0C.0
....................             stopBitCount = 0; 
0058:  BCF    03.5
0059:  CLRF   4A
....................             oddevenbit=1; 
005A:  BSF    33.0
....................             data[0]=0; 
005B:  CLRF   35
....................             data[1]=0; 
005C:  CLRF   36
....................             data[2]=0; 
005D:  CLRF   37
....................             tout=0 ; 
005E:  CLRF   39
....................             datacount = 0;    
005F:  CLRF   34
.................... 			settling_time = 0;  
0060:  CLRF   3D
.................... } 
....................  
....................  
....................  
....................  
0061:  BCF    0B.1
0062:  BCF    0A.3
0063:  GOTO   033
.................... #int_TIMER1 
.................... TIMER1_isr() 
.................... { 
....................  
....................  
.................... readDly=20; 
*
007F:  CLRF   50
0080:  MOVLW  14
0081:  MOVWF  4F
.................... error_flag=0; 
0082:  BCF    33.4
.................... 	if(oddevenbit==1) 
0083:  BTFSS  33.0
0084:  GOTO   0C0
.................... 	{ 
.................... 	//	output_high( ); 
.................... 		a=input(rx);  
0085:  BSF    03.5
0086:  BSF    05.2
0087:  BCF    03.5
0088:  BCF    33.1
0089:  BTFSC  05.2
008A:  BSF    33.1
.................... 		atmp=a ;           
008B:  BCF    33.2
008C:  BTFSC  33.1
008D:  BSF    33.2
.................... 		oddevenbit=0 ; 
008E:  BCF    33.0
.................... 		 
.................... 				if(atmp) 
008F:  BTFSS  33.2
0090:  GOTO   0A7
.................... 				{ 
.................... 					while(atmp) 
0091:  BTFSS  33.2
0092:  GOTO   0A6
.................... 						{ 
.................... 							atmp=input(rx); 
0093:  BSF    03.5
0094:  BSF    05.2
0095:  BCF    03.5
0096:  BCF    33.2
0097:  BTFSC  05.2
0098:  BSF    33.2
.................... 							if(readDly>0) 
0099:  MOVF   4F,F
009A:  BTFSS  03.2
009B:  GOTO   09F
009C:  MOVF   50,F
009D:  BTFSC  03.2
009E:  GOTO   0A4
.................... 								readDly--; 
009F:  MOVF   4F,W
00A0:  BTFSC  03.2
00A1:  DECF   50,F
00A2:  DECF   4F,F
00A3:  GOTO   0A5
.................... 							else 
.................... 								atmp=0; 
00A4:  BCF    33.2
00A5:  GOTO   091
.................... 								 
.................... 						} 
.................... 				}          
00A6:  GOTO   0B8
.................... 				else 
.................... 				{ 
.................... 					while(!atmp) 
00A7:  BTFSC  33.2
00A8:  GOTO   0B8
.................... 						{ 
.................... 							atmp=input(rx); 
00A9:  BSF    03.5
00AA:  BSF    05.2
00AB:  BCF    03.5
00AC:  BCF    33.2
00AD:  BTFSC  05.2
00AE:  BSF    33.2
.................... 							readDly--; 
00AF:  MOVF   4F,W
00B0:  BTFSC  03.2
00B1:  DECF   50,F
00B2:  DECFSZ 4F,F
.................... 								if(readdly==0) 
00B3:  GOTO   0B7
00B4:  MOVF   50,F
00B5:  BTFSC  03.2
.................... 									{ 
.................... 									atmp=1; 
00B6:  BSF    33.2
.................... 									}	 
00B7:  GOTO   0A7
.................... 						} 
.................... 				} 
....................  
.................... 			setup_timer_1(T1_internal|T1_div_by_1);//settimer1with1us least count 
00B8:  MOVLW  05
00B9:  MOVWF  10
.................... 			set_timer1(0xffff-150);  //374  //  355             350////old value 150 
00BA:  CLRF   0E
00BB:  MOVLW  FF
00BC:  MOVWF  0F
00BD:  MOVLW  69
00BE:  MOVWF  0E
.................... 	} 
00BF:  GOTO   12F
.................... 	else 
.................... 	{  
.................... 	//	output_low(pin_c3); 
.................... 		b=input(rx) ; // store data line status in the second half 
00C0:  BSF    03.5
00C1:  BSF    05.2
00C2:  BCF    03.5
00C3:  BCF    33.3
00C4:  BTFSC  05.2
00C5:  BSF    33.3
.................... 		oddevenbit=1; 
00C6:  BSF    33.0
.................... 		setup_timer_1(T1_internal|T1_div_by_1); 
00C7:  MOVLW  05
00C8:  MOVWF  10
.................... 		set_timer1(0xffff-350);  // delay  till the next call st to 73 us/////old value 350 
00C9:  CLRF   0E
00CA:  MOVLW  FE
00CB:  MOVWF  0F
00CC:  MOVLW  A1
00CD:  MOVWF  0E
.................... 		readData();  // function  get the dat from the conditions of a and b 
.................... 					 
.................... 	} 
.................... return(0); 
*
012F:  MOVLW  00
0130:  MOVWF  21
....................  
....................  
....................  
....................  
....................  
.................... } 
....................  
0131:  BCF    0C.0
0132:  BCF    0A.3
0133:  GOTO   033
.................... #int_RTCC 
.................... RTCC_isr() 
.................... {	 
....................  
.................... 	restart_wdt();  
0134:  CLRWDT
.................... 	dly--; 
0135:  DECFSZ 3F,F
....................   	if (dly == 0) 
0136:  GOTO   13D
....................   	{	 
....................       dly = 4; 
0137:  MOVLW  04
0138:  MOVWF  3F
....................       if(settling_time < 25) 
0139:  MOVF   3D,W
013A:  SUBLW  18
013B:  BTFSC  03.0
....................       { 
....................           settling_time++; 
013C:  INCF   3D,F
....................       }               
....................    }    
....................  
.................... } 
....................  
....................  
013D:  BCF    0B.2
013E:  BCF    0A.3
013F:  GOTO   033
.................... #int_timer2					// 60 ms interrupt 
.................... timer2_isr() 
.................... { 
....................  
.................... curtain_timer++; 
0140:  INCF   68,F
0141:  BTFSC  03.2
0142:  INCF   69,F
.................... restart_wdt();  
0143:  CLRWDT
....................  
0144:  BCF    0C.1
0145:  BCF    0A.3
0146:  GOTO   033
.................... } 
....................  
....................  
.................... void main(void) 
*
05EF:  MOVF   03,W
05F0:  ANDLW  1F
05F1:  MOVWF  03
05F2:  MOVLW  61
05F3:  BSF    03.5
05F4:  MOVWF  0F
05F5:  MOVF   0F,W
05F6:  BCF    03.5
05F7:  CLRF   32
05F8:  MOVLW  0A
05F9:  MOVWF  31
05FA:  CLRF   3A
05FB:  CLRF   3C
05FC:  CLRF   3B
05FD:  MOVLW  04
05FE:  MOVWF  3F
05FF:  MOVLW  01
0600:  MOVWF  48
0601:  MOVLW  D6
0602:  MOVWF  49
0603:  MOVLW  01
0604:  MOVWF  50
0605:  MOVLW  2C
0606:  MOVWF  4F
0607:  CLRF   54
0608:  CLRF   55
0609:  MOVLW  48
060A:  MOVWF  67
060B:  CLRF   69
060C:  CLRF   68
060D:  CLRF   6A
060E:  BCF    1F.6
060F:  MOVLW  00
0610:  BSF    03.5
0611:  MOVWF  11
0612:  BCF    03.5
0613:  CLRF   1A
0614:  MOVLW  07
0615:  MOVWF  19
....................  
.................... { 
.................... 	setup_wdt(WDT_ON); 
*
0617:  BSF    18.0
.................... 	setup_wdt(WDT_72MS|WDT_TIMES_16);		//~1.1 s reset	 
0618:  MOVLW  11
0619:  MOVWF  18
061A:  MOVLW  0A
061B:  MOVWF  20
061C:  CLRF   01
061D:  MOVLW  81
061E:  MOVWF  04
061F:  MOVF   00,W
0620:  ANDLW  F0
0621:  IORLW  07
0622:  MOVWF  00
0623:  CLRWDT
0624:  MOVF   00,W
0625:  ANDLW  F7
0626:  BTFSC  20.3
0627:  ANDLW  F0
0628:  IORWF  20,W
0629:  MOVWF  00
....................  
.................... 	init_from_eeprom(); 
062A:  CALL   147
.................... 	init();		 
062B:  GOTO   2EA
.................... 	GroupSelectReg = MAKE16(read_EEPROM (Group_815Store ),read_EEPROM (Group_07Store));	 
062C:  MOVLW  08
062D:  BSF    03.5
062E:  MOVWF  1B
062F:  BCF    1C.7
0630:  BSF    1C.0
0631:  MOVF   1A,W
0632:  BCF    03.5
0633:  MOVWF  6B
0634:  MOVLW  07
0635:  BSF    03.5
0636:  MOVWF  1B
0637:  BCF    1C.7
0638:  BSF    1C.0
0639:  MOVF   1A,W
063A:  BCF    03.5
063B:  MOVWF  6C
063C:  MOVF   6B,W
063D:  MOVWF  52
063E:  MOVF   6C,W
063F:  MOVWF  51
....................  
.................... PowerOnLevel = read_EEPROM (PowerOnLevelStore); 
0640:  BSF    03.5
0641:  CLRF   1B
0642:  BCF    1C.7
0643:  BSF    1C.0
0644:  MOVF   1A,W
0645:  BCF    03.5
0646:  MOVWF  63
....................  
.................... /*	if(PowerOnLevel<= 2) 
.................... 	{ 
.................... 	 	curtain_duty=0;	 
.................... 	 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		curtain_duty = PowerOnLevel;		 
.................... 	} 
.................... */ 
.................... faderate=3; 
0647:  CLRF   5A
0648:  MOVLW  03
0649:  MOVWF  59
.................... start: 
.................... //output_toggle(pin_C3); 
.................... 	restart_wdt(); 	 
064A:  CLRWDT
.................... 	if (dataReady ==1) 
064B:  BTFSS  33.7
064C:  GOTO   67C
.................... 	{ 
.................... 		if(address == 0xff) 
064D:  INCFSZ 4B,W
064E:  GOTO   651
.................... 		{ 
.................... 			handle();  
064F:  CALL   3FE
.................... 		}		 
0650:  GOTO   67B
.................... 		else if(address==lampid)		{ 
0651:  MOVF   67,W
0652:  SUBWF  4B,W
0653:  BTFSS  03.2
0654:  GOTO   65A
.................... 			if(address>=64) 
0655:  MOVF   4B,W
0656:  SUBLW  3F
0657:  BTFSS  03.0
.................... 			{ 
.................... 			handle(); 
0658:  CALL   3FE
.................... 			}			  
.................... 		}		 
0659:  GOTO   67B
....................     	else if(address == zoneid) 
065A:  MOVF   49,W
065B:  SUBWF  4B,W
065C:  BTFSS  03.2
065D:  GOTO   660
.................... 		{ 
.................... 			handle();	 
065E:  CALL   3FE
.................... 		} 
065F:  GOTO   67B
.................... 		else if(address>191 && address<209) 
0660:  MOVF   4B,W
0661:  SUBLW  BF
0662:  BTFSC  03.0
0663:  GOTO   67B
0664:  MOVF   4B,W
0665:  SUBLW  D0
0666:  BTFSS  03.0
0667:  GOTO   67B
.................... 		{	 
.................... 			gindex = address &0x0F; 
0668:  MOVF   4B,W
0669:  ANDLW  0F
066A:  MOVWF  53
.................... 			if ( bit_test (GroupSelectReg, gindex)==1) 
066B:  MOVF   52,W
066C:  MOVWF  23
066D:  MOVF   51,W
066E:  MOVWF  22
066F:  MOVF   53,W
0670:  MOVWF  20
0671:  BTFSC  03.2
0672:  GOTO   678
0673:  BCF    03.0
0674:  RRF    23,F
0675:  RRF    22,F
0676:  DECFSZ 20,F
0677:  GOTO   673
0678:  MOVF   22,W
0679:  BTFSC  22.0
.................... 			{ 				 
.................... 				handle(); 
067A:  CALL   3FE
.................... 			}	 
.................... 		} 
.................... 		dataReady =0; 
067B:  BCF    33.7
.................... 	} 
....................  
....................  
.................... 	if(curtain_process==1 && curtain_timer >=(curt_tot_time*100)/6) 
067C:  DECFSZ 6A,W
067D:  GOTO   6B1
067E:  MOVF   32,W
067F:  MOVWF  6E
0680:  MOVF   31,W
0681:  MOVWF  6D
0682:  CLRF   70
0683:  MOVLW  64
0684:  MOVWF  6F
0685:  CALL   242
0686:  MOVF   22,W
0687:  MOVWF  6C
0688:  MOVF   21,W
0689:  MOVWF  6B
068A:  MOVF   6C,W
068B:  MOVWF  70
068C:  MOVF   6B,W
068D:  MOVWF  6F
068E:  CLRF   72
068F:  MOVLW  06
0690:  MOVWF  71
0691:  CALL   257
0692:  MOVF   22,W
0693:  MOVWF  23
0694:  MOVF   23,W
0695:  SUBWF  69,W
0696:  BTFSS  03.0
0697:  GOTO   6B1
0698:  BTFSS  03.2
0699:  GOTO   69E
069A:  MOVF   21,W
069B:  SUBWF  68,W
069C:  BTFSS  03.0
069D:  GOTO   6B1
.................... 	{ 
.................... 		 
.................... 		disable_interrupts(int_timer2); 
069E:  BSF    03.5
069F:  BCF    0C.1
.................... 		output_high(curtain_open_pin);			// pulse 2 
06A0:  BCF    07.3
06A1:  BCF    03.5
06A2:  BSF    07.3
.................... 		delay_ms(100); 
06A3:  MOVLW  64
06A4:  MOVWF  6D
06A5:  CALL   22E
.................... 		output_low(curtain_open_pin); 
06A6:  BSF    03.5
06A7:  BCF    07.3
06A8:  BCF    03.5
06A9:  BCF    07.3
.................... 		curtain_timer=0; 
06AA:  CLRF   69
06AB:  CLRF   68
.................... 		enable_interrupts(int_timer2); 
06AC:  BSF    03.5
06AD:  BSF    0C.1
.................... 		curtain_process=2; 
06AE:  MOVLW  02
06AF:  BCF    03.5
06B0:  MOVWF  6A
.................... 	} 
....................  
.................... 	if(curtain_process==2 && curtain_timer >=(curtain_time*100)/6) 
06B1:  MOVF   6A,W
06B2:  SUBLW  02
06B3:  BTFSS  03.2
06B4:  GOTO   6E4
06B5:  MOVF   3C,W
06B6:  MOVWF  6E
06B7:  MOVF   3B,W
06B8:  MOVWF  6D
06B9:  CLRF   70
06BA:  MOVLW  64
06BB:  MOVWF  6F
06BC:  CALL   242
06BD:  MOVF   22,W
06BE:  MOVWF  6C
06BF:  MOVF   21,W
06C0:  MOVWF  6B
06C1:  MOVF   6C,W
06C2:  MOVWF  70
06C3:  MOVF   6B,W
06C4:  MOVWF  6F
06C5:  CLRF   72
06C6:  MOVLW  06
06C7:  MOVWF  71
06C8:  CALL   257
06C9:  MOVF   22,W
06CA:  MOVWF  23
06CB:  MOVF   23,W
06CC:  SUBWF  69,W
06CD:  BTFSS  03.0
06CE:  GOTO   6E4
06CF:  BTFSS  03.2
06D0:  GOTO   6D5
06D1:  MOVF   21,W
06D2:  SUBWF  68,W
06D3:  BTFSS  03.0
06D4:  GOTO   6E4
.................... 	{ 
.................... 		 
.................... 		disable_interrupts(int_timer2); 
06D5:  BSF    03.5
06D6:  BCF    0C.1
.................... 		output_high(curtain_open_pin);			// pulse 3 
06D7:  BCF    07.3
06D8:  BCF    03.5
06D9:  BSF    07.3
.................... 		delay_ms(100); 
06DA:  MOVLW  64
06DB:  MOVWF  6D
06DC:  CALL   22E
.................... 		output_low(curtain_open_pin); 
06DD:  BSF    03.5
06DE:  BCF    07.3
06DF:  BCF    03.5
06E0:  BCF    07.3
.................... 		curtain_timer=0; 
06E1:  CLRF   69
06E2:  CLRF   68
.................... 		curtain_process=0; 
06E3:  CLRF   6A
....................  
.................... 	} 
....................  
....................  
....................  
.................... /*	if(txmit_error==1&&txmit_count<64) 
.................... 	{ 
.................... 		txmit_count++; 
.................... 		txmit(2,2); 
.................... 	}	 
.................... 	else 
.................... 	{ 
.................... 		txmit_count=0; 
.................... 	} 
.................... */ 
.................... 	goto start; 
06E4:  GOTO   64A
.................... } 
....................  
06E5:  SLEEP
.................... void init(void) 
....................  
.................... { 
.................... //	setup_timer_2(T2_OFF);		//26.0 us overflow, 26.0 us interrupt 
....................  	setup_ccp1(CCP_OFF); 
*
02EA:  MOVLW  F0
02EB:  ANDWF  15,F
.................... //	set_pwm1_duty((int16)10);	 
.................... 	setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1); 
02EC:  BSF    03.5
02ED:  MOVF   01,W
02EE:  ANDLW  C7
02EF:  IORLW  08
02F0:  MOVWF  01
.................... 	//setup_wdt(WDT_2304MS|WDT_DIV_16); 
.................... 	setup_timer_1(T1_internal|T1_div_by_1); 
02F1:  MOVLW  05
02F2:  BCF    03.5
02F3:  MOVWF  10
.................... 	setup_timer_2(T2_DIV_BY_16,249,15);		//4.0 ms overflow, 60.0 ms interrupt 
02F4:  MOVLW  70
02F5:  MOVWF  21
02F6:  IORLW  06
02F7:  MOVWF  12
02F8:  MOVLW  F9
02F9:  BSF    03.5
02FA:  MOVWF  12
.................... 	timerOnOff=0; 
02FB:  BCF    03.5
02FC:  BCF    10.0
.................... 	ext_int_edge( H_TO_L ); 
02FD:  BSF    03.5
02FE:  BCF    01.6
.................... 	enable_interrupts(INT_EXT); 
02FF:  BCF    03.5
0300:  BSF    0B.4
.................... 	enable_interrupts(INT_RTCC); 
0301:  BSF    0B.5
.................... 	disable_interrupts(INT_TIMER2); 
0302:  BSF    03.5
0303:  BCF    0C.1
.................... 	enable_interrupts(global);	 
0304:  MOVLW  C0
0305:  BCF    03.5
0306:  IORWF  0B,F
.................... 	settling_time =23; 
0307:  MOVLW  17
0308:  MOVWF  3D
.................... 	dataReady =0; 
0309:  BCF    33.7
.................... 	//set_pwm1_duty(0); 
.................... 	     
.................... 	faderate=3; 
030A:  CLRF   5A
030B:  MOVLW  03
030C:  MOVWF  59
....................  
.................... 	delay_ms(3000); 
030D:  MOVLW  0C
030E:  MOVWF  6B
030F:  MOVLW  FA
0310:  MOVWF  6D
0311:  CALL   22E
0312:  DECFSZ 6B,F
0313:  GOTO   30F
.................... /*	output_high(curtain_open_pin); 
.................... 	delay_ms(1000); 
.................... 	output_low(curtain_open_pin); 
.................... 	delay_ms(1000); 
.................... */ 
.................... /*	output_high(curtain_close_pin); 
.................... 	delay_ms(1000); 
.................... 	output_low(curtain_close_pin); 
.................... 	delay_ms(2000); 
.................... */ 
.................... 	curtain_process=0; 
0314:  CLRF   6A
.................... 	curtain_timer=0; 
0315:  CLRF   69
0316:  CLRF   68
.................... 	curtain_time=0; 
0317:  CLRF   3C
0318:  CLRF   3B
.................... 	goto_position(20); 
0319:  CLRF   6C
031A:  MOVLW  14
031B:  MOVWF  6B
031C:  CALL   27C
.................... 	 
.................... 	 
....................  
.................... 	 
.................... 	return; 
031D:  GOTO   62C (RETURN)
.................... } 
....................  
....................  
....................  
.................... void handle(void ) 
....................  
.................... { 
.................... 	commands(); 
.................... 	delay_ms(2); 
*
05EA:  MOVLW  02
05EB:  MOVWF  6D
05EC:  CALL   22E
.................... 	RetryCount =0; 
05ED:  CLRF   47
....................  
.................... return; 
05EE:  RETURN
....................  
.................... } 
....................  
....................  
.................... //				trnsmission of  bit 1			// 
.................... /********************************************************************* 
....................  * Function:       void txmit0(void); 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          transmission of  bit 1 to the bus	 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
.................... **********************************************************************/ 
....................  
.................... void txmit1(void) 
....................  
.................... {      
....................   	txmit_error = 0; 
*
031E:  BCF    33.6
.................... 	if (input(rx)==1) 
031F:  BSF    03.5
0320:  BSF    05.2
0321:  BCF    03.5
0322:  BTFSS  05.2
0323:  GOTO   328
.................... 	{   
.................... 		output_bit(tx,0); 
0324:  BCF    05.0
0325:  BSF    03.5
0326:  BCF    05.0
0327:  BCF    03.5
.................... 	} 
.................... 	delay_us(79); 
0328:  MOVLW  19
0329:  MOVWF  20
032A:  DECFSZ 20,F
032B:  GOTO   32A
032C:  GOTO   32D
032D:  NOP
.................... 	if (input(rx)==1) 
032E:  BSF    03.5
032F:  BSF    05.2
0330:  BCF    03.5
0331:  BTFSS  05.2
0332:  GOTO   339
.................... 	{ 
.................... 		output_bit(tx,1); 
0333:  BSF    05.0
0334:  BSF    03.5
0335:  BCF    05.0
.................... 		txmit_error = 1; 
0336:  BCF    03.5
0337:  BSF    33.6
.................... 		return; 
0338:  GOTO   370
.................... 	}			   
.................... 	delay_us(290);//345 
0339:  MOVLW  60
033A:  MOVWF  20
033B:  DECFSZ 20,F
033C:  GOTO   33B
033D:  NOP
.................... 	if (input(rx)==0) 
033E:  BSF    03.5
033F:  BSF    05.2
0340:  BCF    03.5
0341:  BTFSC  05.2
0342:  GOTO   348
.................... 	{ 
.................... 		output_bit(tx,1); 
0343:  BSF    05.0
0344:  BSF    03.5
0345:  BCF    05.0
.................... 	} 
0346:  GOTO   34F
0347:  BCF    03.5
.................... 	else 
.................... 	{ 
.................... 		output_bit(tx,1); 
0348:  BSF    05.0
0349:  BSF    03.5
034A:  BCF    05.0
.................... 		txmit_error = 1; 
034B:  BCF    03.5
034C:  BSF    33.6
.................... 		return; 
034D:  GOTO   370
034E:  BSF    03.5
.................... 	} 
.................... 	delay_us(79); 
034F:  MOVLW  19
0350:  BCF    03.5
0351:  MOVWF  20
0352:  DECFSZ 20,F
0353:  GOTO   352
0354:  GOTO   355
0355:  NOP
.................... 	if (input(rx)==0) 
0356:  BSF    03.5
0357:  BSF    05.2
0358:  BCF    03.5
0359:  BTFSC  05.2
035A:  GOTO   361
.................... 	{ 
.................... 		output_bit(tx,1); 
035B:  BSF    05.0
035C:  BSF    03.5
035D:  BCF    05.0
.................... 		txmit_error = 1; 
035E:  BCF    03.5
035F:  BSF    33.6
.................... 		return; 
0360:  GOTO   370
.................... 	} 
....................     delay_us(290); 
0361:  MOVLW  60
0362:  MOVWF  20
0363:  DECFSZ 20,F
0364:  GOTO   363
0365:  NOP
.................... 	if (input(rx)==0) 
0366:  BSF    03.5
0367:  BSF    05.2
0368:  BCF    03.5
0369:  BTFSC  05.2
036A:  GOTO   370
.................... 	{ 
.................... 		output_bit(tx,1); 
036B:  BSF    05.0
036C:  BSF    03.5
036D:  BCF    05.0
.................... 		txmit_error = 1; 
036E:  BCF    03.5
036F:  BSF    33.6
.................... 		return; 
.................... 	} 
....................     return; 
0370:  RETURN
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... //         transmission of 0 to the bus      // 
.................... /********************************************************************* 
....................  * Function:       void txmit0(void); 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          transmission of  0 bit to the bus	 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
.................... **********************************************************************/ 
....................  
.................... void txmit0(void) 
....................  
.................... { 
.................... 	txmit_error = 0;	 
*
03AB:  BCF    33.6
.................... 	output_bit(tx,1); 
03AC:  BSF    05.0
03AD:  BSF    03.5
03AE:  BCF    05.0
.................... 	delay_us(79); 
03AF:  MOVLW  19
03B0:  BCF    03.5
03B1:  MOVWF  20
03B2:  DECFSZ 20,F
03B3:  GOTO   3B2
03B4:  GOTO   3B5
03B5:  NOP
.................... 	if (input(rx)!=1) 
03B6:  BSF    03.5
03B7:  BSF    05.2
03B8:  BCF    03.5
03B9:  BTFSC  05.2
03BA:  GOTO   3BD
.................... 	{		 
.................... 		txmit_error = 1; 
03BB:  BSF    33.6
.................... 		return; 
03BC:  GOTO   3EC
.................... 	}    
.................... 	delay_us(290); 
03BD:  MOVLW  60
03BE:  MOVWF  20
03BF:  DECFSZ 20,F
03C0:  GOTO   3BF
03C1:  NOP
.................... 	if (input(rx)==1) 
03C2:  BSF    03.5
03C3:  BSF    05.2
03C4:  BCF    03.5
03C5:  BTFSS  05.2
03C6:  GOTO   3CC
.................... 	{ 
.................... 		output_bit(tx,0); 
03C7:  BCF    05.0
03C8:  BSF    03.5
03C9:  BCF    05.0
.................... 	} 
03CA:  GOTO   3D3
03CB:  BCF    03.5
....................     else 
.................... 	{ 
.................... 		output_bit(tx,1); 
03CC:  BSF    05.0
03CD:  BSF    03.5
03CE:  BCF    05.0
.................... 		txmit_error = 1; 
03CF:  BCF    03.5
03D0:  BSF    33.6
.................... 		return; 
03D1:  GOTO   3EC
03D2:  BSF    03.5
.................... 	} 
....................     delay_us(79); 
03D3:  MOVLW  19
03D4:  BCF    03.5
03D5:  MOVWF  20
03D6:  DECFSZ 20,F
03D7:  GOTO   3D6
03D8:  GOTO   3D9
03D9:  NOP
....................     if (input(rx)==1) 
03DA:  BSF    03.5
03DB:  BSF    05.2
03DC:  BCF    03.5
03DD:  BTFSS  05.2
03DE:  GOTO   3E1
.................... 	{		 
.................... 		txmit_error = 1; 
03DF:  BSF    33.6
.................... 		return; 
03E0:  GOTO   3EC
.................... 	} 
....................     delay_us(290); 
03E1:  MOVLW  60
03E2:  MOVWF  20
03E3:  DECFSZ 20,F
03E4:  GOTO   3E3
03E5:  NOP
.................... 	if (input(rx)==1) 
03E6:  BSF    03.5
03E7:  BSF    05.2
03E8:  BCF    03.5
03E9:  BTFSS  05.2
03EA:  GOTO   3EC
.................... 	{		 
.................... 		txmit_error = 1; 
03EB:  BSF    33.6
.................... 		return; 
.................... 	} 
....................     return; 
.................... } 
.................... //----------------------------------------------------------------------------- 
....................                    // txmit2 bit 
.................... //----------------------------------------------------------------------------- 
....................  
.................... void txmit(char priority,char length) 
.................... {  
....................      j= 8*length; 
*
038F:  RLF    6C,W
0390:  MOVWF  40
0391:  RLF    40,F
0392:  RLF    40,F
0393:  MOVLW  F8
0394:  ANDWF  40,F
.................... 	 while (settling_time < 12+Fixlampid);      // priority 
0395:  MOVF   3D,W
0396:  SUBLW  53
0397:  BTFSC  03.0
0398:  GOTO   395
....................      disable_interrupts(global); 
0399:  BCF    0B.6
039A:  BCF    0B.7
039B:  BTFSC  0B.7
039C:  GOTO   39A
....................      txmit1();        // start bit   
039D:  CALL   31E
....................      for(i=0;i<j;i++) 
039E:  CLRF   3E
039F:  MOVF   40,W
03A0:  SUBWF  3E,W
03A1:  BTFSC  03.0
03A2:  GOTO   3F0
....................          { 
....................             if (shift_left(tx_buffer,3,1)==1) 
03A3:  BSF    03.0
03A4:  RLF    41,F
03A5:  RLF    42,F
03A6:  RLF    43,F
03A7:  BTFSS  03.0
03A8:  GOTO   3AB
....................             { 
....................                  txmit1(); 
03A9:  CALL   31E
....................             } 
03AA:  GOTO   3EC
....................             else 
....................             { 
....................                   txmit0(); 
....................             } 
....................             if (txmit_error ==1) 
*
03EC:  BTFSC  33.6
....................             { 
....................                goto rr; 
03ED:  GOTO   3F4
....................             }		 
03EE:  INCF   3E,F
03EF:  GOTO   39F
....................          }         
....................      stopbit();     
03F0:  CALL   371
....................      stopbit();  
03F1:  CALL   371
.................... 	stopbit(); stopbit(); 
03F2:  CALL   371
03F3:  CALL   371
.................... rr:  output_bit(tx,1); 
03F4:  BSF    05.0
03F5:  BSF    03.5
03F6:  BCF    05.0
.................... 	 settling_time = 0; 
03F7:  BCF    03.5
03F8:  CLRF   3D
....................      intf =0; 
03F9:  BCF    0B.1
....................      enable_interrupts(global);	 
03FA:  MOVLW  C0
03FB:  IORWF  0B,F
.................... 	 enable_interrupts(INT_RTCC); 
03FC:  BSF    0B.5
....................      return; 
03FD:  RETURN
.................... } 
....................  
.................... //-------------------------------------------------------------------------- 
....................           // stop bit function // 
.................... //-------------------------------------------------------------------------- 
.................... void  stopbit(void) 
.................... { 
....................       output_bit(tx,1); 
*
0371:  BSF    05.0
0372:  BSF    03.5
0373:  BCF    05.0
.................... 	  restart_wdt();  
0374:  CLRWDT
....................       delay_us(830); 
0375:  MOVLW  05
0376:  BCF    03.5
0377:  MOVWF  6D
0378:  MOVLW  A3
0379:  MOVWF  6E
*
038C:  DECFSZ 6D,F
038D:  GOTO   378
....................       return; 
038E:  RETURN
.................... } 
....................  
.................... //-------------------------------------------------------------------------- 
....................  
....................  
.................... void readData(void) 
.................... { 
.................... 	restart_wdt();  
*
00CE:  CLRWDT
....................       error_flag=0; 
00CF:  BCF    33.4
....................       datacount++; 
00D0:  INCF   34,F
....................       forwrdFrameFlag = 0; 
00D1:  BCF    4E.0
.................... 	  backwardFrameFlag =0; 
00D2:  BCF    4E.1
....................       if(datacount< 27) 
00D3:  MOVF   34,W
00D4:  SUBLW  1A
00D5:  BTFSS  03.0
00D6:  GOTO   12A
....................       { 
....................          if((a==0 )&& (b==1)) 
00D7:  BTFSC  33.1
00D8:  GOTO   0E0
00D9:  BTFSS  33.3
00DA:  GOTO   0E0
....................          { 
....................             shift_left(data,3,1);  // a one  detewcted on bus  
00DB:  BSF    03.0
00DC:  RLF    35,F
00DD:  RLF    36,F
00DE:  RLF    37,F
....................          } 
00DF:  GOTO   129
....................          else if((a==1)&&(b==0)) 
00E0:  BTFSS  33.1
00E1:  GOTO   0E9
00E2:  BTFSC  33.3
00E3:  GOTO   0E9
....................          { 
....................             shift_left(data,3,0);  // a zero is  deted on the bus  
00E4:  BCF    03.0
00E5:  RLF    35,F
00E6:  RLF    36,F
00E7:  RLF    37,F
....................          } 
00E8:  GOTO   129
....................          else if ( a==1 && b==1) 
00E9:  BTFSS  33.1
00EA:  GOTO   124
00EB:  BTFSS  33.3
00EC:  GOTO   124
....................          { 
....................             switch (datacount) 
00ED:  MOVF   34,W
00EE:  XORLW  11
00EF:  BTFSC  03.2
00F0:  GOTO   0FB
00F1:  XORLW  03
00F2:  BTFSC  03.2
00F3:  GOTO   0FD
00F4:  XORLW  0B
00F5:  BTFSC  03.2
00F6:  GOTO   10D
00F7:  XORLW  03
00F8:  BTFSC  03.2
00F9:  GOTO   10F
00FA:  GOTO   11E
....................             { 
....................                case 17: 
....................                { 
....................                      stopBitCount ++; 
00FB:  INCF   4A,F
....................                      break; 
00FC:  GOTO   123
....................                } 
....................                case 18: 
....................                { 
....................                   stopBitCount ++; 
00FD:  INCF   4A,F
....................                   if(stopBitCount == 2) 
00FE:  MOVF   4A,W
00FF:  SUBLW  02
0100:  BTFSS  03.2
0101:  GOTO   109
....................                   { 
....................                         r_a=1;  
0102:  MOVLW  01
0103:  MOVWF  44
....................                         copyData(); 
0104:  CALL   064
....................                         forwrdFrameFlag = 1; 
0105:  BSF    4E.0
....................                         masterflag = 0; 
0106:  BCF    4E.2
....................                         backwardFrameFlag =0; 
0107:  BCF    4E.1
....................  
....................                   } 
0108:  GOTO   10C
....................                   else 
....................                   { 
.................... 						error_flag =1; 
0109:  BSF    33.4
.................... 						enable_interrupts(INT_EXT);        
010A:  BSF    0B.4
.................... 						enable_interrupts(INT_RTCC); 
010B:  BSF    0B.5
....................                   } 
....................                   break; 
010C:  GOTO   123
....................                } 
....................               	case 25: 
.................... 				{ 
.................... 					stopBitCount ++; 
010D:  INCF   4A,F
.................... 					break; 
010E:  GOTO   123
.................... 				} 
....................               	case 26:  
.................... 				{ 
.................... 					stopBitCount ++; 
010F:  INCF   4A,F
.................... 					if(stopBitCount == 2) 
0110:  MOVF   4A,W
0111:  SUBLW  02
0112:  BTFSS  03.2
0113:  GOTO   11A
.................... 					{ 
.................... 						r_a=0;  
0114:  CLRF   44
.................... 						copyData(); 
0115:  CALL   064
.................... 						forwrdFrameFlag =0; 
0116:  BCF    4E.0
.................... 						masterflag = 1; 
0117:  BSF    4E.2
.................... 						backwardFrameFlag =0; 
0118:  BCF    4E.1
.................... 					} 
0119:  GOTO   11D
.................... 					else 
.................... 					{ 
.................... 						error_flag =1; 
011A:  BSF    33.4
.................... 						enable_interrupts(INT_EXT);        
011B:  BSF    0B.4
.................... 						enable_interrupts(INT_RTCC); 
011C:  BSF    0B.5
.................... 					} 
.................... 					break; 
011D:  GOTO   123
.................... 				} 
....................                 default: 
....................                 { 
....................                       error_flag=1; 
011E:  BSF    33.4
....................                       timerOnOff=0; 
011F:  BCF    10.0
....................                       enable_interrupts(INT_EXT);   
0120:  BSF    0B.4
.................... 					  enable_interrupts(INT_RTCC); 
0121:  BSF    0B.5
....................                       settling_time = 0; 
0122:  CLRF   3D
....................                       break; 
....................                 } 
....................              }    
....................           }  
0123:  GOTO   129
.................... 		else 
.................... 		{ 
.................... 			error_flag=1;     
0124:  BSF    33.4
.................... 			settling_time = 0; 
0125:  CLRF   3D
.................... 			timerOnOff=0;        
0126:  BCF    10.0
.................... 			enable_interrupts(INT_EXT);        
0127:  BSF    0B.4
.................... 			enable_interrupts(INT_RTCC);          
0128:  BSF    0B.5
.................... 		} 
....................       } 
0129:  GOTO   12F
.................... 	else  // the  data count grater than 27  
.................... 	{ 
.................... 		over_flowflag =1 ; 
012A:  BSF    33.5
.................... 		settling_time = 0; 
012B:  CLRF   3D
.................... 		timerOnOff=0;        
012C:  BCF    10.0
.................... 		enable_interrupts(INT_EXT);        
012D:  BSF    0B.4
.................... 		enable_interrupts(INT_RTCC);          
012E:  BSF    0B.5
.................... 	} 
....................     return; 
.................... } 
....................  
....................  
....................  
....................  
.................... void copyData(void) 
.................... {  
.................... 	restart_wdt();  
*
0064:  CLRWDT
.................... 	dataReady =1;     
0065:  BSF    33.7
.................... 	if( r_a==1) 
0066:  DECFSZ 44,W
0067:  GOTO   06D
.................... 	{ 
.................... 		address = data[1]; 
0068:  MOVF   36,W
0069:  MOVWF  4B
.................... 		command =data[0];						 
006A:  MOVF   35,W
006B:  MOVWF  4C
.................... 	} 
006C:  GOTO   076
.................... 	else if( r_a==0) 
006D:  MOVF   44,F
006E:  BTFSS  03.2
006F:  GOTO   076
.................... 	{	 
.................... 		address = data[2]; 
0070:  MOVF   37,W
0071:  MOVWF  4B
.................... 		command =data[1]; 
0072:  MOVF   36,W
0073:  MOVWF  4C
.................... 		databyte=data[0];  
0074:  MOVF   35,W
0075:  MOVWF  4D
.................... 	}        
....................     timerOnOff=0; 
0076:  BCF    10.0
....................     intf =0; 
0077:  BCF    0B.1
....................     enable_interrupts(INT_EXT); 
0078:  BSF    0B.4
....................     disable_interrupts(int_timer1); 
0079:  BSF    03.5
007A:  BCF    0C.0
....................     enable_interrupts(INT_RTCC); 
007B:  BCF    03.5
007C:  BSF    0B.5
....................     settling_time = 0; 
007D:  CLRF   3D
....................     return; 
007E:  RETURN
.................... } 
....................  
....................  
.................... void commands(void) 
.................... {  
.................... 	command_st =0;	 
*
03FE:  CLRF   46
.................... 	switch(command) 
03FF:  MOVF   4C,W
0400:  XORLW  CA
0401:  BTFSC  03.2
0402:  GOTO   428
0403:  XORLW  01
0404:  BTFSC  03.2
0405:  GOTO   43D
0406:  XORLW  07
0407:  BTFSC  03.2
0408:  GOTO   444
0409:  XORLW  26
040A:  BTFSC  03.2
040B:  GOTO   44A
040C:  XORLW  0D
040D:  BTFSC  03.2
040E:  GOTO   465
040F:  XORLW  EE
0410:  BTFSC  03.2
0411:  GOTO   48D
0412:  XORLW  2B
0413:  BTFSC  03.2
0414:  GOTO   550
0415:  XORLW  01
0416:  BTFSC  03.2
0417:  GOTO   574
0418:  XORLW  07
0419:  BTFSC  03.2
041A:  GOTO   579
041B:  XORLW  01
041C:  BTFSC  03.2
041D:  GOTO   5A0
041E:  XORLW  03
041F:  BTFSC  03.2
0420:  GOTO   5A9
0421:  XORLW  01
0422:  BTFSC  03.2
0423:  GOTO   5B8
0424:  XORLW  16
0425:  BTFSC  03.2
0426:  GOTO   5C6
0427:  GOTO   5CF
.................... 	{ 
.................... 		 
.................... 	   	case 202:	// goto  level  
.................... 		{   
.................... 			 
.................... 			if(databyte > MaximumLevel ) 
0428:  MOVF   4D,W
0429:  SUBWF  57,W
042A:  BTFSC  03.0
042B:  GOTO   42F
.................... 			{ 
....................  
....................                 curtain_duty=MaximumLevel; 
042C:  MOVF   57,W
042D:  MOVWF  3A
.................... 			} 
042E:  GOTO   438
.................... 			else if(databyte< MinimumLevel ) 
042F:  MOVF   56,W
0430:  SUBWF  4D,W
0431:  BTFSC  03.0
0432:  GOTO   436
.................... 		    { 
.................... 			 
....................                 curtain_duty=MinimumLevel; 
0433:  MOVF   56,W
0434:  MOVWF  3A
.................... 			} 
0435:  GOTO   438
.................... 			else 
.................... 			{ 
.................... 		 
....................                 curtain_duty=databyte; 
0436:  MOVF   4D,W
0437:  MOVWF  3A
.................... 			} 		 
.................... 			goto_position(curtain_duty);	 
0438:  CLRF   6C
0439:  MOVF   3A,W
043A:  MOVWF  6B
043B:  CALL   27C
.................... 										 
.................... 			break; 
043C:  GOTO   5D1
.................... 		} 
.................... 		case 203:	// on 
.................... 		{  		 
.................... 		 
....................             curtain_duty=100;			 
043D:  MOVLW  64
043E:  MOVWF  3A
.................... 			goto_position(curtain_duty);						 
043F:  CLRF   6C
0440:  MOVF   3A,W
0441:  MOVWF  6B
0442:  CALL   27C
.................... 			break; 
0443:  GOTO   5D1
.................... 		} 
.................... 		case 204:	//off 
.................... 		{  	 
.................... 		 
....................          curtain_duty=0; 
0444:  CLRF   3A
.................... 		goto_position(curtain_duty); 
0445:  CLRF   6C
0446:  MOVF   3A,W
0447:  MOVWF  6B
0448:  CALL   27C
.................... 			break; 
0449:  GOTO   5D1
.................... 		} 
.................... 	/*	case 216:	//dim 
.................... 		case 241:		//ZONE DIM 
.................... 		{ 
.................... 			if(l_st==1) 
.................... 			{				 
.................... 				if(duty>MinimumLevel) 
.................... 				{							 
.................... 					duty--; 
.................... 					SetDimmLevel(duty);					 
.................... 				} 
.................... 			} 
.................... 			break; 
.................... 		} 
.................... 		case 220:	//bright 
.................... 		case 240:  //zone  bright 
.................... 		{ 
.................... 			if(l_st==1) 
.................... 			{			 
.................... 				if(duty < MaximumLevel) 
.................... 				{									 
.................... 					duty++; 
.................... 					SetDimmLevel(duty);			 
.................... 				} 
.................... 			} 
.................... 			break; 
.................... 		}*/	 
.................... 	 
.................... 		case 234: // scene select  
.................... 		{ 
.................... 			 
.................... 			if(databyte < 17) 
044A:  MOVF   4D,W
044B:  SUBLW  10
044C:  BTFSS  03.0
044D:  GOTO   460
.................... 			{				 
.................... 				currentSceen = databyte;			 
044E:  MOVF   4D,W
044F:  MOVWF  45
.................... 		        curtain_duty = read_EEPROM (currentSceen+SceneStore);	 
0450:  MOVLW  09
0451:  ADDWF  45,W
0452:  MOVWF  6B
0453:  MOVF   6B,W
0454:  BSF    03.5
0455:  MOVWF  1B
0456:  BCF    1C.7
0457:  BSF    1C.0
0458:  MOVF   1A,W
0459:  BCF    03.5
045A:  MOVWF  3A
.................... 			     	if(curtain_duty<=MinimumLevel) 
045B:  MOVF   3A,W
045C:  SUBWF  56,W
045D:  BTFSS  03.0
045E:  GOTO   460
.................... 					{ 
.................... 					   	curtain_duty=0;					 
045F:  CLRF   3A
.................... 					 
.................... 					} 
.................... 					else 
.................... 					{								 
.................... 							 
.................... 					}			 
.................... 			} 
.................... 			goto_position(curtain_duty); 
0460:  CLRF   6C
0461:  MOVF   3A,W
0462:  MOVWF  6B
0463:  CALL   27C
.................... 			break; 
0464:  GOTO   5D1
.................... 		 } 
.................... 		case 231:  // store sceen  
.................... 		{ 
....................  
.................... 			if(databyte < 17) 
0465:  MOVF   4D,W
0466:  SUBLW  10
0467:  BTFSS  03.0
0468:  GOTO   48C
.................... 			{				 
.................... 				disable_interrupts (global); 
0469:  BCF    0B.6
046A:  BCF    0B.7
046B:  BTFSC  0B.7
046C:  GOTO   46A
.................... 				write_eeprom(databyte+SceneStore,curtain_duty); 
046D:  MOVLW  09
046E:  ADDWF  4D,W
046F:  MOVWF  6B
0470:  MOVF   0B,W
0471:  MOVWF  20
0472:  BCF    0B.7
0473:  MOVF   6B,W
0474:  BSF    03.5
0475:  MOVWF  1B
0476:  BCF    03.5
0477:  MOVF   3A,W
0478:  BSF    03.5
0479:  MOVWF  1A
047A:  BCF    1C.7
047B:  BSF    1C.2
047C:  MOVLW  55
047D:  MOVWF  1D
047E:  MOVLW  AA
047F:  MOVWF  1D
0480:  BSF    1C.1
0481:  BTFSC  1C.1
0482:  GOTO   481
0483:  BCF    1C.2
0484:  BCF    03.5
0485:  MOVF   20,W
0486:  IORWF  0B,F
.................... 				delay_us(5);			 
0487:  GOTO   488
0488:  GOTO   489
0489:  NOP
.................... 				enable_interrupts(global);	 
048A:  MOVLW  C0
048B:  IORWF  0B,F
.................... 			} 
.................... 			 
.................... 			break; 
048C:  GOTO   5D1
.................... 		} 
.................... 		case 0x09: 
.................... 		{		 
.................... 				GroupSelectReg = MAKE16(read_EEPROM (Group_815Store ),read_EEPROM (Group_07Store));	 
048D:  MOVLW  08
048E:  BSF    03.5
048F:  MOVWF  1B
0490:  BCF    1C.7
0491:  BSF    1C.0
0492:  MOVF   1A,W
0493:  BCF    03.5
0494:  MOVWF  6B
0495:  MOVLW  07
0496:  BSF    03.5
0497:  MOVWF  1B
0498:  BCF    1C.7
0499:  BSF    1C.0
049A:  MOVF   1A,W
049B:  BCF    03.5
049C:  MOVWF  6C
049D:  MOVF   6B,W
049E:  MOVWF  52
049F:  MOVF   6C,W
04A0:  MOVWF  51
.................... 				gindex = databyte &0x0f;				 
04A1:  MOVF   4D,W
04A2:  ANDLW  0F
04A3:  MOVWF  53
.................... 				switch (databyte & 0x10) 
04A4:  MOVF   4D,W
04A5:  ANDLW  10
04A6:  BTFSC  03.2
04A7:  GOTO   4AC
04A8:  XORLW  10
04A9:  BTFSC  03.2
04AA:  GOTO   500
04AB:  GOTO   54F
.................... 				{ 
.................... 					case 0: 
.................... 						{ 
.................... 							bit_clear(GroupSelectReg,gindex); 
04AC:  CLRF   23
04AD:  MOVLW  01
04AE:  MOVWF  22
04AF:  MOVF   53,W
04B0:  MOVWF  20
04B1:  BTFSC  03.2
04B2:  GOTO   4B8
04B3:  BCF    03.0
04B4:  RLF    22,F
04B5:  RLF    23,F
04B6:  DECFSZ 20,F
04B7:  GOTO   4B3
04B8:  MOVF   22,W
04B9:  XORLW  FF
04BA:  MOVWF  20
04BB:  MOVLW  FF
04BC:  XORWF  23,F
04BD:  MOVF   20,W
04BE:  ANDWF  51,F
04BF:  MOVF   23,W
04C0:  ANDWF  52,F
.................... 							write_eeprom(Group_07Store  ,make8(GroupSelectReg,0)); 
04C1:  MOVF   51,W
04C2:  MOVWF  6B
04C3:  MOVF   0B,W
04C4:  MOVWF  20
04C5:  BCF    0B.7
04C6:  MOVLW  07
04C7:  BSF    03.5
04C8:  MOVWF  1B
04C9:  BCF    03.5
04CA:  MOVF   51,W
04CB:  BSF    03.5
04CC:  MOVWF  1A
04CD:  BCF    1C.7
04CE:  BSF    1C.2
04CF:  MOVLW  55
04D0:  MOVWF  1D
04D1:  MOVLW  AA
04D2:  MOVWF  1D
04D3:  BSF    1C.1
04D4:  BTFSC  1C.1
04D5:  GOTO   4D4
04D6:  BCF    1C.2
04D7:  BCF    03.5
04D8:  MOVF   20,W
04D9:  IORWF  0B,F
.................... 							delay_us(10); 
04DA:  MOVLW  02
04DB:  MOVWF  20
04DC:  DECFSZ 20,F
04DD:  GOTO   4DC
04DE:  GOTO   4DF
04DF:  NOP
.................... 							write_eeprom(Group_815Store,make8(GroupSelectReg,1)); 
04E0:  MOVF   52,W
04E1:  MOVWF  6B
04E2:  MOVF   0B,W
04E3:  MOVWF  20
04E4:  BCF    0B.7
04E5:  MOVLW  08
04E6:  BSF    03.5
04E7:  MOVWF  1B
04E8:  BCF    03.5
04E9:  MOVF   52,W
04EA:  BSF    03.5
04EB:  MOVWF  1A
04EC:  BCF    1C.7
04ED:  BSF    1C.2
04EE:  MOVLW  55
04EF:  MOVWF  1D
04F0:  MOVLW  AA
04F1:  MOVWF  1D
04F2:  BSF    1C.1
04F3:  BTFSC  1C.1
04F4:  GOTO   4F3
04F5:  BCF    1C.2
04F6:  BCF    03.5
04F7:  MOVF   20,W
04F8:  IORWF  0B,F
....................  							delay_us(10); 
04F9:  MOVLW  02
04FA:  MOVWF  20
04FB:  DECFSZ 20,F
04FC:  GOTO   4FB
04FD:  GOTO   4FE
04FE:  NOP
.................... 							break; 
04FF:  GOTO   54F
.................... 						} 
.................... 					case 16: 
.................... 						{ 
.................... 							bit_set(GroupSelectReg,gindex); 
0500:  CLRF   23
0501:  MOVLW  01
0502:  MOVWF  22
0503:  MOVF   53,W
0504:  MOVWF  20
0505:  BTFSC  03.2
0506:  GOTO   50C
0507:  BCF    03.0
0508:  RLF    22,F
0509:  RLF    23,F
050A:  DECFSZ 20,F
050B:  GOTO   507
050C:  MOVF   22,W
050D:  IORWF  51,F
050E:  MOVF   23,W
050F:  IORWF  52,F
.................... 							write_eeprom(Group_07Store  ,make8(GroupSelectReg,0)); 
0510:  MOVF   51,W
0511:  MOVWF  6B
0512:  MOVF   0B,W
0513:  MOVWF  20
0514:  BCF    0B.7
0515:  MOVLW  07
0516:  BSF    03.5
0517:  MOVWF  1B
0518:  BCF    03.5
0519:  MOVF   51,W
051A:  BSF    03.5
051B:  MOVWF  1A
051C:  BCF    1C.7
051D:  BSF    1C.2
051E:  MOVLW  55
051F:  MOVWF  1D
0520:  MOVLW  AA
0521:  MOVWF  1D
0522:  BSF    1C.1
0523:  BTFSC  1C.1
0524:  GOTO   523
0525:  BCF    1C.2
0526:  BCF    03.5
0527:  MOVF   20,W
0528:  IORWF  0B,F
.................... 							delay_us(10); 
0529:  MOVLW  02
052A:  MOVWF  20
052B:  DECFSZ 20,F
052C:  GOTO   52B
052D:  GOTO   52E
052E:  NOP
.................... 							write_eeprom(Group_815Store,make8(GroupSelectReg,1)); 
052F:  MOVF   52,W
0530:  MOVWF  6B
0531:  MOVF   0B,W
0532:  MOVWF  20
0533:  BCF    0B.7
0534:  MOVLW  08
0535:  BSF    03.5
0536:  MOVWF  1B
0537:  BCF    03.5
0538:  MOVF   52,W
0539:  BSF    03.5
053A:  MOVWF  1A
053B:  BCF    1C.7
053C:  BSF    1C.2
053D:  MOVLW  55
053E:  MOVWF  1D
053F:  MOVLW  AA
0540:  MOVWF  1D
0541:  BSF    1C.1
0542:  BTFSC  1C.1
0543:  GOTO   542
0544:  BCF    1C.2
0545:  BCF    03.5
0546:  MOVF   20,W
0547:  IORWF  0B,F
....................  							delay_us(10); 
0548:  MOVLW  02
0549:  MOVWF  20
054A:  DECFSZ 20,F
054B:  GOTO   54A
054C:  GOTO   54D
054D:  NOP
.................... 							break; 
054E:  GOTO   54F
.................... 						} 
.................... 					 
.................... 					default: break; 
....................  
.................... 				} 
.................... 				 
.................... 				break ; 
054F:  GOTO   5D1
.................... 		} 
.................... 		case 0x22:    // store  short  aress  
.................... 		{ 
.................... 			if(databyte >=64 && databyte <=255) 
0550:  MOVF   4D,W
0551:  SUBLW  3F
0552:  BTFSC  03.0
0553:  GOTO   573
.................... 			{ 
.................... 					lampid = databyte; 
0554:  MOVF   4D,W
0555:  MOVWF  67
.................... 					write_eeprom(ShortAddressStore ,lampid); 
0556:  MOVF   0B,W
0557:  MOVWF  20
0558:  BCF    0B.7
0559:  MOVLW  06
055A:  BSF    03.5
055B:  MOVWF  1B
055C:  BCF    03.5
055D:  MOVF   67,W
055E:  BSF    03.5
055F:  MOVWF  1A
0560:  BCF    1C.7
0561:  BSF    1C.2
0562:  MOVLW  55
0563:  MOVWF  1D
0564:  MOVLW  AA
0565:  MOVWF  1D
0566:  BSF    1C.1
0567:  BTFSC  1C.1
0568:  GOTO   567
0569:  BCF    1C.2
056A:  BCF    03.5
056B:  MOVF   20,W
056C:  IORWF  0B,F
.................... 					delay_us(10); 
056D:  MOVLW  02
056E:  MOVWF  20
056F:  DECFSZ 20,F
0570:  GOTO   56F
0571:  GOTO   572
0572:  NOP
.................... 			} 
.................... 		 
.................... 			break;		 
0573:  GOTO   5D1
.................... 		} 
.................... 		case 0x23:    // write  DTR  
.................... 		{ 
.................... 					DTR = databyte;	 
0574:  MOVF   4D,W
0575:  MOVWF  64
.................... 					DTR_Ready =1; 
0576:  MOVLW  01
0577:  MOVWF  66
.................... 					break; 
0578:  GOTO   5D1
.................... 		} 
.................... 		case 0x24:    // write  DTR  to  adress  location  in data  byte  
.................... 		{ 
.................... 					 
.................... 				DwriteLocation = databyte;	 
0579:  MOVF   4D,W
057A:  MOVWF  65
.................... 				if(DTR_Ready ==1 && DwriteLocation<33 ) 
057B:  DECFSZ 66,W
057C:  GOTO   59E
057D:  MOVF   65,W
057E:  SUBLW  20
057F:  BTFSS  03.0
0580:  GOTO   59E
.................... 				{ 
.................... 					DTR_Ready =0; 
0581:  CLRF   66
.................... 					write_eeprom(DwriteLocation,DTR); 
0582:  MOVF   0B,W
0583:  MOVWF  20
0584:  BCF    0B.7
0585:  MOVF   65,W
0586:  BSF    03.5
0587:  MOVWF  1B
0588:  BCF    03.5
0589:  MOVF   64,W
058A:  BSF    03.5
058B:  MOVWF  1A
058C:  BCF    1C.7
058D:  BSF    1C.2
058E:  MOVLW  55
058F:  MOVWF  1D
0590:  MOVLW  AA
0591:  MOVWF  1D
0592:  BSF    1C.1
0593:  BTFSC  1C.1
0594:  GOTO   593
0595:  BCF    1C.2
0596:  BCF    03.5
0597:  MOVF   20,W
0598:  IORWF  0B,F
.................... 					DELAY_US(20); 
0599:  MOVLW  06
059A:  MOVWF  20
059B:  DECFSZ 20,F
059C:  GOTO   59B
059D:  NOP
.................... 				} 
.................... 			init_from_eeprom(); 
059E:  CALL   147
.................... 			break; 
059F:  GOTO   5D1
.................... 		} 
.................... 		case 0x25:    // Read  DTR  to  adress  location  in data  byte  
.................... 		{ 
.................... 				tx_buffer[2]=lampid;tx_buffer[1]=DTR; txmit(2,2);  /////////priority changed 
05A0:  MOVF   67,W
05A1:  MOVWF  43
05A2:  MOVF   64,W
05A3:  MOVWF  42
05A4:  MOVLW  02
05A5:  MOVWF  6B
05A6:  MOVWF  6C
05A7:  CALL   38F
.................... 				break;			 
05A8:  GOTO   5D1
.................... 		} 
.................... 		case 0x26:    // Read  eeprom  and  store  in dtr   to  adress  location  in data  byte  
.................... 		{ 
.................... 				DwriteLocation = databyte;	 
05A9:  MOVF   4D,W
05AA:  MOVWF  65
.................... 				if( DwriteLocation<33 ) 
05AB:  MOVF   65,W
05AC:  SUBLW  20
05AD:  BTFSS  03.0
05AE:  GOTO   5B7
.................... 				{ 
.................... 					DTR=Read_eeprom(DwriteLocation); 
05AF:  MOVF   65,W
05B0:  BSF    03.5
05B1:  MOVWF  1B
05B2:  BCF    1C.7
05B3:  BSF    1C.0
05B4:  MOVF   1A,W
05B5:  BCF    03.5
05B6:  MOVWF  64
.................... 				}	 
.................... 				break;				 
05B7:  GOTO   5D1
.................... 		} 
.................... 		case 0x27: 
.................... 		{ 
.................... 			tx_buffer[2]=lampid;tx_buffer[1]=Read_eeprom(0);  
05B8:  MOVF   67,W
05B9:  MOVWF  43
05BA:  BSF    03.5
05BB:  CLRF   1B
05BC:  BCF    1C.7
05BD:  BSF    1C.0
05BE:  MOVF   1A,W
05BF:  BCF    03.5
05C0:  MOVWF  42
.................... 	    	txmit(2,2); 
05C1:  MOVLW  02
05C2:  MOVWF  6B
05C3:  MOVWF  6C
05C4:  CALL   38F
.................... 		 
.................... 			break; 
05C5:  GOTO   5D1
....................  
.................... 		} 
.................... 		case 0x31: //////////////// case for device type query ///////////////// 
.................... 		{ 
.................... 			tx_buffer[2]=lampid;tx_buffer[1]=device_type;  
05C6:  MOVF   67,W
05C7:  MOVWF  43
05C8:  MOVLW  03
05C9:  MOVWF  42
.................... 			txmit(2,2); 
05CA:  MOVLW  02
05CB:  MOVWF  6B
05CC:  MOVWF  6C
05CD:  CALL   38F
.................... 					 
.................... 			 
.................... 			break; 
05CE:  GOTO   5D1
....................  
.................... 		} 
.................... 		default: 
.................... 		{ 
.................... 			command_st=1; 
05CF:  MOVLW  01
05D0:  MOVWF  46
.................... 			break; 
.................... 		} 
.................... 	} 
.................... 	if(command_st==0) 
05D1:  MOVF   46,F
05D2:  BTFSS  03.2
05D3:  GOTO   5EA
.................... 	{ 		 
.................... 		  write_eeprom(PowerOnLevelStore,curtain_duty);		 
05D4:  MOVF   0B,W
05D5:  MOVWF  20
05D6:  BCF    0B.7
05D7:  BSF    03.5
05D8:  CLRF   1B
05D9:  BCF    03.5
05DA:  MOVF   3A,W
05DB:  BSF    03.5
05DC:  MOVWF  1A
05DD:  BCF    1C.7
05DE:  BSF    1C.2
05DF:  MOVLW  55
05E0:  MOVWF  1D
05E1:  MOVLW  AA
05E2:  MOVWF  1D
05E3:  BSF    1C.1
05E4:  BTFSC  1C.1
05E5:  GOTO   5E4
05E6:  BCF    1C.2
05E7:  BCF    03.5
05E8:  MOVF   20,W
05E9:  IORWF  0B,F
.................... 	} 
....................  
....................  
.................... return; 
.................... } 
....................  
....................  
....................  
.................... void goto_position(int16 position) 
.................... { 
....................  
.................... //	faderate=2; 
.................... 	curtain_time=(curt_tot_time*position)/100; 
*
027C:  MOVF   32,W
027D:  MOVWF  6E
027E:  MOVF   31,W
027F:  MOVWF  6D
0280:  MOVF   6C,W
0281:  MOVWF  70
0282:  MOVF   6B,W
0283:  MOVWF  6F
0284:  CALL   242
0285:  MOVF   22,W
0286:  MOVWF  6E
0287:  MOVF   21,W
0288:  MOVWF  6D
0289:  MOVF   22,W
028A:  MOVWF  70
028B:  MOVF   21,W
028C:  MOVWF  6F
028D:  CLRF   72
028E:  MOVLW  64
028F:  MOVWF  71
0290:  CALL   257
0291:  MOVF   22,W
0292:  MOVWF  3C
0293:  MOVF   21,W
0294:  MOVWF  3B
.................... 	curtain_process=0; 
0295:  CLRF   6A
.................... //	curtain_time=position * faderate * 10; 
.................... 	 
.................... 	if(position == 0) 
0296:  MOVF   6B,F
0297:  BTFSS  03.2
0298:  GOTO   2A8
0299:  MOVF   6C,F
029A:  BTFSS  03.2
029B:  GOTO   2A8
.................... 	{ 
.................... 	output_high(curtain_close_pin); 
029C:  BSF    03.5
029D:  BCF    07.2
029E:  BCF    03.5
029F:  BSF    07.2
.................... 	delay_ms(100); 
02A0:  MOVLW  64
02A1:  MOVWF  6D
02A2:  CALL   22E
.................... 	output_low(curtain_close_pin); 
02A3:  BSF    03.5
02A4:  BCF    07.2
02A5:  BCF    03.5
02A6:  BCF    07.2
.................... 	} 
02A7:  GOTO   2E7
.................... 	else if(position==100) 
02A8:  MOVF   6B,W
02A9:  SUBLW  64
02AA:  BTFSS  03.2
02AB:  GOTO   2BB
02AC:  MOVF   6C,F
02AD:  BTFSS  03.2
02AE:  GOTO   2BB
.................... 	{ 
.................... 	output_high(curtain_open_pin); 
02AF:  BSF    03.5
02B0:  BCF    07.3
02B1:  BCF    03.5
02B2:  BSF    07.3
.................... 	delay_ms(100); 
02B3:  MOVLW  64
02B4:  MOVWF  6D
02B5:  CALL   22E
.................... 	output_low(curtain_open_pin); 
02B6:  BSF    03.5
02B7:  BCF    07.3
02B8:  BCF    03.5
02B9:  BCF    07.3
.................... 	} 
02BA:  GOTO   2E7
.................... 	else if(position>0 && position <100) 
02BB:  MOVF   6B,F
02BC:  BTFSS  03.2
02BD:  GOTO   2C1
02BE:  MOVF   6C,F
02BF:  BTFSC  03.2
02C0:  GOTO   2DC
02C1:  MOVF   6C,F
02C2:  BTFSS  03.2
02C3:  GOTO   2DC
02C4:  MOVF   6B,W
02C5:  SUBLW  63
02C6:  BTFSS  03.0
02C7:  GOTO   2DC
.................... 	{ 
.................... 	// code to go to position 0 
.................... /* 
.................... 	disable_interrupts(int_timer2); 
.................... 	output_high(curtain_close_pin);			// pulse 1 
.................... 	delay_ms(100); 
.................... 	output_low(curtain_close_pin); 
....................  
....................  
.................... 	enable_interrupts(int_timer2); 
.................... 	while(curtain_timer<=(curt_tot_time*100)/6);	 
.................... 	disable_interrupts(int_timer2); 
.................... 	curtain_timer=0; 
.................... 	// code to go to desired position 
.................... 	output_high(curtain_open_pin);			// pulse 2 
.................... 	delay_ms(100); 
.................... 	output_low(curtain_open_pin); 
.................... 	enable_interrupts(int_timer2); 
.................... 	while(curtain_timer<=(curtain_time*100)/6); 
.................... 	disable_interrupts(int_timer2); 
.................... 	curtain_timer=0; 
.................... 	output_high(curtain_open_pin);			// pulse 3 
.................... 	delay_ms(100); 
.................... 	output_low(curtain_open_pin); 
.................... */ 
.................... 	 
.................... 	disable_interrupts(int_timer2); 
02C8:  BSF    03.5
02C9:  BCF    0C.1
.................... 	output_high(curtain_close_pin);			// pulse 1 
02CA:  BCF    07.2
02CB:  BCF    03.5
02CC:  BSF    07.2
.................... 	delay_ms(100); 
02CD:  MOVLW  64
02CE:  MOVWF  6D
02CF:  CALL   22E
.................... 	output_low(curtain_close_pin); 
02D0:  BSF    03.5
02D1:  BCF    07.2
02D2:  BCF    03.5
02D3:  BCF    07.2
.................... 	curtain_process=1; 
02D4:  MOVLW  01
02D5:  MOVWF  6A
.................... 	curtain_timer=0; 
02D6:  CLRF   69
02D7:  CLRF   68
.................... 	enable_interrupts(int_timer2); 
02D8:  BSF    03.5
02D9:  BSF    0C.1
.................... 	} 
02DA:  GOTO   2E8
02DB:  BCF    03.5
.................... 	else 
.................... 	{ 
.................... 	output_high(curtain_close_pin); 
02DC:  BSF    03.5
02DD:  BCF    07.2
02DE:  BCF    03.5
02DF:  BSF    07.2
.................... 	delay_ms(100); 
02E0:  MOVLW  64
02E1:  MOVWF  6D
02E2:  CALL   22E
.................... 	output_low(curtain_close_pin); 
02E3:  BSF    03.5
02E4:  BCF    07.2
02E5:  BCF    03.5
02E6:  BCF    07.2
02E7:  BSF    03.5
.................... 	} 
.................... 	 
.................... 	return; 
02E8:  BCF    03.5
02E9:  RETURN
....................  
....................  
.................... } 
....................  
.................... void init_from_eeprom(void) 
.................... { 
.................... GroupSelectReg = MAKE16(read_EEPROM (Group_815Store ),read_EEPROM (Group_07Store));	 
*
0147:  MOVLW  08
0148:  BSF    03.5
0149:  MOVWF  1B
014A:  BCF    1C.7
014B:  BSF    1C.0
014C:  MOVF   1A,W
014D:  BCF    03.5
014E:  MOVWF  6B
014F:  MOVLW  07
0150:  BSF    03.5
0151:  MOVWF  1B
0152:  BCF    1C.7
0153:  BSF    1C.0
0154:  MOVF   1A,W
0155:  BCF    03.5
0156:  MOVWF  6C
0157:  MOVF   6B,W
0158:  MOVWF  52
0159:  MOVF   6C,W
015A:  MOVWF  51
.................... delay_us(10); 
015B:  MOVLW  02
015C:  MOVWF  20
015D:  DECFSZ 20,F
015E:  GOTO   15D
015F:  GOTO   160
0160:  NOP
.................... PowerOnLevel 		= read_EEPROM (PowerOnLevelStore); 
0161:  BSF    03.5
0162:  CLRF   1B
0163:  BCF    1C.7
0164:  BSF    1C.0
0165:  MOVF   1A,W
0166:  BCF    03.5
0167:  MOVWF  63
.................... delay_us(10);  
0168:  MOVLW  02
0169:  MOVWF  20
016A:  DECFSZ 20,F
016B:  GOTO   16A
016C:  GOTO   16D
016D:  NOP
.................... SystemFailureLevel	= read_EEPROM ( SystemFailureLevelStore );  
016E:  MOVLW  01
016F:  BSF    03.5
0170:  MOVWF  1B
0171:  BCF    1C.7
0172:  BSF    1C.0
0173:  MOVF   1A,W
0174:  BCF    03.5
0175:  MOVWF  58
.................... delay_us(10);	     
0176:  MOVLW  02
0177:  MOVWF  20
0178:  DECFSZ 20,F
0179:  GOTO   178
017A:  GOTO   17B
017B:  NOP
.................... MinimumLevel		= read_EEPROM ( MinimumLevelStore );    
017C:  MOVLW  02
017D:  BSF    03.5
017E:  MOVWF  1B
017F:  BCF    1C.7
0180:  BSF    1C.0
0181:  MOVF   1A,W
0182:  BCF    03.5
0183:  MOVWF  56
.................... delay_us(10);       	 
0184:  MOVLW  02
0185:  MOVWF  20
0186:  DECFSZ 20,F
0187:  GOTO   186
0188:  GOTO   189
0189:  NOP
.................... MaximumLevel 		= read_EEPROM ( MaximumLevelStore);  
018A:  MOVLW  03
018B:  BSF    03.5
018C:  MOVWF  1B
018D:  BCF    1C.7
018E:  BSF    1C.0
018F:  MOVF   1A,W
0190:  BCF    03.5
0191:  MOVWF  57
.................... delay_us(10);  		 
0192:  MOVLW  02
0193:  MOVWF  20
0194:  DECFSZ 20,F
0195:  GOTO   194
0196:  GOTO   197
0197:  NOP
.................... FadeRate 			= read_EEPROM ( FadeRateStore); 
0198:  MOVLW  04
0199:  BSF    03.5
019A:  MOVWF  1B
019B:  BCF    1C.7
019C:  BSF    1C.0
019D:  MOVF   1A,W
019E:  BCF    03.5
019F:  CLRF   5A
01A0:  MOVWF  59
.................... delay_us(10); 
01A1:  MOVLW  02
01A2:  MOVWF  20
01A3:  DECFSZ 20,F
01A4:  GOTO   1A3
01A5:  GOTO   1A6
01A6:  NOP
.................... FadeTime 			= read_EEPROM ( FadeTimeStore ); 
01A7:  MOVLW  05
01A8:  BSF    03.5
01A9:  MOVWF  1B
01AA:  BCF    1C.7
01AB:  BSF    1C.0
01AC:  MOVF   1A,W
01AD:  BCF    03.5
01AE:  MOVWF  5B
.................... delay_us(10); 
01AF:  MOVLW  02
01B0:  MOVWF  20
01B1:  DECFSZ 20,F
01B2:  GOTO   1B1
01B3:  GOTO   1B4
01B4:  NOP
.................... lampid 				= read_EEPROM ( ShortAddressStore ); 
01B5:  MOVLW  06
01B6:  BSF    03.5
01B7:  MOVWF  1B
01B8:  BCF    1C.7
01B9:  BSF    1C.0
01BA:  MOVF   1A,W
01BB:  BCF    03.5
01BC:  MOVWF  67
.................... delay_us(10); 
01BD:  MOVLW  02
01BE:  MOVWF  20
01BF:  DECFSZ 20,F
01C0:  GOTO   1BF
01C1:  GOTO   1C2
01C2:  NOP
....................  
.................... RandomAddress0 		= read_EEPROM ( RandomAddressStore0);  
01C3:  MOVLW  19
01C4:  BSF    03.5
01C5:  MOVWF  1B
01C6:  BCF    1C.7
01C7:  BSF    1C.0
01C8:  MOVF   1A,W
01C9:  BCF    03.5
01CA:  MOVWF  5C
.................... delay_us(10);   
01CB:  MOVLW  02
01CC:  MOVWF  20
01CD:  DECFSZ 20,F
01CE:  GOTO   1CD
01CF:  GOTO   1D0
01D0:  NOP
.................... RandomAddress1 		= read_EEPROM ( RandomAddressStore1);  
01D1:  MOVLW  1A
01D2:  BSF    03.5
01D3:  MOVWF  1B
01D4:  BCF    1C.7
01D5:  BSF    1C.0
01D6:  MOVF   1A,W
01D7:  BCF    03.5
01D8:  MOVWF  5D
.................... delay_us(10); 
01D9:  MOVLW  02
01DA:  MOVWF  20
01DB:  DECFSZ 20,F
01DC:  GOTO   1DB
01DD:  GOTO   1DE
01DE:  NOP
.................... RandomAddress2 		= read_EEPROM ( RandomAddressStore2); 
01DF:  MOVLW  1B
01E0:  BSF    03.5
01E1:  MOVWF  1B
01E2:  BCF    1C.7
01E3:  BSF    1C.0
01E4:  MOVF   1A,W
01E5:  BCF    03.5
01E6:  MOVWF  5E
.................... delay_us(10); 
01E7:  MOVLW  02
01E8:  MOVWF  20
01E9:  DECFSZ 20,F
01EA:  GOTO   1E9
01EB:  GOTO   1EC
01EC:  NOP
....................   		 
.................... FastFadeTime 		= read_EEPROM ( FastFadeTimeStore);  
01ED:  MOVLW  1C
01EE:  BSF    03.5
01EF:  MOVWF  1B
01F0:  BCF    1C.7
01F1:  BSF    1C.0
01F2:  MOVF   1A,W
01F3:  BCF    03.5
01F4:  MOVWF  5F
.................... delay_us(10); 		 
01F5:  MOVLW  02
01F6:  MOVWF  20
01F7:  DECFSZ 20,F
01F8:  GOTO   1F7
01F9:  GOTO   1FA
01FA:  NOP
.................... FailureStatus 		= read_EEPROM ( FailureStatusStore);  
01FB:  MOVLW  1D
01FC:  BSF    03.5
01FD:  MOVWF  1B
01FE:  BCF    1C.7
01FF:  BSF    1C.0
0200:  MOVF   1A,W
0201:  BCF    03.5
0202:  MOVWF  60
.................... delay_us(10);  
0203:  MOVLW  02
0204:  MOVWF  20
0205:  DECFSZ 20,F
0206:  GOTO   205
0207:  GOTO   208
0208:  NOP
.................... OperatingMode 		= read_EEPROM ( OperatingModeStore);  
0209:  MOVLW  1E
020A:  BSF    03.5
020B:  MOVWF  1B
020C:  BCF    1C.7
020D:  BSF    1C.0
020E:  MOVF   1A,W
020F:  BCF    03.5
0210:  MOVWF  61
.................... delay_us(10); 
0211:  MOVLW  02
0212:  MOVWF  20
0213:  DECFSZ 20,F
0214:  GOTO   213
0215:  GOTO   216
0216:  NOP
.................... DimmingCurv 		= read_EEPROM ( DimmingCurveStore); 
0217:  MOVLW  1F
0218:  BSF    03.5
0219:  MOVWF  1B
021A:  BCF    1C.7
021B:  BSF    1C.0
021C:  MOVF   1A,W
021D:  BCF    03.5
021E:  MOVWF  62
.................... delay_us(10);  
021F:  MOVLW  02
0220:  MOVWF  20
0221:  DECFSZ 20,F
0222:  GOTO   221
0223:  GOTO   224
0224:  NOP
.................... zoneid=read_EEPROM(zoneidstore); 
0225:  MOVLW  20
0226:  BSF    03.5
0227:  MOVWF  1B
0228:  BCF    1C.7
0229:  BSF    1C.0
022A:  MOVF   1A,W
022B:  BCF    03.5
022C:  MOVWF  49
022D:  RETURN
....................  
.................... } 
....................  
....................  

Configuration Fuses:
   Word  1: 33CC   INTRC_IO WDT PUT NOMCLR NOPROTECT NOCPD BROWNOUT NOIESO NOFCMEN

ROM data:
002100: 0064 0032 0000 0064 0005 0006 0048 0001 
002108: 0000 0006 0007 0008 

002120: 00D6 
