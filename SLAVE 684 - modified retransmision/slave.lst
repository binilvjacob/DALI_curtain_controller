CCS PCM C Compiler, Version 5.015, 5967               10-Aug-21 16:59

               Filename:   D:\home automation codes\curtain slave\curtain slave\SLAVE 684 - modified retransmision\slave.lst

               ROM used:   1619 words (79%)
                           Largest free fragment is 429
               RAM used:   72 (56%) at main() level
                           89 (70%) worst case
               Stack used: 5 locations (3 in main + 2 for interrupts)
               Stack size: 8

*
0000:  MOVLW  05
0001:  MOVWF  0A
0002:  GOTO   5E0
0003:  NOP
0004:  BTFSC  03.5
0005:  GOTO   00A
0006:  MOVWF  24
0007:  SWAPF  03,W
0008:  MOVWF  25
0009:  GOTO   00F
000A:  BCF    03.5
000B:  MOVWF  24
000C:  SWAPF  03,W
000D:  MOVWF  25
000E:  BSF    25.1
000F:  MOVF   0A,W
0010:  MOVWF  2B
0011:  CLRF   0A
0012:  BCF    03.7
0013:  SWAPF  24,F
0014:  MOVF   04,W
0015:  MOVWF  26
0016:  MOVF   20,W
0017:  MOVWF  27
0018:  MOVF   21,W
0019:  MOVWF  28
001A:  MOVF   22,W
001B:  MOVWF  29
001C:  MOVF   23,W
001D:  MOVWF  2A
001E:  BCF    03.5
001F:  BTFSS  0B.5
0020:  GOTO   023
0021:  BTFSC  0B.2
0022:  GOTO   129
0023:  BTFSS  0B.4
0024:  GOTO   027
0025:  BTFSC  0B.1
0026:  GOTO   040
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.0
002A:  GOTO   02D
002B:  BTFSC  0C.0
002C:  GOTO   074
002D:  MOVF   26,W
002E:  MOVWF  04
002F:  MOVF   27,W
0030:  MOVWF  20
0031:  MOVF   28,W
0032:  MOVWF  21
0033:  MOVF   29,W
0034:  MOVWF  22
0035:  MOVF   2A,W
0036:  MOVWF  23
0037:  MOVF   2B,W
0038:  MOVWF  0A
0039:  SWAPF  25,W
003A:  MOVWF  03
003B:  BCF    03.5
003C:  SWAPF  24,W
003D:  BTFSC  25.1
003E:  BSF    03.5
003F:  RETFIE
.................... #include <slave.h> 
.................... #include <16F684.h> 
.................... //////////// Standard Header file for the PIC16F684 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F684 
*
0269:  MOVLW  10
026A:  MOVWF  6E
026B:  CLRF   20
026C:  CLRF   23
026D:  RRF    6B,F
026E:  RRF    6A,F
026F:  BTFSS  03.0
0270:  GOTO   277
0271:  MOVF   6C,W
0272:  ADDWF  20,F
0273:  BTFSC  03.0
0274:  INCF   23,F
0275:  MOVF   6D,W
0276:  ADDWF  23,F
0277:  RRF    23,F
0278:  RRF    20,F
0279:  RRF    22,F
027A:  RRF    21,F
027B:  DECFSZ 6E,F
027C:  GOTO   26D
027D:  RETURN
....................  
.................... #list 
....................  
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES INTRC_IO                     	//Crystal osc <= 4mhz for PCM/PCH , 3mhz to 10 mhz for PCD 
.................... //#FUSES XT 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES BROWNOUT              	//Reset when brownout detected 
.................... #FUSES NOMCLR                  	//Master Clear pin enabled 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOIESO                	//Internal External Switch Over mode disabled 
.................... #FUSES NOFCMEN               	//Fail-safe clock monitor disabled 
....................  
.................... #use delay(clock=4000000) 
....................  
.................... #include<math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  #include <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0601:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #use delay(clock=4000000) 
*
021C:  MOVLW  69
021D:  MOVWF  04
021E:  MOVF   00,W
021F:  BTFSC  03.2
0220:  GOTO   22F
0221:  MOVLW  01
0222:  MOVWF  21
0223:  CLRF   20
0224:  DECFSZ 20,F
0225:  GOTO   224
0226:  DECFSZ 21,F
0227:  GOTO   223
0228:  MOVLW  4A
0229:  MOVWF  20
022A:  DECFSZ 20,F
022B:  GOTO   22A
022C:  GOTO   22D
022D:  DECFSZ 00,F
022E:  GOTO   221
022F:  RETURN
*
036A:  MOVLW  12
036B:  SUBWF  69,F
036C:  BTFSS  03.0
036D:  GOTO   37C
036E:  MOVLW  69
036F:  MOVWF  04
0370:  MOVLW  FC
0371:  ANDWF  00,F
0372:  BCF    03.0
0373:  RRF    00,F
0374:  RRF    00,F
0375:  MOVF   00,W
0376:  BTFSC  03.2
0377:  GOTO   37C
0378:  GOTO   37A
0379:  NOP
037A:  DECFSZ 00,F
037B:  GOTO   379
....................  
.................... /////////// Driver details /////////////////// 
.................... /* 
.................... fan driver 
....................  
.................... */ 
.................... ///////////////////////////////////////////////// 
....................  
.................... #define device_type 3 /////////// setting device type  
....................  
.................... #define curtain_open_pin pin_c3 
.................... #define curtain_close_pin pin_c2 
....................  
....................  
.................... #define Fixlampid 72                  // LAMP ADDRESS // 
.................... #define zoneid_init   214 // zone address // 1-6 192//,5-8 193//,9-12 194//,13-16 195// 
.................... #define G1 0b00000001 
.................... #define G2 0b00000000 
.................... #define rx pin_a2 
.................... #define tx pin_a0 
.................... #define self 0x01 
....................  
.................... #define MaxDuty  100 //254 1 led 53,2- 58,3-95 
.................... #define MinDuty  0//10  
....................  
....................  
.................... /////////////////////////////////////////////////////////////// 
....................  
.................... #define PowerOnLevelStore    		0           //[0] 
.................... #define SystemFailureLevelStore  	    1           //[1] 
.................... #define MinimumLevelStore           	2			// [2] 
.................... #define MaximumLevelStore  			3 			// [3] 
.................... #define FadeRateStore      			4  			//[4] 
.................... #define FadeTimeStore       			5			//[5] 
.................... #define ShortAddressStore  			6  			//[6] 
.................... #define Group_07Store    			7			//[7] 
.................... #define Group_815Store  			8			///15 [8] 
.................... #define SceneStore  				9			//15 [9-24]/ 
.................... #define RandomAddressStore0  			25			//[25-27] 
.................... #define RandomAddressStore1  			26			//[25-27] 
.................... #define RandomAddressStore2  			27			//[25-27] 
.................... #define FastFadeTimeStore  			28			//[28] 
.................... #define FailureStatusStore  			29			//[29] 
.................... #define OperatingModeStore  30 //[30] 
.................... #define DimmingCurveStore  31   //[31]      
.................... #define ZoneIDStore 32 
....................  
....................  
....................  
.................... ////////////////// Device types //////////////////////// 
.................... /* 
.................... 	lamp =1 
.................... 	fan=2 
.................... 	curtain=3 
.................... 	strip=4 
.................... */ 
.................... //////////////////////////////////////////////////////// 
....................  
.................... #byte dutyreg = 0x15 
....................   
.................... #bit intf = 0x0b.1 
.................... #bit timerOnOff =0x10.0 
....................  
.................... int1 oddevenbit,a,atmp,b,error_flag,over_flowflag; 
.................... unsigned int8 dataCount; 
.................... char data[3],bitcount,tout; 
....................  
....................  
.................... unsigned char curtain_duty=0; 
.................... int16 curtain_time=0;	 
....................  
....................  
.................... char settling_time,i,dly=4,j; 
.................... int1 txmit_error; 
.................... char tx_buffer[3]; 
.................... char r_a,currentSceen; 
.................... char command_st,RetryCount; 
.................... char FadeRateCount=1; 
....................  
.................... char zoneid=zoneid_init; 
....................  
....................  
.................... char stopBitCount,address ,command,databyte; 
.................... int1 dataready,forwrdFrameFlag,backwardFrameFlag ,masterFlag ; 
.................... int16 readDly=300; 
.................... int16 GroupSelectReg; 
.................... char gindex; 
.................... /////// new  ////// 
.................... int txmit_count=0; 
.................... int error_value=0; 
.................... /////////////////// 
....................  
.................... char MinimumLevel; 
.................... char MaximumLevel; 
.................... char SystemFailureLevel; 
.................... int16 FadeRate; 
.................... char FadeTime; 
.................... char RandomAddress0; 
.................... char RandomAddress1; 
.................... char RandomAddress2; 
.................... char FastFadeTime; 
.................... char FailureStatus; 
.................... char OperatingMode; 
.................... char DimmingCurv; 
.................... char PowerOnLevel; 
.................... char DTR,DwriteLocation,DTR_Ready; 
....................  
.................... char lampid  = Fixlampid; 
....................  
.................... void readData(void); 
.................... void init(void); 
.................... void handle(void ); 
.................... void copyData(void); 
.................... void commands(void); 
.................... void txmit(char priority,char length); 
.................... void txmit1(void); 
.................... void txmit0(void); 
.................... void stopbit(void); 
.................... void lamp_on(void); 
.................... void lamp_off(void); 
.................... void startBit(void); 
.................... void init_from_eeprom(void); 
.................... void goto_position(int16); 
....................  
....................  
....................  
....................  
.................... #rom  0x2100={MaxDuty,50,MinDuty,Maxduty,5,6,Fixlampid,G1,G2,6,7,8} 
....................  
.................... #rom  0x2120={zoneid_init} 
....................  
....................  
.................... #int_EXT 
.................... EXT_isr()  
.................... { 
.................... 		restart_wdt(); 		 
*
0040:  CLRWDT
....................             disable_interrupts(int_ext); 
0041:  BCF    0B.4
....................             disable_interrupts(INT_RTCC); 
0042:  BCF    0B.5
....................             bitcount=0; 
0043:  CLRF   36
....................             setup_timer_1(T1_internal|T1_div_by_1); 
0044:  MOVLW  05
0045:  MOVWF  10
....................             set_timer1(0xffff-840); //858  880///old value 923 
0046:  CLRF   0E
0047:  MOVLW  FC
0048:  MOVWF  0F
0049:  MOVLW  B7
004A:  MOVWF  0E
....................             enable_interrupts(int_timer1); 
004B:  BSF    03.5
004C:  BSF    0C.0
....................             stopBitCount = 0; 
004D:  BCF    03.5
004E:  CLRF   48
....................             oddevenbit=1; 
004F:  BSF    31.0
....................             data[0]=0; 
0050:  CLRF   33
....................             data[1]=0; 
0051:  CLRF   34
....................             data[2]=0; 
0052:  CLRF   35
....................             tout=0 ; 
0053:  CLRF   37
....................             datacount = 0;    
0054:  CLRF   32
.................... 			settling_time = 0;  
0055:  CLRF   3B
.................... } 
....................  
....................  
....................  
....................  
0056:  BCF    0B.1
0057:  BCF    0A.3
0058:  GOTO   02D
.................... #int_TIMER1 
.................... TIMER1_isr() 
.................... { 
....................  
....................  
.................... readDly=20; 
*
0074:  CLRF   4E
0075:  MOVLW  14
0076:  MOVWF  4D
.................... error_flag=0; 
0077:  BCF    31.4
.................... 	if(oddevenbit==1) 
0078:  BTFSS  31.0
0079:  GOTO   0B5
.................... 	{ 
.................... 	//	output_high( ); 
.................... 		a=input(rx);  
007A:  BSF    03.5
007B:  BSF    05.2
007C:  BCF    03.5
007D:  BCF    31.1
007E:  BTFSC  05.2
007F:  BSF    31.1
.................... 		atmp=a ;           
0080:  BCF    31.2
0081:  BTFSC  31.1
0082:  BSF    31.2
.................... 		oddevenbit=0 ; 
0083:  BCF    31.0
.................... 		 
.................... 				if(atmp) 
0084:  BTFSS  31.2
0085:  GOTO   09C
.................... 				{ 
.................... 					while(atmp) 
0086:  BTFSS  31.2
0087:  GOTO   09B
.................... 						{ 
.................... 							atmp=input(rx); 
0088:  BSF    03.5
0089:  BSF    05.2
008A:  BCF    03.5
008B:  BCF    31.2
008C:  BTFSC  05.2
008D:  BSF    31.2
.................... 							if(readDly>0) 
008E:  MOVF   4D,F
008F:  BTFSS  03.2
0090:  GOTO   094
0091:  MOVF   4E,F
0092:  BTFSC  03.2
0093:  GOTO   099
.................... 								readDly--; 
0094:  MOVF   4D,W
0095:  BTFSC  03.2
0096:  DECF   4E,F
0097:  DECF   4D,F
0098:  GOTO   09A
.................... 							else 
.................... 								atmp=0; 
0099:  BCF    31.2
009A:  GOTO   086
.................... 								 
.................... 						} 
.................... 				}          
009B:  GOTO   0AD
.................... 				else 
.................... 				{ 
.................... 					while(!atmp) 
009C:  BTFSC  31.2
009D:  GOTO   0AD
.................... 						{ 
.................... 							atmp=input(rx); 
009E:  BSF    03.5
009F:  BSF    05.2
00A0:  BCF    03.5
00A1:  BCF    31.2
00A2:  BTFSC  05.2
00A3:  BSF    31.2
.................... 							readDly--; 
00A4:  MOVF   4D,W
00A5:  BTFSC  03.2
00A6:  DECF   4E,F
00A7:  DECFSZ 4D,F
.................... 								if(readdly==0) 
00A8:  GOTO   0AC
00A9:  MOVF   4E,F
00AA:  BTFSC  03.2
.................... 									{ 
.................... 									atmp=1; 
00AB:  BSF    31.2
.................... 									}	 
00AC:  GOTO   09C
.................... 						} 
.................... 				} 
....................  
.................... 			setup_timer_1(T1_internal|T1_div_by_1);//settimer1with1us least count 
00AD:  MOVLW  05
00AE:  MOVWF  10
.................... 			set_timer1(0xffff-150);  //374  //  355             350////old value 150 
00AF:  CLRF   0E
00B0:  MOVLW  FF
00B1:  MOVWF  0F
00B2:  MOVLW  69
00B3:  MOVWF  0E
.................... 	} 
00B4:  GOTO   124
.................... 	else 
.................... 	{  
.................... 	//	output_low(pin_c3); 
.................... 		b=input(rx) ; // store data line status in the second half 
00B5:  BSF    03.5
00B6:  BSF    05.2
00B7:  BCF    03.5
00B8:  BCF    31.3
00B9:  BTFSC  05.2
00BA:  BSF    31.3
.................... 		oddevenbit=1; 
00BB:  BSF    31.0
.................... 		setup_timer_1(T1_internal|T1_div_by_1); 
00BC:  MOVLW  05
00BD:  MOVWF  10
.................... 		set_timer1(0xffff-350);  // delay  till the next call st to 73 us/////old value 350 
00BE:  CLRF   0E
00BF:  MOVLW  FE
00C0:  MOVWF  0F
00C1:  MOVLW  A1
00C2:  MOVWF  0E
.................... 		readData();  // function  get the dat from the conditions of a and b 
.................... 					 
.................... 	} 
.................... return(0); 
*
0124:  MOVLW  00
0125:  MOVWF  21
....................  
....................  
....................  
....................  
....................  
.................... } 
....................  
0126:  BCF    0C.0
0127:  BCF    0A.3
0128:  GOTO   02D
.................... #int_RTCC 
.................... RTCC_isr() 
.................... {	 
....................  
.................... 	restart_wdt();  
0129:  CLRWDT
.................... 	dly--; 
012A:  DECFSZ 3D,F
....................   	if (dly == 0) 
012B:  GOTO   132
....................   	{	 
....................       dly = 4; 
012C:  MOVLW  04
012D:  MOVWF  3D
....................       if(settling_time < 25) 
012E:  MOVF   3B,W
012F:  SUBLW  18
0130:  BTFSC  03.0
....................       { 
....................           settling_time++; 
0131:  INCF   3B,F
....................       }               
....................    }    
....................  
0132:  BCF    0B.2
0133:  BCF    0A.3
0134:  GOTO   02D
.................... } 
....................  
....................  
.................... void main(void) 
*
05E0:  MOVF   03,W
05E1:  ANDLW  1F
05E2:  MOVWF  03
05E3:  MOVLW  61
05E4:  BSF    03.5
05E5:  MOVWF  0F
05E6:  MOVF   0F,W
05E7:  BCF    03.5
05E8:  CLRF   38
05E9:  CLRF   3A
05EA:  CLRF   39
05EB:  MOVLW  04
05EC:  MOVWF  3D
05ED:  MOVLW  01
05EE:  MOVWF  46
05EF:  MOVLW  D6
05F0:  MOVWF  47
05F1:  MOVLW  01
05F2:  MOVWF  4E
05F3:  MOVLW  2C
05F4:  MOVWF  4D
05F5:  CLRF   52
05F6:  CLRF   53
05F7:  MOVLW  48
05F8:  MOVWF  65
05F9:  BCF    1F.6
05FA:  MOVLW  00
05FB:  BSF    03.5
05FC:  MOVWF  11
05FD:  BCF    03.5
05FE:  CLRF   1A
05FF:  MOVLW  07
0600:  MOVWF  19
....................  
.................... { 
.................... 	init_from_eeprom(); 
*
0602:  CALL   135
.................... 	init();		 
0603:  GOTO   230
.................... 	GroupSelectReg = MAKE16(read_EEPROM (Group_815Store ),read_EEPROM (Group_07Store));	 
0604:  MOVLW  08
0605:  BSF    03.5
0606:  MOVWF  1B
0607:  BCF    1C.7
0608:  BSF    1C.0
0609:  MOVF   1A,W
060A:  BCF    03.5
060B:  MOVWF  66
060C:  MOVLW  07
060D:  BSF    03.5
060E:  MOVWF  1B
060F:  BCF    1C.7
0610:  BSF    1C.0
0611:  MOVF   1A,W
0612:  BCF    03.5
0613:  MOVWF  67
0614:  MOVF   66,W
0615:  MOVWF  50
0616:  MOVF   67,W
0617:  MOVWF  4F
....................  
.................... PowerOnLevel = read_EEPROM (PowerOnLevelStore); 
0618:  BSF    03.5
0619:  CLRF   1B
061A:  BCF    1C.7
061B:  BSF    1C.0
061C:  MOVF   1A,W
061D:  BCF    03.5
061E:  MOVWF  61
....................  
.................... /*	if(PowerOnLevel<= 2) 
.................... 	{ 
.................... 	 	curtain_duty=0;	 
.................... 	 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		curtain_duty = PowerOnLevel;		 
.................... 	} 
.................... */ 
.................... faderate=3; 
061F:  CLRF   58
0620:  MOVLW  03
0621:  MOVWF  57
.................... start: 
.................... //output_toggle(pin_C3); 
.................... 	restart_wdt(); 	 
0622:  CLRWDT
.................... 	if (dataReady ==1) 
0623:  BTFSS  31.7
0624:  GOTO   651
.................... 	{ 
.................... 		if(address == 0xff) 
0625:  INCFSZ 49,W
0626:  GOTO   629
.................... 		{ 
.................... 			handle();  
0627:  CALL   3EF
.................... 		}		 
0628:  GOTO   650
.................... 		else if(address==lampid)		{ 
0629:  MOVF   65,W
062A:  SUBWF  49,W
062B:  BTFSS  03.2
062C:  GOTO   62F
.................... 			 
.................... 			handle();  
062D:  CALL   3EF
.................... 		}		 
062E:  GOTO   650
....................     	else if(address == zoneid) 
062F:  MOVF   47,W
0630:  SUBWF  49,W
0631:  BTFSS  03.2
0632:  GOTO   635
.................... 		{ 
.................... 			handle();	 
0633:  CALL   3EF
.................... 		} 
0634:  GOTO   650
.................... 		else if(address>191 && address<209) 
0635:  MOVF   49,W
0636:  SUBLW  BF
0637:  BTFSC  03.0
0638:  GOTO   650
0639:  MOVF   49,W
063A:  SUBLW  D0
063B:  BTFSS  03.0
063C:  GOTO   650
.................... 		{	 
.................... 			gindex = address &0x0F; 
063D:  MOVF   49,W
063E:  ANDLW  0F
063F:  MOVWF  51
.................... 			if ( bit_test (GroupSelectReg, gindex)==1) 
0640:  MOVF   50,W
0641:  MOVWF  23
0642:  MOVF   4F,W
0643:  MOVWF  22
0644:  MOVF   51,W
0645:  MOVWF  20
0646:  BTFSC  03.2
0647:  GOTO   64D
0648:  BCF    03.0
0649:  RRF    23,F
064A:  RRF    22,F
064B:  DECFSZ 20,F
064C:  GOTO   648
064D:  MOVF   22,W
064E:  BTFSC  22.0
.................... 			{ 				 
.................... 				handle(); 
064F:  CALL   3EF
.................... 			}	 
.................... 		} 
.................... 		dataReady =0; 
0650:  BCF    31.7
.................... 	} 
.................... /*	if(txmit_error==1&&txmit_count<64) 
.................... 	{ 
.................... 		txmit_count++; 
.................... 		txmit(2,2); 
.................... 	}	 
.................... 	else 
.................... 	{ 
.................... 		txmit_count=0; 
.................... 	} 
.................... */ 
.................... 	goto start; 
0651:  GOTO   622
.................... } 
....................  
0652:  SLEEP
.................... void init(void) 
....................  
.................... { 
.................... //	setup_timer_2(T2_OFF);		//26.0 us overflow, 26.0 us interrupt 
....................  	setup_ccp1(CCP_OFF); 
*
0230:  MOVLW  F0
0231:  ANDWF  15,F
.................... //	set_pwm1_duty((int16)10);	 
.................... 	setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1); 
0232:  BSF    03.5
0233:  MOVF   01,W
0234:  ANDLW  C7
0235:  IORLW  08
0236:  MOVWF  01
.................... 	//setup_wdt(WDT_2304MS|WDT_DIV_16); 
.................... 	setup_timer_1(T1_internal|T1_div_by_1); 
0237:  MOVLW  05
0238:  BCF    03.5
0239:  MOVWF  10
.................... 	timerOnOff=0; 
023A:  BCF    10.0
.................... 	ext_int_edge( H_TO_L ); 
023B:  BSF    03.5
023C:  BCF    01.6
.................... 	enable_interrupts(INT_EXT); 
023D:  BCF    03.5
023E:  BSF    0B.4
.................... 	enable_interrupts(INT_RTCC); 
023F:  BSF    0B.5
.................... 	disable_interrupts(INT_TIMER2); 
0240:  BSF    03.5
0241:  BCF    0C.1
.................... 	enable_interrupts(global);	 
0242:  MOVLW  C0
0243:  BCF    03.5
0244:  IORWF  0B,F
.................... 	settling_time =23; 
0245:  MOVLW  17
0246:  MOVWF  3B
.................... 	dataReady =0; 
0247:  BCF    31.7
.................... 	//set_pwm1_duty(0); 
.................... 	     
.................... 	faderate=3; 
0248:  CLRF   58
0249:  MOVLW  03
024A:  MOVWF  57
....................  
.................... 	delay_ms(2000); 
024B:  MOVLW  08
024C:  MOVWF  66
024D:  MOVLW  FA
024E:  MOVWF  69
024F:  CALL   21C
0250:  DECFSZ 66,F
0251:  GOTO   24D
.................... /*	output_high(curtain_open_pin); 
.................... 	delay_ms(1000); 
.................... 	output_low(curtain_open_pin); 
.................... 	delay_ms(1000); 
.................... */ 
.................... 	output_high(curtain_close_pin); 
0252:  BSF    03.5
0253:  BCF    07.2
0254:  BCF    03.5
0255:  BSF    07.2
.................... 	delay_ms(1000); 
0256:  MOVLW  04
0257:  MOVWF  66
0258:  MOVLW  FA
0259:  MOVWF  69
025A:  CALL   21C
025B:  DECFSZ 66,F
025C:  GOTO   258
.................... 	output_low(curtain_close_pin); 
025D:  BSF    03.5
025E:  BCF    07.2
025F:  BCF    03.5
0260:  BCF    07.2
.................... 	delay_ms(1000); 
0261:  MOVLW  04
0262:  MOVWF  66
0263:  MOVLW  FA
0264:  MOVWF  69
0265:  CALL   21C
0266:  DECFSZ 66,F
0267:  GOTO   263
.................... 	 
....................  
.................... 	 
.................... 	return; 
0268:  GOTO   604 (RETURN)
.................... } 
....................  
....................  
....................  
.................... void handle(void ) 
....................  
.................... { 
.................... 	commands(); 
.................... 	delay_ms(2); 
*
05DB:  MOVLW  02
05DC:  MOVWF  69
05DD:  CALL   21C
.................... 	RetryCount =0; 
05DE:  CLRF   45
....................  
.................... return; 
05DF:  RETURN
....................  
.................... } 
....................  
....................  
.................... //				trnsmission of  bit 1			// 
.................... /********************************************************************* 
....................  * Function:       void txmit0(void); 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          transmission of  bit 1 to the bus	 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
.................... **********************************************************************/ 
....................  
.................... void txmit1(void) 
....................  
.................... {      
....................   	txmit_error = 0; 
*
030E:  BCF    31.6
.................... 	if (input(rx)==1) 
030F:  BSF    03.5
0310:  BSF    05.2
0311:  BCF    03.5
0312:  BTFSS  05.2
0313:  GOTO   318
.................... 	{   
.................... 		output_bit(tx,0); 
0314:  BCF    05.0
0315:  BSF    03.5
0316:  BCF    05.0
0317:  BCF    03.5
.................... 	} 
.................... 	delay_us(79); 
0318:  MOVLW  19
0319:  MOVWF  20
031A:  DECFSZ 20,F
031B:  GOTO   31A
031C:  GOTO   31D
031D:  NOP
.................... 	if (input(rx)==1) 
031E:  BSF    03.5
031F:  BSF    05.2
0320:  BCF    03.5
0321:  BTFSS  05.2
0322:  GOTO   329
.................... 	{ 
.................... 		output_bit(tx,1); 
0323:  BSF    05.0
0324:  BSF    03.5
0325:  BCF    05.0
.................... 		txmit_error = 1; 
0326:  BCF    03.5
0327:  BSF    31.6
.................... 		return; 
0328:  GOTO   360
.................... 	}			   
.................... 	delay_us(290);//345 
0329:  MOVLW  60
032A:  MOVWF  20
032B:  DECFSZ 20,F
032C:  GOTO   32B
032D:  NOP
.................... 	if (input(rx)==0) 
032E:  BSF    03.5
032F:  BSF    05.2
0330:  BCF    03.5
0331:  BTFSC  05.2
0332:  GOTO   338
.................... 	{ 
.................... 		output_bit(tx,1); 
0333:  BSF    05.0
0334:  BSF    03.5
0335:  BCF    05.0
.................... 	} 
0336:  GOTO   33F
0337:  BCF    03.5
.................... 	else 
.................... 	{ 
.................... 		output_bit(tx,1); 
0338:  BSF    05.0
0339:  BSF    03.5
033A:  BCF    05.0
.................... 		txmit_error = 1; 
033B:  BCF    03.5
033C:  BSF    31.6
.................... 		return; 
033D:  GOTO   360
033E:  BSF    03.5
.................... 	} 
.................... 	delay_us(79); 
033F:  MOVLW  19
0340:  BCF    03.5
0341:  MOVWF  20
0342:  DECFSZ 20,F
0343:  GOTO   342
0344:  GOTO   345
0345:  NOP
.................... 	if (input(rx)==0) 
0346:  BSF    03.5
0347:  BSF    05.2
0348:  BCF    03.5
0349:  BTFSC  05.2
034A:  GOTO   351
.................... 	{ 
.................... 		output_bit(tx,1); 
034B:  BSF    05.0
034C:  BSF    03.5
034D:  BCF    05.0
.................... 		txmit_error = 1; 
034E:  BCF    03.5
034F:  BSF    31.6
.................... 		return; 
0350:  GOTO   360
.................... 	} 
....................     delay_us(290); 
0351:  MOVLW  60
0352:  MOVWF  20
0353:  DECFSZ 20,F
0354:  GOTO   353
0355:  NOP
.................... 	if (input(rx)==0) 
0356:  BSF    03.5
0357:  BSF    05.2
0358:  BCF    03.5
0359:  BTFSC  05.2
035A:  GOTO   360
.................... 	{ 
.................... 		output_bit(tx,1); 
035B:  BSF    05.0
035C:  BSF    03.5
035D:  BCF    05.0
.................... 		txmit_error = 1; 
035E:  BCF    03.5
035F:  BSF    31.6
.................... 		return; 
.................... 	} 
....................     return; 
0360:  RETURN
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... //         transmission of 0 to the bus      // 
.................... /********************************************************************* 
....................  * Function:       void txmit0(void); 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          transmission of  0 bit to the bus	 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
.................... **********************************************************************/ 
....................  
.................... void txmit0(void) 
....................  
.................... { 
.................... 	txmit_error = 0;	 
*
039C:  BCF    31.6
.................... 	output_bit(tx,1); 
039D:  BSF    05.0
039E:  BSF    03.5
039F:  BCF    05.0
.................... 	delay_us(79); 
03A0:  MOVLW  19
03A1:  BCF    03.5
03A2:  MOVWF  20
03A3:  DECFSZ 20,F
03A4:  GOTO   3A3
03A5:  GOTO   3A6
03A6:  NOP
.................... 	if (input(rx)!=1) 
03A7:  BSF    03.5
03A8:  BSF    05.2
03A9:  BCF    03.5
03AA:  BTFSC  05.2
03AB:  GOTO   3AE
.................... 	{		 
.................... 		txmit_error = 1; 
03AC:  BSF    31.6
.................... 		return; 
03AD:  GOTO   3DD
.................... 	}    
.................... 	delay_us(290); 
03AE:  MOVLW  60
03AF:  MOVWF  20
03B0:  DECFSZ 20,F
03B1:  GOTO   3B0
03B2:  NOP
.................... 	if (input(rx)==1) 
03B3:  BSF    03.5
03B4:  BSF    05.2
03B5:  BCF    03.5
03B6:  BTFSS  05.2
03B7:  GOTO   3BD
.................... 	{ 
.................... 		output_bit(tx,0); 
03B8:  BCF    05.0
03B9:  BSF    03.5
03BA:  BCF    05.0
.................... 	} 
03BB:  GOTO   3C4
03BC:  BCF    03.5
....................     else 
.................... 	{ 
.................... 		output_bit(tx,1); 
03BD:  BSF    05.0
03BE:  BSF    03.5
03BF:  BCF    05.0
.................... 		txmit_error = 1; 
03C0:  BCF    03.5
03C1:  BSF    31.6
.................... 		return; 
03C2:  GOTO   3DD
03C3:  BSF    03.5
.................... 	} 
....................     delay_us(79); 
03C4:  MOVLW  19
03C5:  BCF    03.5
03C6:  MOVWF  20
03C7:  DECFSZ 20,F
03C8:  GOTO   3C7
03C9:  GOTO   3CA
03CA:  NOP
....................     if (input(rx)==1) 
03CB:  BSF    03.5
03CC:  BSF    05.2
03CD:  BCF    03.5
03CE:  BTFSS  05.2
03CF:  GOTO   3D2
.................... 	{		 
.................... 		txmit_error = 1; 
03D0:  BSF    31.6
.................... 		return; 
03D1:  GOTO   3DD
.................... 	} 
....................     delay_us(290); 
03D2:  MOVLW  60
03D3:  MOVWF  20
03D4:  DECFSZ 20,F
03D5:  GOTO   3D4
03D6:  NOP
.................... 	if (input(rx)==1) 
03D7:  BSF    03.5
03D8:  BSF    05.2
03D9:  BCF    03.5
03DA:  BTFSS  05.2
03DB:  GOTO   3DD
.................... 	{		 
.................... 		txmit_error = 1; 
03DC:  BSF    31.6
.................... 		return; 
.................... 	} 
....................     return; 
.................... } 
.................... //----------------------------------------------------------------------------- 
....................                    // txmit2 bit 
.................... //----------------------------------------------------------------------------- 
....................  
.................... void txmit(char priority,char length) 
.................... {  
....................      j= 8*length; 
*
037F:  RLF    67,W
0380:  MOVWF  3E
0381:  RLF    3E,F
0382:  RLF    3E,F
0383:  MOVLW  F8
0384:  ANDWF  3E,F
.................... 	 while (settling_time < 12+priority);      // priority 
0385:  MOVLW  0C
0386:  ADDWF  66,W
0387:  SUBWF  3B,W
0388:  BTFSS  03.0
0389:  GOTO   385
....................      disable_interrupts(global); 
038A:  BCF    0B.6
038B:  BCF    0B.7
038C:  BTFSC  0B.7
038D:  GOTO   38B
....................      txmit1();        // start bit   
038E:  CALL   30E
....................      for(i=0;i<j;i++) 
038F:  CLRF   3C
0390:  MOVF   3E,W
0391:  SUBWF  3C,W
0392:  BTFSC  03.0
0393:  GOTO   3E1
....................          { 
....................             if (shift_left(tx_buffer,3,1)==1) 
0394:  BSF    03.0
0395:  RLF    3F,F
0396:  RLF    40,F
0397:  RLF    41,F
0398:  BTFSS  03.0
0399:  GOTO   39C
....................             { 
....................                  txmit1(); 
039A:  CALL   30E
....................             } 
039B:  GOTO   3DD
....................             else 
....................             { 
....................                   txmit0(); 
....................             } 
....................             if (txmit_error ==1) 
*
03DD:  BTFSC  31.6
....................             { 
....................                goto rr; 
03DE:  GOTO   3E5
....................             }		 
03DF:  INCF   3C,F
03E0:  GOTO   390
....................          }         
....................      stopbit();     
03E1:  CALL   361
....................      stopbit();  
03E2:  CALL   361
.................... 	stopbit(); stopbit(); 
03E3:  CALL   361
03E4:  CALL   361
.................... rr:  output_bit(tx,1); 
03E5:  BSF    05.0
03E6:  BSF    03.5
03E7:  BCF    05.0
.................... 	 settling_time = 0; 
03E8:  BCF    03.5
03E9:  CLRF   3B
....................      intf =0; 
03EA:  BCF    0B.1
....................      enable_interrupts(global);	 
03EB:  MOVLW  C0
03EC:  IORWF  0B,F
.................... 	 enable_interrupts(INT_RTCC); 
03ED:  BSF    0B.5
....................      return; 
03EE:  RETURN
.................... } 
....................  
.................... //-------------------------------------------------------------------------- 
....................           // stop bit function // 
.................... //-------------------------------------------------------------------------- 
.................... void  stopbit(void) 
.................... { 
....................       output_bit(tx,1); 
*
0361:  BSF    05.0
0362:  BSF    03.5
0363:  BCF    05.0
.................... 	  restart_wdt();  
0364:  CLRWDT
....................       delay_us(830); 
0365:  MOVLW  05
0366:  BCF    03.5
0367:  MOVWF  68
0368:  MOVLW  A3
0369:  MOVWF  69
*
037C:  DECFSZ 68,F
037D:  GOTO   368
....................       return; 
037E:  RETURN
.................... } 
....................  
.................... //-------------------------------------------------------------------------- 
....................  
....................  
.................... void readData(void) 
.................... { 
.................... 	restart_wdt();  
*
00C3:  CLRWDT
....................       error_flag=0; 
00C4:  BCF    31.4
....................       datacount++; 
00C5:  INCF   32,F
....................       forwrdFrameFlag = 0; 
00C6:  BCF    4C.0
.................... 	  backwardFrameFlag =0; 
00C7:  BCF    4C.1
....................       if(datacount< 27) 
00C8:  MOVF   32,W
00C9:  SUBLW  1A
00CA:  BTFSS  03.0
00CB:  GOTO   11F
....................       { 
....................          if((a==0 )&& (b==1)) 
00CC:  BTFSC  31.1
00CD:  GOTO   0D5
00CE:  BTFSS  31.3
00CF:  GOTO   0D5
....................          { 
....................             shift_left(data,3,1);  // a one  detewcted on bus  
00D0:  BSF    03.0
00D1:  RLF    33,F
00D2:  RLF    34,F
00D3:  RLF    35,F
....................          } 
00D4:  GOTO   11E
....................          else if((a==1)&&(b==0)) 
00D5:  BTFSS  31.1
00D6:  GOTO   0DE
00D7:  BTFSC  31.3
00D8:  GOTO   0DE
....................          { 
....................             shift_left(data,3,0);  // a zero is  deted on the bus  
00D9:  BCF    03.0
00DA:  RLF    33,F
00DB:  RLF    34,F
00DC:  RLF    35,F
....................          } 
00DD:  GOTO   11E
....................          else if ( a==1 && b==1) 
00DE:  BTFSS  31.1
00DF:  GOTO   119
00E0:  BTFSS  31.3
00E1:  GOTO   119
....................          { 
....................             switch (datacount) 
00E2:  MOVF   32,W
00E3:  XORLW  11
00E4:  BTFSC  03.2
00E5:  GOTO   0F0
00E6:  XORLW  03
00E7:  BTFSC  03.2
00E8:  GOTO   0F2
00E9:  XORLW  0B
00EA:  BTFSC  03.2
00EB:  GOTO   102
00EC:  XORLW  03
00ED:  BTFSC  03.2
00EE:  GOTO   104
00EF:  GOTO   113
....................             { 
....................                case 17: 
....................                { 
....................                      stopBitCount ++; 
00F0:  INCF   48,F
....................                      break; 
00F1:  GOTO   118
....................                } 
....................                case 18: 
....................                { 
....................                   stopBitCount ++; 
00F2:  INCF   48,F
....................                   if(stopBitCount == 2) 
00F3:  MOVF   48,W
00F4:  SUBLW  02
00F5:  BTFSS  03.2
00F6:  GOTO   0FE
....................                   { 
....................                         r_a=1;  
00F7:  MOVLW  01
00F8:  MOVWF  42
....................                         copyData(); 
00F9:  CALL   059
....................                         forwrdFrameFlag = 1; 
00FA:  BSF    4C.0
....................                         masterflag = 0; 
00FB:  BCF    4C.2
....................                         backwardFrameFlag =0; 
00FC:  BCF    4C.1
....................  
....................                   } 
00FD:  GOTO   101
....................                   else 
....................                   { 
.................... 						error_flag =1; 
00FE:  BSF    31.4
.................... 						enable_interrupts(INT_EXT);        
00FF:  BSF    0B.4
.................... 						enable_interrupts(INT_RTCC); 
0100:  BSF    0B.5
....................                   } 
....................                   break; 
0101:  GOTO   118
....................                } 
....................               	case 25: 
.................... 				{ 
.................... 					stopBitCount ++; 
0102:  INCF   48,F
.................... 					break; 
0103:  GOTO   118
.................... 				} 
....................               	case 26:  
.................... 				{ 
.................... 					stopBitCount ++; 
0104:  INCF   48,F
.................... 					if(stopBitCount == 2) 
0105:  MOVF   48,W
0106:  SUBLW  02
0107:  BTFSS  03.2
0108:  GOTO   10F
.................... 					{ 
.................... 						r_a=0;  
0109:  CLRF   42
.................... 						copyData(); 
010A:  CALL   059
.................... 						forwrdFrameFlag =0; 
010B:  BCF    4C.0
.................... 						masterflag = 1; 
010C:  BSF    4C.2
.................... 						backwardFrameFlag =0; 
010D:  BCF    4C.1
.................... 					} 
010E:  GOTO   112
.................... 					else 
.................... 					{ 
.................... 						error_flag =1; 
010F:  BSF    31.4
.................... 						enable_interrupts(INT_EXT);        
0110:  BSF    0B.4
.................... 						enable_interrupts(INT_RTCC); 
0111:  BSF    0B.5
.................... 					} 
.................... 					break; 
0112:  GOTO   118
.................... 				} 
....................                 default: 
....................                 { 
....................                       error_flag=1; 
0113:  BSF    31.4
....................                       timerOnOff=0; 
0114:  BCF    10.0
....................                       enable_interrupts(INT_EXT);   
0115:  BSF    0B.4
.................... 					  enable_interrupts(INT_RTCC); 
0116:  BSF    0B.5
....................                       settling_time = 0; 
0117:  CLRF   3B
....................                       break; 
....................                 } 
....................              }    
....................           }  
0118:  GOTO   11E
.................... 		else 
.................... 		{ 
.................... 			error_flag=1;     
0119:  BSF    31.4
.................... 			settling_time = 0; 
011A:  CLRF   3B
.................... 			timerOnOff=0;        
011B:  BCF    10.0
.................... 			enable_interrupts(INT_EXT);        
011C:  BSF    0B.4
.................... 			enable_interrupts(INT_RTCC);          
011D:  BSF    0B.5
.................... 		} 
....................       } 
011E:  GOTO   124
.................... 	else  // the  data count grater than 27  
.................... 	{ 
.................... 		over_flowflag =1 ; 
011F:  BSF    31.5
.................... 		settling_time = 0; 
0120:  CLRF   3B
.................... 		timerOnOff=0;        
0121:  BCF    10.0
.................... 		enable_interrupts(INT_EXT);        
0122:  BSF    0B.4
.................... 		enable_interrupts(INT_RTCC);          
0123:  BSF    0B.5
.................... 	} 
....................     return; 
.................... } 
....................  
....................  
....................  
....................  
.................... void copyData(void) 
.................... {  
.................... 	restart_wdt();  
*
0059:  CLRWDT
.................... 	dataReady =1;     
005A:  BSF    31.7
.................... 	if( r_a==1) 
005B:  DECFSZ 42,W
005C:  GOTO   062
.................... 	{ 
.................... 		address = data[1]; 
005D:  MOVF   34,W
005E:  MOVWF  49
.................... 		command =data[0];						 
005F:  MOVF   33,W
0060:  MOVWF  4A
.................... 	} 
0061:  GOTO   06B
.................... 	else if( r_a==0) 
0062:  MOVF   42,F
0063:  BTFSS  03.2
0064:  GOTO   06B
.................... 	{	 
.................... 		address = data[2]; 
0065:  MOVF   35,W
0066:  MOVWF  49
.................... 		command =data[1]; 
0067:  MOVF   34,W
0068:  MOVWF  4A
.................... 		databyte=data[0];  
0069:  MOVF   33,W
006A:  MOVWF  4B
.................... 	}        
....................     timerOnOff=0; 
006B:  BCF    10.0
....................     intf =0; 
006C:  BCF    0B.1
....................     enable_interrupts(INT_EXT); 
006D:  BSF    0B.4
....................     disable_interrupts(int_timer1); 
006E:  BSF    03.5
006F:  BCF    0C.0
....................     enable_interrupts(INT_RTCC); 
0070:  BCF    03.5
0071:  BSF    0B.5
....................     settling_time = 0; 
0072:  CLRF   3B
....................     return; 
0073:  RETURN
.................... } 
....................  
....................  
.................... void commands(void) 
.................... {  
.................... 	command_st =0;	 
*
03EF:  CLRF   44
.................... 	switch(command) 
03F0:  MOVF   4A,W
03F1:  XORLW  CA
03F2:  BTFSC  03.2
03F3:  GOTO   419
03F4:  XORLW  01
03F5:  BTFSC  03.2
03F6:  GOTO   42E
03F7:  XORLW  07
03F8:  BTFSC  03.2
03F9:  GOTO   435
03FA:  XORLW  26
03FB:  BTFSC  03.2
03FC:  GOTO   43B
03FD:  XORLW  0D
03FE:  BTFSC  03.2
03FF:  GOTO   456
0400:  XORLW  EE
0401:  BTFSC  03.2
0402:  GOTO   47E
0403:  XORLW  2B
0404:  BTFSC  03.2
0405:  GOTO   541
0406:  XORLW  01
0407:  BTFSC  03.2
0408:  GOTO   565
0409:  XORLW  07
040A:  BTFSC  03.2
040B:  GOTO   56A
040C:  XORLW  01
040D:  BTFSC  03.2
040E:  GOTO   591
040F:  XORLW  03
0410:  BTFSC  03.2
0411:  GOTO   59A
0412:  XORLW  01
0413:  BTFSC  03.2
0414:  GOTO   5A9
0415:  XORLW  16
0416:  BTFSC  03.2
0417:  GOTO   5B7
0418:  GOTO   5C0
.................... 	{ 
.................... 		 
.................... 	   	case 202:	// goto  level  
.................... 		{   
.................... 			 
.................... 			if(databyte > MaximumLevel ) 
0419:  MOVF   4B,W
041A:  SUBWF  55,W
041B:  BTFSC  03.0
041C:  GOTO   420
.................... 			{ 
....................  
....................                 curtain_duty=MaximumLevel; 
041D:  MOVF   55,W
041E:  MOVWF  38
.................... 			} 
041F:  GOTO   429
.................... 			else if(databyte< MinimumLevel ) 
0420:  MOVF   54,W
0421:  SUBWF  4B,W
0422:  BTFSC  03.0
0423:  GOTO   427
.................... 		    { 
.................... 			 
....................                 curtain_duty=MinimumLevel; 
0424:  MOVF   54,W
0425:  MOVWF  38
.................... 			} 
0426:  GOTO   429
.................... 			else 
.................... 			{ 
.................... 		 
....................                 curtain_duty=databyte; 
0427:  MOVF   4B,W
0428:  MOVWF  38
.................... 			} 		 
.................... 			goto_position(curtain_duty);	 
0429:  CLRF   67
042A:  MOVF   38,W
042B:  MOVWF  66
042C:  CALL   27E
.................... 										 
.................... 			break; 
042D:  GOTO   5C2
.................... 		} 
.................... 		case 203:	// on 
.................... 		{  		 
.................... 		 
....................             curtain_duty=100;			 
042E:  MOVLW  64
042F:  MOVWF  38
.................... 			goto_position(curtain_duty);						 
0430:  CLRF   67
0431:  MOVF   38,W
0432:  MOVWF  66
0433:  CALL   27E
.................... 			break; 
0434:  GOTO   5C2
.................... 		} 
.................... 		case 204:	//off 
.................... 		{  	 
.................... 		 
....................          curtain_duty=0; 
0435:  CLRF   38
.................... 		goto_position(curtain_duty); 
0436:  CLRF   67
0437:  MOVF   38,W
0438:  MOVWF  66
0439:  CALL   27E
.................... 			break; 
043A:  GOTO   5C2
.................... 		} 
.................... 	/*	case 216:	//dim 
.................... 		case 241:		//ZONE DIM 
.................... 		{ 
.................... 			if(l_st==1) 
.................... 			{				 
.................... 				if(duty>MinimumLevel) 
.................... 				{							 
.................... 					duty--; 
.................... 					SetDimmLevel(duty);					 
.................... 				} 
.................... 			} 
.................... 			break; 
.................... 		} 
.................... 		case 220:	//bright 
.................... 		case 240:  //zone  bright 
.................... 		{ 
.................... 			if(l_st==1) 
.................... 			{			 
.................... 				if(duty < MaximumLevel) 
.................... 				{									 
.................... 					duty++; 
.................... 					SetDimmLevel(duty);			 
.................... 				} 
.................... 			} 
.................... 			break; 
.................... 		}*/	 
.................... 	 
.................... 		case 234: // scene select  
.................... 		{ 
.................... 			 
.................... 			if(databyte < 17) 
043B:  MOVF   4B,W
043C:  SUBLW  10
043D:  BTFSS  03.0
043E:  GOTO   451
.................... 			{				 
.................... 				currentSceen = databyte;			 
043F:  MOVF   4B,W
0440:  MOVWF  43
.................... 		        curtain_duty = read_EEPROM (currentSceen+SceneStore);	 
0441:  MOVLW  09
0442:  ADDWF  43,W
0443:  MOVWF  66
0444:  MOVF   66,W
0445:  BSF    03.5
0446:  MOVWF  1B
0447:  BCF    1C.7
0448:  BSF    1C.0
0449:  MOVF   1A,W
044A:  BCF    03.5
044B:  MOVWF  38
.................... 			     	if(curtain_duty<=MinimumLevel) 
044C:  MOVF   38,W
044D:  SUBWF  54,W
044E:  BTFSS  03.0
044F:  GOTO   451
.................... 					{ 
.................... 					   	curtain_duty=0;					 
0450:  CLRF   38
.................... 					 
.................... 					} 
.................... 					else 
.................... 					{								 
.................... 							 
.................... 					}			 
.................... 			} 
.................... 			goto_position(curtain_duty); 
0451:  CLRF   67
0452:  MOVF   38,W
0453:  MOVWF  66
0454:  CALL   27E
.................... 			break; 
0455:  GOTO   5C2
.................... 		 } 
.................... 		case 231:  // store sceen  
.................... 		{ 
....................  
.................... 			if(databyte < 17) 
0456:  MOVF   4B,W
0457:  SUBLW  10
0458:  BTFSS  03.0
0459:  GOTO   47D
.................... 			{				 
.................... 				disable_interrupts (global); 
045A:  BCF    0B.6
045B:  BCF    0B.7
045C:  BTFSC  0B.7
045D:  GOTO   45B
.................... 				write_eeprom(databyte+SceneStore,curtain_duty); 
045E:  MOVLW  09
045F:  ADDWF  4B,W
0460:  MOVWF  66
0461:  MOVF   0B,W
0462:  MOVWF  20
0463:  BCF    0B.7
0464:  MOVF   66,W
0465:  BSF    03.5
0466:  MOVWF  1B
0467:  BCF    03.5
0468:  MOVF   38,W
0469:  BSF    03.5
046A:  MOVWF  1A
046B:  BCF    1C.7
046C:  BSF    1C.2
046D:  MOVLW  55
046E:  MOVWF  1D
046F:  MOVLW  AA
0470:  MOVWF  1D
0471:  BSF    1C.1
0472:  BTFSC  1C.1
0473:  GOTO   472
0474:  BCF    1C.2
0475:  BCF    03.5
0476:  MOVF   20,W
0477:  IORWF  0B,F
.................... 				delay_us(5);			 
0478:  GOTO   479
0479:  GOTO   47A
047A:  NOP
.................... 				enable_interrupts(global);	 
047B:  MOVLW  C0
047C:  IORWF  0B,F
.................... 			} 
.................... 			 
.................... 			break; 
047D:  GOTO   5C2
.................... 		} 
.................... 		case 0x09: 
.................... 		{		 
.................... 				GroupSelectReg = MAKE16(read_EEPROM (Group_815Store ),read_EEPROM (Group_07Store));	 
047E:  MOVLW  08
047F:  BSF    03.5
0480:  MOVWF  1B
0481:  BCF    1C.7
0482:  BSF    1C.0
0483:  MOVF   1A,W
0484:  BCF    03.5
0485:  MOVWF  66
0486:  MOVLW  07
0487:  BSF    03.5
0488:  MOVWF  1B
0489:  BCF    1C.7
048A:  BSF    1C.0
048B:  MOVF   1A,W
048C:  BCF    03.5
048D:  MOVWF  67
048E:  MOVF   66,W
048F:  MOVWF  50
0490:  MOVF   67,W
0491:  MOVWF  4F
.................... 				gindex = databyte &0x0f;				 
0492:  MOVF   4B,W
0493:  ANDLW  0F
0494:  MOVWF  51
.................... 				switch (databyte & 0x10) 
0495:  MOVF   4B,W
0496:  ANDLW  10
0497:  BTFSC  03.2
0498:  GOTO   49D
0499:  XORLW  10
049A:  BTFSC  03.2
049B:  GOTO   4F1
049C:  GOTO   540
.................... 				{ 
.................... 					case 0: 
.................... 						{ 
.................... 							bit_clear(GroupSelectReg,gindex); 
049D:  CLRF   23
049E:  MOVLW  01
049F:  MOVWF  22
04A0:  MOVF   51,W
04A1:  MOVWF  20
04A2:  BTFSC  03.2
04A3:  GOTO   4A9
04A4:  BCF    03.0
04A5:  RLF    22,F
04A6:  RLF    23,F
04A7:  DECFSZ 20,F
04A8:  GOTO   4A4
04A9:  MOVF   22,W
04AA:  XORLW  FF
04AB:  MOVWF  20
04AC:  MOVLW  FF
04AD:  XORWF  23,F
04AE:  MOVF   20,W
04AF:  ANDWF  4F,F
04B0:  MOVF   23,W
04B1:  ANDWF  50,F
.................... 							write_eeprom(Group_07Store  ,make8(GroupSelectReg,0)); 
04B2:  MOVF   4F,W
04B3:  MOVWF  66
04B4:  MOVF   0B,W
04B5:  MOVWF  20
04B6:  BCF    0B.7
04B7:  MOVLW  07
04B8:  BSF    03.5
04B9:  MOVWF  1B
04BA:  BCF    03.5
04BB:  MOVF   4F,W
04BC:  BSF    03.5
04BD:  MOVWF  1A
04BE:  BCF    1C.7
04BF:  BSF    1C.2
04C0:  MOVLW  55
04C1:  MOVWF  1D
04C2:  MOVLW  AA
04C3:  MOVWF  1D
04C4:  BSF    1C.1
04C5:  BTFSC  1C.1
04C6:  GOTO   4C5
04C7:  BCF    1C.2
04C8:  BCF    03.5
04C9:  MOVF   20,W
04CA:  IORWF  0B,F
.................... 							delay_us(10); 
04CB:  MOVLW  02
04CC:  MOVWF  20
04CD:  DECFSZ 20,F
04CE:  GOTO   4CD
04CF:  GOTO   4D0
04D0:  NOP
.................... 							write_eeprom(Group_815Store,make8(GroupSelectReg,1)); 
04D1:  MOVF   50,W
04D2:  MOVWF  66
04D3:  MOVF   0B,W
04D4:  MOVWF  20
04D5:  BCF    0B.7
04D6:  MOVLW  08
04D7:  BSF    03.5
04D8:  MOVWF  1B
04D9:  BCF    03.5
04DA:  MOVF   50,W
04DB:  BSF    03.5
04DC:  MOVWF  1A
04DD:  BCF    1C.7
04DE:  BSF    1C.2
04DF:  MOVLW  55
04E0:  MOVWF  1D
04E1:  MOVLW  AA
04E2:  MOVWF  1D
04E3:  BSF    1C.1
04E4:  BTFSC  1C.1
04E5:  GOTO   4E4
04E6:  BCF    1C.2
04E7:  BCF    03.5
04E8:  MOVF   20,W
04E9:  IORWF  0B,F
....................  							delay_us(10); 
04EA:  MOVLW  02
04EB:  MOVWF  20
04EC:  DECFSZ 20,F
04ED:  GOTO   4EC
04EE:  GOTO   4EF
04EF:  NOP
.................... 							break; 
04F0:  GOTO   540
.................... 						} 
.................... 					case 16: 
.................... 						{ 
.................... 							bit_set(GroupSelectReg,gindex); 
04F1:  CLRF   23
04F2:  MOVLW  01
04F3:  MOVWF  22
04F4:  MOVF   51,W
04F5:  MOVWF  20
04F6:  BTFSC  03.2
04F7:  GOTO   4FD
04F8:  BCF    03.0
04F9:  RLF    22,F
04FA:  RLF    23,F
04FB:  DECFSZ 20,F
04FC:  GOTO   4F8
04FD:  MOVF   22,W
04FE:  IORWF  4F,F
04FF:  MOVF   23,W
0500:  IORWF  50,F
.................... 							write_eeprom(Group_07Store  ,make8(GroupSelectReg,0)); 
0501:  MOVF   4F,W
0502:  MOVWF  66
0503:  MOVF   0B,W
0504:  MOVWF  20
0505:  BCF    0B.7
0506:  MOVLW  07
0507:  BSF    03.5
0508:  MOVWF  1B
0509:  BCF    03.5
050A:  MOVF   4F,W
050B:  BSF    03.5
050C:  MOVWF  1A
050D:  BCF    1C.7
050E:  BSF    1C.2
050F:  MOVLW  55
0510:  MOVWF  1D
0511:  MOVLW  AA
0512:  MOVWF  1D
0513:  BSF    1C.1
0514:  BTFSC  1C.1
0515:  GOTO   514
0516:  BCF    1C.2
0517:  BCF    03.5
0518:  MOVF   20,W
0519:  IORWF  0B,F
.................... 							delay_us(10); 
051A:  MOVLW  02
051B:  MOVWF  20
051C:  DECFSZ 20,F
051D:  GOTO   51C
051E:  GOTO   51F
051F:  NOP
.................... 							write_eeprom(Group_815Store,make8(GroupSelectReg,1)); 
0520:  MOVF   50,W
0521:  MOVWF  66
0522:  MOVF   0B,W
0523:  MOVWF  20
0524:  BCF    0B.7
0525:  MOVLW  08
0526:  BSF    03.5
0527:  MOVWF  1B
0528:  BCF    03.5
0529:  MOVF   50,W
052A:  BSF    03.5
052B:  MOVWF  1A
052C:  BCF    1C.7
052D:  BSF    1C.2
052E:  MOVLW  55
052F:  MOVWF  1D
0530:  MOVLW  AA
0531:  MOVWF  1D
0532:  BSF    1C.1
0533:  BTFSC  1C.1
0534:  GOTO   533
0535:  BCF    1C.2
0536:  BCF    03.5
0537:  MOVF   20,W
0538:  IORWF  0B,F
....................  							delay_us(10); 
0539:  MOVLW  02
053A:  MOVWF  20
053B:  DECFSZ 20,F
053C:  GOTO   53B
053D:  GOTO   53E
053E:  NOP
.................... 							break; 
053F:  GOTO   540
.................... 						} 
.................... 					 
.................... 					default: break; 
....................  
.................... 				} 
.................... 				 
.................... 				break ; 
0540:  GOTO   5C2
.................... 		} 
.................... 		case 0x22:    // store  short  aress  
.................... 		{ 
.................... 			if(databyte <64) 
0541:  MOVF   4B,W
0542:  SUBLW  3F
0543:  BTFSS  03.0
0544:  GOTO   564
.................... 			{ 
.................... 					lampid = databyte; 
0545:  MOVF   4B,W
0546:  MOVWF  65
.................... 					write_eeprom(ShortAddressStore ,lampid); 
0547:  MOVF   0B,W
0548:  MOVWF  20
0549:  BCF    0B.7
054A:  MOVLW  06
054B:  BSF    03.5
054C:  MOVWF  1B
054D:  BCF    03.5
054E:  MOVF   65,W
054F:  BSF    03.5
0550:  MOVWF  1A
0551:  BCF    1C.7
0552:  BSF    1C.2
0553:  MOVLW  55
0554:  MOVWF  1D
0555:  MOVLW  AA
0556:  MOVWF  1D
0557:  BSF    1C.1
0558:  BTFSC  1C.1
0559:  GOTO   558
055A:  BCF    1C.2
055B:  BCF    03.5
055C:  MOVF   20,W
055D:  IORWF  0B,F
.................... 					delay_us(10); 
055E:  MOVLW  02
055F:  MOVWF  20
0560:  DECFSZ 20,F
0561:  GOTO   560
0562:  GOTO   563
0563:  NOP
.................... 			} 
.................... 		 
.................... 			break;		 
0564:  GOTO   5C2
.................... 		} 
.................... 		case 0x23:    // write  DTR  
.................... 		{ 
.................... 					DTR = databyte;	 
0565:  MOVF   4B,W
0566:  MOVWF  62
.................... 					DTR_Ready =1; 
0567:  MOVLW  01
0568:  MOVWF  64
.................... 					break; 
0569:  GOTO   5C2
.................... 		} 
.................... 		case 0x24:    // write  DTR  to  adress  location  in data  byte  
.................... 		{ 
.................... 					 
.................... 				DwriteLocation = databyte;	 
056A:  MOVF   4B,W
056B:  MOVWF  63
.................... 				if(DTR_Ready ==1 && DwriteLocation<33 ) 
056C:  DECFSZ 64,W
056D:  GOTO   58F
056E:  MOVF   63,W
056F:  SUBLW  20
0570:  BTFSS  03.0
0571:  GOTO   58F
.................... 				{ 
.................... 					DTR_Ready =0; 
0572:  CLRF   64
.................... 					write_eeprom(DwriteLocation,DTR); 
0573:  MOVF   0B,W
0574:  MOVWF  20
0575:  BCF    0B.7
0576:  MOVF   63,W
0577:  BSF    03.5
0578:  MOVWF  1B
0579:  BCF    03.5
057A:  MOVF   62,W
057B:  BSF    03.5
057C:  MOVWF  1A
057D:  BCF    1C.7
057E:  BSF    1C.2
057F:  MOVLW  55
0580:  MOVWF  1D
0581:  MOVLW  AA
0582:  MOVWF  1D
0583:  BSF    1C.1
0584:  BTFSC  1C.1
0585:  GOTO   584
0586:  BCF    1C.2
0587:  BCF    03.5
0588:  MOVF   20,W
0589:  IORWF  0B,F
.................... 					DELAY_US(20); 
058A:  MOVLW  06
058B:  MOVWF  20
058C:  DECFSZ 20,F
058D:  GOTO   58C
058E:  NOP
.................... 				} 
.................... 			init_from_eeprom(); 
058F:  CALL   135
.................... 			break; 
0590:  GOTO   5C2
.................... 		} 
.................... 		case 0x25:    // Read  DTR  to  adress  location  in data  byte  
.................... 		{ 
.................... 				tx_buffer[2]=lampid;tx_buffer[1]=DTR; txmit(2,2);  /////////priority changed 
0591:  MOVF   65,W
0592:  MOVWF  41
0593:  MOVF   62,W
0594:  MOVWF  40
0595:  MOVLW  02
0596:  MOVWF  66
0597:  MOVWF  67
0598:  CALL   37F
.................... 				break;			 
0599:  GOTO   5C2
.................... 		} 
.................... 		case 0x26:    // Read  eeprom  and  store  in dtr   to  adress  location  in data  byte  
.................... 		{ 
.................... 				DwriteLocation = databyte;	 
059A:  MOVF   4B,W
059B:  MOVWF  63
.................... 				if( DwriteLocation<33 ) 
059C:  MOVF   63,W
059D:  SUBLW  20
059E:  BTFSS  03.0
059F:  GOTO   5A8
.................... 				{ 
.................... 					DTR=Read_eeprom(DwriteLocation); 
05A0:  MOVF   63,W
05A1:  BSF    03.5
05A2:  MOVWF  1B
05A3:  BCF    1C.7
05A4:  BSF    1C.0
05A5:  MOVF   1A,W
05A6:  BCF    03.5
05A7:  MOVWF  62
.................... 				}	 
.................... 				break;				 
05A8:  GOTO   5C2
.................... 		} 
.................... 		case 0x27: 
.................... 		{ 
.................... 			tx_buffer[2]=lampid;tx_buffer[1]=Read_eeprom(0);  
05A9:  MOVF   65,W
05AA:  MOVWF  41
05AB:  BSF    03.5
05AC:  CLRF   1B
05AD:  BCF    1C.7
05AE:  BSF    1C.0
05AF:  MOVF   1A,W
05B0:  BCF    03.5
05B1:  MOVWF  40
.................... 	    	txmit(2,2); 
05B2:  MOVLW  02
05B3:  MOVWF  66
05B4:  MOVWF  67
05B5:  CALL   37F
.................... 		 
.................... 			break; 
05B6:  GOTO   5C2
....................  
.................... 		} 
.................... 		case 0x31: //////////////// case for device type query ///////////////// 
.................... 		{ 
.................... 			tx_buffer[2]=lampid;tx_buffer[1]=device_type;  
05B7:  MOVF   65,W
05B8:  MOVWF  41
05B9:  MOVLW  03
05BA:  MOVWF  40
.................... 			txmit(2,2); 
05BB:  MOVLW  02
05BC:  MOVWF  66
05BD:  MOVWF  67
05BE:  CALL   37F
.................... 					 
.................... 			 
.................... 			break; 
05BF:  GOTO   5C2
....................  
.................... 		} 
.................... 		default: 
.................... 		{ 
.................... 			command_st=1; 
05C0:  MOVLW  01
05C1:  MOVWF  44
.................... 			break; 
.................... 		} 
.................... 	} 
.................... 	if(command_st==0) 
05C2:  MOVF   44,F
05C3:  BTFSS  03.2
05C4:  GOTO   5DB
.................... 	{ 		 
.................... 		  write_eeprom(PowerOnLevelStore,curtain_duty);		 
05C5:  MOVF   0B,W
05C6:  MOVWF  20
05C7:  BCF    0B.7
05C8:  BSF    03.5
05C9:  CLRF   1B
05CA:  BCF    03.5
05CB:  MOVF   38,W
05CC:  BSF    03.5
05CD:  MOVWF  1A
05CE:  BCF    1C.7
05CF:  BSF    1C.2
05D0:  MOVLW  55
05D1:  MOVWF  1D
05D2:  MOVLW  AA
05D3:  MOVWF  1D
05D4:  BSF    1C.1
05D5:  BTFSC  1C.1
05D6:  GOTO   5D5
05D7:  BCF    1C.2
05D8:  BCF    03.5
05D9:  MOVF   20,W
05DA:  IORWF  0B,F
.................... 	} 
....................  
....................  
.................... return; 
.................... } 
....................  
....................  
....................  
.................... void goto_position(int16 position) 
.................... { 
....................  
.................... 	faderate=2; 
*
027E:  CLRF   58
027F:  MOVLW  02
0280:  MOVWF  57
.................... 	curtain_time=position * faderate * 10; 
0281:  MOVF   67,W
0282:  MOVWF  6B
0283:  MOVF   66,W
0284:  MOVWF  6A
0285:  MOVF   58,W
0286:  MOVWF  6D
0287:  MOVF   57,W
0288:  MOVWF  6C
0289:  CALL   269
028A:  MOVF   22,W
028B:  MOVWF  69
028C:  MOVF   21,W
028D:  MOVWF  68
028E:  MOVF   22,W
028F:  MOVWF  6B
0290:  MOVF   21,W
0291:  MOVWF  6A
0292:  CLRF   6D
0293:  MOVLW  0A
0294:  MOVWF  6C
0295:  CALL   269
0296:  MOVF   22,W
0297:  MOVWF  3A
0298:  MOVF   21,W
0299:  MOVWF  39
.................... 	 
.................... 	if(position == 0) 
029A:  MOVF   66,F
029B:  BTFSS  03.2
029C:  GOTO   2AC
029D:  MOVF   67,F
029E:  BTFSS  03.2
029F:  GOTO   2AC
.................... 	{ 
.................... 	output_high(curtain_close_pin); 
02A0:  BSF    03.5
02A1:  BCF    07.2
02A2:  BCF    03.5
02A3:  BSF    07.2
.................... 	delay_ms(100); 
02A4:  MOVLW  64
02A5:  MOVWF  69
02A6:  CALL   21C
.................... 	output_low(curtain_close_pin); 
02A7:  BSF    03.5
02A8:  BCF    07.2
02A9:  BCF    03.5
02AA:  BCF    07.2
.................... 	} 
02AB:  GOTO   30D
.................... 	else if(position==100) 
02AC:  MOVF   66,W
02AD:  SUBLW  64
02AE:  BTFSS  03.2
02AF:  GOTO   2BF
02B0:  MOVF   67,F
02B1:  BTFSS  03.2
02B2:  GOTO   2BF
.................... 	{ 
.................... 	output_high(curtain_open_pin); 
02B3:  BSF    03.5
02B4:  BCF    07.3
02B5:  BCF    03.5
02B6:  BSF    07.3
.................... 	delay_ms(100); 
02B7:  MOVLW  64
02B8:  MOVWF  69
02B9:  CALL   21C
.................... 	output_low(curtain_open_pin); 
02BA:  BSF    03.5
02BB:  BCF    07.3
02BC:  BCF    03.5
02BD:  BCF    07.3
.................... 	} 
02BE:  GOTO   30D
.................... 	else if(position>0 && position <100) 
02BF:  MOVF   66,F
02C0:  BTFSS  03.2
02C1:  GOTO   2C5
02C2:  MOVF   67,F
02C3:  BTFSC  03.2
02C4:  GOTO   302
02C5:  MOVF   67,F
02C6:  BTFSS  03.2
02C7:  GOTO   302
02C8:  MOVF   66,W
02C9:  SUBLW  63
02CA:  BTFSS  03.0
02CB:  GOTO   302
.................... 	{ 
.................... 	// code to go to position 0 
.................... 	output_high(curtain_close_pin); 
02CC:  BSF    03.5
02CD:  BCF    07.2
02CE:  BCF    03.5
02CF:  BSF    07.2
.................... 	delay_ms(100); 
02D0:  MOVLW  64
02D1:  MOVWF  69
02D2:  CALL   21C
.................... 	output_low(curtain_close_pin); 
02D3:  BSF    03.5
02D4:  BCF    07.2
02D5:  BCF    03.5
02D6:  BCF    07.2
.................... 	delay_ms(3000); 
02D7:  MOVLW  0C
02D8:  MOVWF  68
02D9:  MOVLW  FA
02DA:  MOVWF  69
02DB:  CALL   21C
02DC:  DECFSZ 68,F
02DD:  GOTO   2D9
....................  
.................... 	// code to go to desired position 
.................... 	output_high(curtain_open_pin); 
02DE:  BSF    03.5
02DF:  BCF    07.3
02E0:  BCF    03.5
02E1:  BSF    07.3
.................... 	delay_ms(100); 
02E2:  MOVLW  64
02E3:  MOVWF  69
02E4:  CALL   21C
.................... 	output_low(curtain_open_pin); 
02E5:  BSF    03.5
02E6:  BCF    07.3
02E7:  BCF    03.5
02E8:  BCF    07.3
.................... 	delay_ms(curtain_time); 
02E9:  MOVF   3A,W
02EA:  MOVWF  68
02EB:  INCF   68,F
02EC:  DECF   68,F
02ED:  BTFSC  03.2
02EE:  GOTO   2F3
02EF:  MOVLW  FF
02F0:  MOVWF  69
02F1:  CALL   21C
02F2:  GOTO   2EC
02F3:  MOVF   39,W
02F4:  MOVWF  69
02F5:  CALL   21C
.................... 	output_high(curtain_open_pin); 
02F6:  BSF    03.5
02F7:  BCF    07.3
02F8:  BCF    03.5
02F9:  BSF    07.3
.................... 	delay_ms(100); 
02FA:  MOVLW  64
02FB:  MOVWF  69
02FC:  CALL   21C
.................... 	output_low(curtain_open_pin); 
02FD:  BSF    03.5
02FE:  BCF    07.3
02FF:  BCF    03.5
0300:  BCF    07.3
.................... 	} 
0301:  GOTO   30D
.................... 	else 
.................... 	{ 
.................... 	output_high(curtain_close_pin); 
0302:  BSF    03.5
0303:  BCF    07.2
0304:  BCF    03.5
0305:  BSF    07.2
.................... 	delay_ms(100); 
0306:  MOVLW  64
0307:  MOVWF  69
0308:  CALL   21C
.................... 	output_low(curtain_close_pin); 
0309:  BSF    03.5
030A:  BCF    07.2
030B:  BCF    03.5
030C:  BCF    07.2
.................... 	} 
.................... 	 
.................... 	return; 
030D:  RETURN
....................  
....................  
.................... } 
....................  
.................... void init_from_eeprom(void) 
.................... { 
.................... GroupSelectReg = MAKE16(read_EEPROM (Group_815Store ),read_EEPROM (Group_07Store));	 
*
0135:  MOVLW  08
0136:  BSF    03.5
0137:  MOVWF  1B
0138:  BCF    1C.7
0139:  BSF    1C.0
013A:  MOVF   1A,W
013B:  BCF    03.5
013C:  MOVWF  66
013D:  MOVLW  07
013E:  BSF    03.5
013F:  MOVWF  1B
0140:  BCF    1C.7
0141:  BSF    1C.0
0142:  MOVF   1A,W
0143:  BCF    03.5
0144:  MOVWF  67
0145:  MOVF   66,W
0146:  MOVWF  50
0147:  MOVF   67,W
0148:  MOVWF  4F
.................... delay_us(10); 
0149:  MOVLW  02
014A:  MOVWF  20
014B:  DECFSZ 20,F
014C:  GOTO   14B
014D:  GOTO   14E
014E:  NOP
.................... PowerOnLevel 		= read_EEPROM (PowerOnLevelStore); 
014F:  BSF    03.5
0150:  CLRF   1B
0151:  BCF    1C.7
0152:  BSF    1C.0
0153:  MOVF   1A,W
0154:  BCF    03.5
0155:  MOVWF  61
.................... delay_us(10);  
0156:  MOVLW  02
0157:  MOVWF  20
0158:  DECFSZ 20,F
0159:  GOTO   158
015A:  GOTO   15B
015B:  NOP
.................... SystemFailureLevel	= read_EEPROM ( SystemFailureLevelStore );  
015C:  MOVLW  01
015D:  BSF    03.5
015E:  MOVWF  1B
015F:  BCF    1C.7
0160:  BSF    1C.0
0161:  MOVF   1A,W
0162:  BCF    03.5
0163:  MOVWF  56
.................... delay_us(10);	     
0164:  MOVLW  02
0165:  MOVWF  20
0166:  DECFSZ 20,F
0167:  GOTO   166
0168:  GOTO   169
0169:  NOP
.................... MinimumLevel		= read_EEPROM ( MinimumLevelStore );    
016A:  MOVLW  02
016B:  BSF    03.5
016C:  MOVWF  1B
016D:  BCF    1C.7
016E:  BSF    1C.0
016F:  MOVF   1A,W
0170:  BCF    03.5
0171:  MOVWF  54
.................... delay_us(10);       	 
0172:  MOVLW  02
0173:  MOVWF  20
0174:  DECFSZ 20,F
0175:  GOTO   174
0176:  GOTO   177
0177:  NOP
.................... MaximumLevel 		= read_EEPROM ( MaximumLevelStore);  
0178:  MOVLW  03
0179:  BSF    03.5
017A:  MOVWF  1B
017B:  BCF    1C.7
017C:  BSF    1C.0
017D:  MOVF   1A,W
017E:  BCF    03.5
017F:  MOVWF  55
.................... delay_us(10);  		 
0180:  MOVLW  02
0181:  MOVWF  20
0182:  DECFSZ 20,F
0183:  GOTO   182
0184:  GOTO   185
0185:  NOP
.................... FadeRate 			= read_EEPROM ( FadeRateStore); 
0186:  MOVLW  04
0187:  BSF    03.5
0188:  MOVWF  1B
0189:  BCF    1C.7
018A:  BSF    1C.0
018B:  MOVF   1A,W
018C:  BCF    03.5
018D:  CLRF   58
018E:  MOVWF  57
.................... delay_us(10); 
018F:  MOVLW  02
0190:  MOVWF  20
0191:  DECFSZ 20,F
0192:  GOTO   191
0193:  GOTO   194
0194:  NOP
.................... FadeTime 			= read_EEPROM ( FadeTimeStore ); 
0195:  MOVLW  05
0196:  BSF    03.5
0197:  MOVWF  1B
0198:  BCF    1C.7
0199:  BSF    1C.0
019A:  MOVF   1A,W
019B:  BCF    03.5
019C:  MOVWF  59
.................... delay_us(10); 
019D:  MOVLW  02
019E:  MOVWF  20
019F:  DECFSZ 20,F
01A0:  GOTO   19F
01A1:  GOTO   1A2
01A2:  NOP
.................... lampid 				= read_EEPROM ( ShortAddressStore ); 
01A3:  MOVLW  06
01A4:  BSF    03.5
01A5:  MOVWF  1B
01A6:  BCF    1C.7
01A7:  BSF    1C.0
01A8:  MOVF   1A,W
01A9:  BCF    03.5
01AA:  MOVWF  65
.................... delay_us(10); 
01AB:  MOVLW  02
01AC:  MOVWF  20
01AD:  DECFSZ 20,F
01AE:  GOTO   1AD
01AF:  GOTO   1B0
01B0:  NOP
....................  
.................... RandomAddress0 		= read_EEPROM ( RandomAddressStore0);  
01B1:  MOVLW  19
01B2:  BSF    03.5
01B3:  MOVWF  1B
01B4:  BCF    1C.7
01B5:  BSF    1C.0
01B6:  MOVF   1A,W
01B7:  BCF    03.5
01B8:  MOVWF  5A
.................... delay_us(10);   
01B9:  MOVLW  02
01BA:  MOVWF  20
01BB:  DECFSZ 20,F
01BC:  GOTO   1BB
01BD:  GOTO   1BE
01BE:  NOP
.................... RandomAddress1 		= read_EEPROM ( RandomAddressStore1);  
01BF:  MOVLW  1A
01C0:  BSF    03.5
01C1:  MOVWF  1B
01C2:  BCF    1C.7
01C3:  BSF    1C.0
01C4:  MOVF   1A,W
01C5:  BCF    03.5
01C6:  MOVWF  5B
.................... delay_us(10); 
01C7:  MOVLW  02
01C8:  MOVWF  20
01C9:  DECFSZ 20,F
01CA:  GOTO   1C9
01CB:  GOTO   1CC
01CC:  NOP
.................... RandomAddress2 		= read_EEPROM ( RandomAddressStore2); 
01CD:  MOVLW  1B
01CE:  BSF    03.5
01CF:  MOVWF  1B
01D0:  BCF    1C.7
01D1:  BSF    1C.0
01D2:  MOVF   1A,W
01D3:  BCF    03.5
01D4:  MOVWF  5C
.................... delay_us(10); 
01D5:  MOVLW  02
01D6:  MOVWF  20
01D7:  DECFSZ 20,F
01D8:  GOTO   1D7
01D9:  GOTO   1DA
01DA:  NOP
....................   		 
.................... FastFadeTime 		= read_EEPROM ( FastFadeTimeStore);  
01DB:  MOVLW  1C
01DC:  BSF    03.5
01DD:  MOVWF  1B
01DE:  BCF    1C.7
01DF:  BSF    1C.0
01E0:  MOVF   1A,W
01E1:  BCF    03.5
01E2:  MOVWF  5D
.................... delay_us(10); 		 
01E3:  MOVLW  02
01E4:  MOVWF  20
01E5:  DECFSZ 20,F
01E6:  GOTO   1E5
01E7:  GOTO   1E8
01E8:  NOP
.................... FailureStatus 		= read_EEPROM ( FailureStatusStore);  
01E9:  MOVLW  1D
01EA:  BSF    03.5
01EB:  MOVWF  1B
01EC:  BCF    1C.7
01ED:  BSF    1C.0
01EE:  MOVF   1A,W
01EF:  BCF    03.5
01F0:  MOVWF  5E
.................... delay_us(10);  
01F1:  MOVLW  02
01F2:  MOVWF  20
01F3:  DECFSZ 20,F
01F4:  GOTO   1F3
01F5:  GOTO   1F6
01F6:  NOP
.................... OperatingMode 		= read_EEPROM ( OperatingModeStore);  
01F7:  MOVLW  1E
01F8:  BSF    03.5
01F9:  MOVWF  1B
01FA:  BCF    1C.7
01FB:  BSF    1C.0
01FC:  MOVF   1A,W
01FD:  BCF    03.5
01FE:  MOVWF  5F
.................... delay_us(10); 
01FF:  MOVLW  02
0200:  MOVWF  20
0201:  DECFSZ 20,F
0202:  GOTO   201
0203:  GOTO   204
0204:  NOP
.................... DimmingCurv 		= read_EEPROM ( DimmingCurveStore); 
0205:  MOVLW  1F
0206:  BSF    03.5
0207:  MOVWF  1B
0208:  BCF    1C.7
0209:  BSF    1C.0
020A:  MOVF   1A,W
020B:  BCF    03.5
020C:  MOVWF  60
.................... delay_us(10);  
020D:  MOVLW  02
020E:  MOVWF  20
020F:  DECFSZ 20,F
0210:  GOTO   20F
0211:  GOTO   212
0212:  NOP
.................... zoneid=read_EEPROM(zoneidstore); 
0213:  MOVLW  20
0214:  BSF    03.5
0215:  MOVWF  1B
0216:  BCF    1C.7
0217:  BSF    1C.0
0218:  MOVF   1A,W
0219:  BCF    03.5
021A:  MOVWF  47
021B:  RETURN
....................  
.................... } 
....................  
....................  

Configuration Fuses:
   Word  1: 33D4   INTRC_IO NOWDT NOPUT NOMCLR NOPROTECT NOCPD BROWNOUT NOIESO NOFCMEN

ROM data:
002100: 0064 0032 0000 0064 0005 0006 0048 0001 
002108: 0000 0006 0007 0008 

002120: 00D6 
