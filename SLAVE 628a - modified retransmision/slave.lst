CCS PCM C Compiler, Version 5.015, 5967               12-Jun-21 10:02

               Filename:   D:\home automation codes\curtain slave\curtain slave\SLAVE 628a - modified retransmision\slave.lst

               ROM used:   1460 words (71%)
                           Largest free fragment is 588
               RAM used:   75 (33%) at main() level
                           100 (45%) worst case
               Stack used: 5 locations (3 in main + 2 for interrupts)
               Stack size: 8

*
0000:  MOVLW  05
0001:  MOVWF  0A
0002:  GOTO   53E
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   7F,W
0009:  MOVWF  20
000A:  MOVF   0A,W
000B:  MOVWF  27
000C:  CLRF   0A
000D:  SWAPF  20,F
000E:  MOVF   04,W
000F:  MOVWF  22
0010:  MOVF   77,W
0011:  MOVWF  23
0012:  MOVF   78,W
0013:  MOVWF  24
0014:  MOVF   79,W
0015:  MOVWF  25
0016:  MOVF   7A,W
0017:  MOVWF  26
0018:  BCF    03.7
0019:  BCF    03.5
001A:  BTFSS  0B.5
001B:  GOTO   01E
001C:  BTFSC  0B.2
001D:  GOTO   11D
001E:  BTFSS  0B.4
001F:  GOTO   022
0020:  BTFSC  0B.1
0021:  GOTO   039
0022:  MOVLW  8C
0023:  MOVWF  04
0024:  BTFSS  00.0
0025:  GOTO   028
0026:  BTFSC  0C.0
0027:  GOTO   06D
0028:  MOVF   22,W
0029:  MOVWF  04
002A:  MOVF   23,W
002B:  MOVWF  77
002C:  MOVF   24,W
002D:  MOVWF  78
002E:  MOVF   25,W
002F:  MOVWF  79
0030:  MOVF   26,W
0031:  MOVWF  7A
0032:  MOVF   27,W
0033:  MOVWF  0A
0034:  SWAPF  21,W
0035:  MOVWF  03
0036:  SWAPF  7F,F
0037:  SWAPF  7F,W
0038:  RETFIE
.................... #include <slave.h> 
.................... #include <16F628A.h> 
.................... //////////// Standard Header file for the PIC16F628A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F628A 
*
022C:  MOVLW  10
022D:  MOVWF  6C
022E:  CLRF   77
022F:  CLRF   7A
0230:  RRF    69,F
0231:  RRF    68,F
0232:  BTFSS  03.0
0233:  GOTO   23A
0234:  MOVF   6A,W
0235:  ADDWF  77,F
0236:  BTFSC  03.0
0237:  INCF   7A,F
0238:  MOVF   6B,W
0239:  ADDWF  7A,F
023A:  RRF    7A,F
023B:  RRF    77,F
023C:  RRF    79,F
023D:  RRF    78,F
023E:  DECFSZ 6C,F
023F:  GOTO   230
0240:  RETURN
....................  
.................... #list 
....................  
....................  
.................... //#FUSES WDT                 	//No Watch Dog Timer 
.................... //#FUSES xt 
.................... #FUSES INTRC_IO                      	//Crystal osc <= 4mhz for PCM/PCH , 3mhz to 10 mhz for PCD 
.................... #FUSES PUT                 	//No Power Up Timer 
.................... #FUSES PROTECT             	//Code not protected from reading 
.................... #FUSES BROWNOUT            	//No brownout reset 
.................... #FUSES MCLR                  	//Master Clear pin enabled 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOCPD                 	//No EE protection 
....................  
.................... #use delay(clock=4000000,RESTART_WDT) 
....................  
.................... #use rs232(baud=9600,parity=N,xmit=PIN_b2,rcv=PIN_b1,bits=8,DISABLE_INTS,ERRORS) 
.................... setup_adc( ADC_OFF ); 
.................... //#use rs232(baud=19200,parity=N,xmit=PIN_b2,rcv=PIN_b1,bits=8,TIMEOUT=X 
....................  
....................  
.................... #include<math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  #include <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0561:  CLRF   29
0562:  CLRF   2A
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #use delay(clock=4000000) 
*
02B8:  MOVLW  12
02B9:  SUBWF  67,F
02BA:  BTFSS  03.0
02BB:  GOTO   2CB
02BC:  MOVLW  67
02BD:  MOVWF  04
02BE:  BCF    03.7
02BF:  MOVLW  FC
02C0:  ANDWF  00,F
02C1:  BCF    03.0
02C2:  RRF    00,F
02C3:  RRF    00,F
02C4:  MOVF   00,W
02C5:  BTFSC  03.2
02C6:  GOTO   2CB
02C7:  GOTO   2C9
02C8:  NOP
02C9:  DECFSZ 00,F
02CA:  GOTO   2C8
*
0528:  MOVLW  64
0529:  MOVWF  04
052A:  BCF    03.7
052B:  MOVF   00,W
052C:  BTFSC  03.2
052D:  GOTO   53C
052E:  MOVLW  01
052F:  MOVWF  78
0530:  CLRF   77
0531:  DECFSZ 77,F
0532:  GOTO   531
0533:  DECFSZ 78,F
0534:  GOTO   530
0535:  MOVLW  4A
0536:  MOVWF  77
0537:  DECFSZ 77,F
0538:  GOTO   537
0539:  GOTO   53A
053A:  DECFSZ 00,F
053B:  GOTO   52E
....................  
.................... /////////// Driver details /////////////////// 
.................... /* 
.................... fan driver 
....................  
.................... */ 
.................... ///////////////////////////////////////////////// 
....................  
.................... #define device_type 3 /////////// setting device type  
....................  
.................... #define curtain_open_pin pin_c3 
.................... #define curtain_close_pin pin_c2 
....................  
....................  
.................... #define Fixlampid 65                  // LAMP ADDRESS // 
.................... #define zoneid_init   255 // zone address // 1-6 192//,5-8 193//,9-12 194//,13-16 195// 
.................... #define G1 0b00000001 
.................... #define G2 0b00000000 
.................... #define rx pin_b0 
.................... #define tx pin_a2 
.................... #define self 0x01 
....................  
.................... #define MaxDuty  100 //254 1 led 53,2- 58,3-95 
.................... #define MinDuty  0//10  
....................  
....................  
.................... /////////////////////////////////////////////////////////////// 
....................  
.................... #define PowerOnLevelStore    		0           //[0] 
.................... #define SystemFailureLevelStore  	    1           //[1] 
.................... #define MinimumLevelStore           	2			// [2] 
.................... #define MaximumLevelStore  			3 			// [3] 
.................... #define FadeRateStore      			4  			//[4] 
.................... #define FadeTimeStore       			5			//[5] 
.................... #define ShortAddressStore  			6  			//[6] 
.................... #define Group_07Store    			7			//[7] 
.................... #define Group_815Store  			8			///15 [8] 
.................... #define SceneStore  				9			//15 [9-24]/ 
.................... #define RandomAddressStore0  			25			//[25-27] 
.................... #define RandomAddressStore1  			26			//[25-27] 
.................... #define RandomAddressStore2  			27			//[25-27] 
.................... #define FastFadeTimeStore  			28			//[28] 
.................... #define FailureStatusStore  			29			//[29] 
.................... #define OperatingModeStore  30 //[30] 
.................... #define DimmingCurveStore  31   //[31]      
.................... #define ZoneIDStore 32 
....................  
.................... #define PowerOnLevelSore    		0           //[0] 
.................... #define SystemFailurLevelStore  	    1           //[1] 
.................... #define MinimumLeveStore           	2			// [2] 
.................... #define MaximumLevlStore  			3 			// [3] 
.................... #define FadeRateSore      			4  			//[4] 
.................... #define FadeTimetore       			5			//[5] 
.................... #define ShortAdressStore  			6  			//[6] 
.................... #define Group_7Store    			7			//[7] 
.................... #define Group815Store  			8			///15 [8] 
.................... #define ScenStore  				9			//15 [9-24]/ 
.................... #define RanomAddressStore0  			25			//[25-27] 
.................... #define RadomAddressStore1  			26			//[25-27] 
.................... #define RndomAddressStore2  			27			//[25-27] 
.................... #define astFadeTimeStore  			28			//[28] 
.................... #define FalureStatusStore  			29			//[29] 
.................... #define OpratingModeStore  30 //[30] 
.................... #define DimingCurveStore  31   //[31]      
.................... #define ZneIDStore 32 
....................  
.................... #define PowenLevelStore    		0           //[0] 
.................... #define SystFailureLevelStore  	    1           //[1] 
.................... #define MimumLevelStore           	2			// [2] 
.................... #define MamumLevelStore  			3 			// [3] 
.................... #define FeRateStore      			4  			//[4] 
.................... #define FadeTeStore       			5			//[5] 
.................... #define ShortdressStore  			6  			//[6] 
.................... #define Grou07Store    			7			//[7] 
.................... #define Gro_815Store  			8			///15 [8] 
.................... #define SceStore  				9			//15 [9-24]/ 
.................... #define RanmAddressStore0  			25			//[25-27] 
.................... #define RaomAddressStore1  			26			//[25-27] 
.................... #define RaomAddressStore2  			27			//[25-27] 
.................... #define stFadeTimeStore  			28			//[28] 
.................... #define FaireStatusStore  			29			//[29] 
.................... #define OperingModeStore  30 //[30] 
.................... #define DimngCurveStore  31   //[31]      
.................... #define ZoIDStore 32 
....................  
....................  
....................  
....................  
.................... ////////////////// Device types //////////////////////// 
.................... /* 
.................... 	lamp =1 
.................... 	fan=2 
.................... 	curtain=3 
.................... 	strip=4 
.................... */ 
.................... //////////////////////////////////////////////////////// 
....................  
.................... #byte dutyreg = 0x15 
....................   
.................... #bit intf = 0x0b.1 
.................... #bit timerOnOff =0x10.0 
....................  
.................... int1 oddevenbit,a,atmp,b,error_flag,over_flowflag; 
.................... unsigned int8 dataCount; 
.................... char data[3],bitcount,tout; 
....................  
....................  
.................... unsigned char curtain_duty=0; 
.................... int16 curtain_time=0;	 
....................  
....................  
.................... char settling_time,i,dly=4,j; 
.................... int1 txmit_error; 
.................... char tx_buffer[3]; 
.................... char r_a,currentSceen; 
.................... char command_st,RetryCount; 
.................... char FadeRateCount=1; 
....................  
.................... char zoneid=zoneid_init; 
....................  
....................  
.................... char stopBitCount,address ,command,databyte; 
.................... int1 dataready,forwrdFrameFlag,backwardFrameFlag ,masterFlag ; 
.................... int16 readDly=300; 
.................... int16 GroupSelectReg; 
.................... char gindex; 
.................... /////// new  ////// 
.................... int txmit_count=0; 
.................... int error_value=0; 
.................... /////////////////// 
....................  
.................... char MinimumLevel; 
.................... char MaximumLevel; 
.................... char SystemFailureLevel; 
.................... int16 FadeRate; 
.................... char FadeTime; 
.................... char RandomAddress0; 
.................... char RandomAddress1; 
.................... char RandomAddress2; 
.................... char FastFadeTime; 
.................... char FailureStatus; 
.................... char OperatingMode; 
.................... char DimmingCurv; 
.................... char PowerOnLevel; 
.................... char DTR,DwriteLocation,DTR_Ready; 
....................  
.................... char lampid  = Fixlampid; 
....................  
.................... void readData(void); 
.................... void init(void); 
.................... void handle(void ); 
.................... void copyData(void); 
.................... void commands(void); 
.................... void txmit(char priority,char length); 
.................... void txmit1(void); 
.................... void txmit0(void); 
.................... void stopbit(void); 
.................... void lamp_on(void); 
.................... void lamp_off(void); 
.................... void startBit(void); 
.................... void init_from_eeprom(void); 
.................... void goto_position(int16); 
....................  
....................  
....................  
....................  
.................... #rom  0x2100={MaxDuty,50,MinDuty,Maxduty,5,6,Fixlampid,G1,G2,6,7,8} 
....................  
.................... #rom  0x2120={zoneid_init} 
....................  
....................  
.................... #int_EXT 
.................... EXT_isr()  
.................... { 
.................... 		restart_wdt(); 		 
*
0039:  CLRWDT
....................             disable_interrupts(int_ext); 
003A:  BCF    0B.4
....................             disable_interrupts(INT_RTCC); 
003B:  BCF    0B.5
....................             bitcount=0; 
003C:  CLRF   34
....................             setup_timer_1(T1_internal|T1_div_by_1); 
003D:  MOVLW  85
003E:  MOVWF  10
....................             set_timer1(0xffff-840); //858  880///old value 923 
003F:  CLRF   0E
0040:  MOVLW  FC
0041:  MOVWF  0F
0042:  MOVLW  B7
0043:  MOVWF  0E
....................             enable_interrupts(int_timer1); 
0044:  BSF    03.5
0045:  BSF    0C.0
....................             stopBitCount = 0; 
0046:  BCF    03.5
0047:  CLRF   46
....................             oddevenbit=1; 
0048:  BSF    2F.0
....................             data[0]=0; 
0049:  CLRF   31
....................             data[1]=0; 
004A:  CLRF   32
....................             data[2]=0; 
004B:  CLRF   33
....................             tout=0 ; 
004C:  CLRF   35
....................             datacount = 0;    
004D:  CLRF   30
.................... 			settling_time = 0;  
004E:  CLRF   39
.................... } 
....................  
....................  
....................  
....................  
004F:  BCF    0B.1
0050:  BCF    0A.3
0051:  GOTO   028
.................... #int_TIMER1 
.................... TIMER1_isr() 
.................... { 
....................  
....................  
.................... readDly=20; 
*
006D:  CLRF   4C
006E:  MOVLW  14
006F:  MOVWF  4B
.................... error_flag=0; 
0070:  BCF    2F.4
.................... 	if(oddevenbit==1) 
0071:  BTFSS  2F.0
0072:  GOTO   0AE
.................... 	{ 
.................... 	//	output_high( ); 
.................... 		a=input(rx);  
0073:  BSF    03.5
0074:  BSF    06.0
0075:  BCF    03.5
0076:  BCF    2F.1
0077:  BTFSC  06.0
0078:  BSF    2F.1
.................... 		atmp=a ;           
0079:  BCF    2F.2
007A:  BTFSC  2F.1
007B:  BSF    2F.2
.................... 		oddevenbit=0 ; 
007C:  BCF    2F.0
.................... 		 
.................... 				if(atmp) 
007D:  BTFSS  2F.2
007E:  GOTO   095
.................... 				{ 
.................... 					while(atmp) 
007F:  BTFSS  2F.2
0080:  GOTO   094
.................... 						{ 
.................... 							atmp=input(rx); 
0081:  BSF    03.5
0082:  BSF    06.0
0083:  BCF    03.5
0084:  BCF    2F.2
0085:  BTFSC  06.0
0086:  BSF    2F.2
.................... 							if(readDly>0) 
0087:  MOVF   4B,F
0088:  BTFSS  03.2
0089:  GOTO   08D
008A:  MOVF   4C,F
008B:  BTFSC  03.2
008C:  GOTO   092
.................... 								readDly--; 
008D:  MOVF   4B,W
008E:  BTFSC  03.2
008F:  DECF   4C,F
0090:  DECF   4B,F
0091:  GOTO   093
.................... 							else 
.................... 								atmp=0; 
0092:  BCF    2F.2
0093:  GOTO   07F
.................... 								 
.................... 						} 
.................... 				}          
0094:  GOTO   0A6
.................... 				else 
.................... 				{ 
.................... 					while(!atmp) 
0095:  BTFSC  2F.2
0096:  GOTO   0A6
.................... 						{ 
.................... 							atmp=input(rx); 
0097:  BSF    03.5
0098:  BSF    06.0
0099:  BCF    03.5
009A:  BCF    2F.2
009B:  BTFSC  06.0
009C:  BSF    2F.2
.................... 							readDly--; 
009D:  MOVF   4B,W
009E:  BTFSC  03.2
009F:  DECF   4C,F
00A0:  DECFSZ 4B,F
.................... 								if(readdly==0) 
00A1:  GOTO   0A5
00A2:  MOVF   4C,F
00A3:  BTFSC  03.2
.................... 									{ 
.................... 									atmp=1; 
00A4:  BSF    2F.2
.................... 									}	 
00A5:  GOTO   095
.................... 						} 
.................... 				} 
....................  
.................... 			setup_timer_1(T1_internal|T1_div_by_1);//settimer1with1us least count 
00A6:  MOVLW  85
00A7:  MOVWF  10
.................... 			set_timer1(0xffff-150);  //374  //  355             350////old value 150 
00A8:  CLRF   0E
00A9:  MOVLW  FF
00AA:  MOVWF  0F
00AB:  MOVLW  69
00AC:  MOVWF  0E
.................... 	} 
00AD:  GOTO   118
.................... 	else 
.................... 	{  
.................... 	//	output_low(pin_c3); 
.................... 		b=input(rx) ; // store data line status in the second half 
00AE:  BSF    03.5
00AF:  BSF    06.0
00B0:  BCF    03.5
00B1:  BCF    2F.3
00B2:  BTFSC  06.0
00B3:  BSF    2F.3
.................... 		oddevenbit=1; 
00B4:  BSF    2F.0
.................... 		setup_timer_1(T1_internal|T1_div_by_1); 
00B5:  MOVLW  85
00B6:  MOVWF  10
.................... 		set_timer1(0xffff-350);  // delay  till the next call st to 73 us/////old value 350 
00B7:  CLRF   0E
00B8:  MOVLW  FE
00B9:  MOVWF  0F
00BA:  MOVLW  A1
00BB:  MOVWF  0E
.................... 		readData();  // function  get the dat from the conditions of a and b 
.................... 					 
.................... 	} 
.................... return(0); 
*
0118:  MOVLW  00
0119:  MOVWF  78
....................  
....................  
....................  
....................  
....................  
.................... } 
....................  
011A:  BCF    0C.0
011B:  BCF    0A.3
011C:  GOTO   028
.................... #int_RTCC 
.................... RTCC_isr() 
.................... {	 
....................  
.................... 	restart_wdt();  
011D:  CLRWDT
.................... 	dly--; 
011E:  DECFSZ 3B,F
....................   	if (dly == 0) 
011F:  GOTO   126
....................   	{	 
....................       dly = 4; 
0120:  MOVLW  04
0121:  MOVWF  3B
....................       if(settling_time < 25) 
0122:  MOVF   39,W
0123:  SUBLW  18
0124:  BTFSC  03.0
....................       { 
....................           settling_time++; 
0125:  INCF   39,F
....................       }               
....................    }    
....................  
0126:  BCF    0B.2
0127:  BCF    0A.3
0128:  GOTO   028
.................... } 
....................  
....................  
.................... void main(void) 
*
053E:  MOVF   03,W
053F:  ANDLW  1F
0540:  MOVWF  03
0541:  BSF    03.5
0542:  BSF    0E.3
0543:  BCF    03.5
0544:  CLRF   28
0545:  MOVLW  19
0546:  BSF    03.5
0547:  MOVWF  19
0548:  MOVLW  A6
0549:  MOVWF  18
054A:  MOVLW  90
054B:  BCF    03.5
054C:  MOVWF  18
054D:  CLRF   36
054E:  CLRF   38
054F:  CLRF   37
0550:  MOVLW  04
0551:  MOVWF  3B
0552:  MOVLW  01
0553:  MOVWF  44
0554:  MOVLW  FF
0555:  MOVWF  45
0556:  MOVLW  01
0557:  MOVWF  4C
0558:  MOVLW  2C
0559:  MOVWF  4B
055A:  CLRF   50
055B:  CLRF   51
055C:  MOVLW  41
055D:  MOVWF  63
055E:  MOVLW  07
055F:  MOVWF  1F
0560:  BCF    03.7
....................  
.................... { 
.................... 	init_from_eeprom(); 
*
0563:  CALL   129
.................... 	init();		 
0564:  GOTO   210
.................... 	GroupSelectReg = MAKE16(read_EEPROM (Group_815Store ),read_EEPROM (Group_07Store));	 
0565:  MOVLW  08
0566:  BSF    03.5
0567:  MOVWF  1B
0568:  BCF    1C.7
0569:  BSF    1C.0
056A:  MOVF   1A,W
056B:  BCF    03.5
056C:  MOVWF  64
056D:  MOVLW  07
056E:  BSF    03.5
056F:  MOVWF  1B
0570:  BCF    1C.7
0571:  BSF    1C.0
0572:  MOVF   1A,W
0573:  BCF    03.5
0574:  MOVWF  65
0575:  MOVF   64,W
0576:  MOVWF  4E
0577:  MOVF   65,W
0578:  MOVWF  4D
....................  
.................... PowerOnLevel = read_EEPROM (PowerOnLevelStore); 
0579:  BSF    03.5
057A:  CLRF   1B
057B:  BCF    1C.7
057C:  BSF    1C.0
057D:  MOVF   1A,W
057E:  BCF    03.5
057F:  MOVWF  5F
....................  
.................... /*	if(PowerOnLevel<= 2) 
.................... 	{ 
.................... 	 	curtain_duty=0;	 
.................... 	 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		curtain_duty = PowerOnLevel;		 
.................... 	} 
.................... */ 
.................... faderate=3; 
0580:  CLRF   56
0581:  MOVLW  03
0582:  MOVWF  55
.................... start: 
.................... //output_toggle(pin_C3); 
.................... 	restart_wdt(); 	 
0583:  CLRWDT
.................... 	if (dataReady ==1) 
0584:  BTFSS  2F.7
0585:  GOTO   5B2
.................... 	{ 
.................... 		if(address == 0xff) 
0586:  INCFSZ 47,W
0587:  GOTO   58A
.................... 		{ 
.................... 			handle();  
0588:  CALL   33A
.................... 		}		 
0589:  GOTO   5B1
.................... 		else if(address==lampid)		{ 
058A:  MOVF   63,W
058B:  SUBWF  47,W
058C:  BTFSS  03.2
058D:  GOTO   590
.................... 			 
.................... 			handle();  
058E:  CALL   33A
.................... 		}		 
058F:  GOTO   5B1
....................     	else if(address == zoneid) 
0590:  MOVF   45,W
0591:  SUBWF  47,W
0592:  BTFSS  03.2
0593:  GOTO   596
.................... 		{ 
.................... 			handle();	 
0594:  CALL   33A
.................... 		} 
0595:  GOTO   5B1
.................... 		else if(address>191 && address<209) 
0596:  MOVF   47,W
0597:  SUBLW  BF
0598:  BTFSC  03.0
0599:  GOTO   5B1
059A:  MOVF   47,W
059B:  SUBLW  D0
059C:  BTFSS  03.0
059D:  GOTO   5B1
.................... 		{	 
.................... 			gindex = address &0x0F; 
059E:  MOVF   47,W
059F:  ANDLW  0F
05A0:  MOVWF  4F
.................... 			if ( bit_test (GroupSelectReg, gindex)==1) 
05A1:  MOVF   4E,W
05A2:  MOVWF  7A
05A3:  MOVF   4D,W
05A4:  MOVWF  79
05A5:  MOVF   4F,W
05A6:  MOVWF  77
05A7:  BTFSC  03.2
05A8:  GOTO   5AE
05A9:  BCF    03.0
05AA:  RRF    7A,F
05AB:  RRF    79,F
05AC:  DECFSZ 77,F
05AD:  GOTO   5A9
05AE:  MOVF   79,W
05AF:  BTFSC  79.0
.................... 			{ 				 
.................... 				handle(); 
05B0:  CALL   33A
.................... 			}	 
.................... 		} 
.................... 		dataReady =0; 
05B1:  BCF    2F.7
.................... 	} 
.................... /*	if(txmit_error==1&&txmit_count<64) 
.................... 	{ 
.................... 		txmit_count++; 
.................... 		txmit(2,2); 
.................... 	}	 
.................... 	else 
.................... 	{ 
.................... 		txmit_count=0; 
.................... 	} 
.................... */ 
.................... 	goto start; 
05B2:  GOTO   583
.................... } 
....................  
05B3:  SLEEP
.................... void init(void) 
....................  
.................... { 
.................... //	setup_timer_2(T2_OFF);		//26.0 us overflow, 26.0 us interrupt 
....................  	setup_ccp1(CCP_OFF); 
*
0210:  MOVLW  F0
0211:  ANDWF  17,F
.................... //	set_pwm1_duty((int16)10);	 
.................... 	setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1); 
0212:  BSF    03.5
0213:  MOVF   01,W
0214:  ANDLW  C7
0215:  IORLW  08
0216:  MOVWF  01
.................... 	//setup_wdt(WDT_2304MS|WDT_DIV_16); 
.................... 	setup_timer_1(T1_internal|T1_div_by_1); 
0217:  MOVLW  85
0218:  BCF    03.5
0219:  MOVWF  10
.................... 	timerOnOff=0; 
021A:  BCF    10.0
.................... 	ext_int_edge( H_TO_L ); 
021B:  BSF    03.5
021C:  BCF    01.6
.................... 	enable_interrupts(INT_EXT); 
021D:  BCF    03.5
021E:  BSF    0B.4
.................... 	enable_interrupts(INT_RTCC); 
021F:  BSF    0B.5
.................... 	disable_interrupts(INT_TIMER2); 
0220:  BSF    03.5
0221:  BCF    0C.1
.................... 	enable_interrupts(global);	 
0222:  MOVLW  C0
0223:  BCF    03.5
0224:  IORWF  0B,F
.................... 	settling_time =23; 
0225:  MOVLW  17
0226:  MOVWF  39
.................... 	dataReady =0; 
0227:  BCF    2F.7
.................... 	//set_pwm1_duty(0); 
.................... 	     
.................... 	faderate=3; 
0228:  CLRF   56
0229:  MOVLW  03
022A:  MOVWF  55
....................  
.................... /*	output_high(curtain_open_pin); 
.................... 	delay_ms(3000); 
.................... 	output_low(curtain_open_pin); 
.................... 	delay_ms(3000); 
.................... 	output_high(curtain_close_pin); 
.................... 	delay_ms(3000); 
.................... 	output_low(curtain_close_pin); 
.................... 	delay_ms(3000); 
.................... 	*/ 
.................... 	return; 
022B:  GOTO   565 (RETURN)
.................... } 
....................  
....................  
....................  
.................... void handle(void ) 
....................  
.................... { 
.................... 	commands(); 
.................... 	delay_ms(2); 
*
0526:  MOVLW  02
0527:  MOVWF  64
.................... 	RetryCount =0; 
*
053C:  CLRF   43
....................  
.................... return; 
053D:  RETURN
....................  
.................... } 
....................  
....................  
.................... //				trnsmission of  bit 1			// 
.................... /********************************************************************* 
....................  * Function:       void txmit0(void); 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          transmission of  bit 1 to the bus	 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
.................... **********************************************************************/ 
....................  
.................... void txmit1(void) 
....................  
.................... {      
....................   	txmit_error = 0; 
*
025E:  BCF    2F.6
.................... 	if (input(rx)==1) 
025F:  BSF    03.5
0260:  BSF    06.0
0261:  BCF    03.5
0262:  BTFSS  06.0
0263:  GOTO   268
.................... 	{   
.................... 		output_bit(tx,0); 
0264:  BCF    05.2
0265:  BSF    03.5
0266:  BCF    05.2
0267:  BCF    03.5
.................... 	} 
.................... 	delay_us(79); 
0268:  MOVLW  19
0269:  MOVWF  77
026A:  DECFSZ 77,F
026B:  GOTO   26A
026C:  GOTO   26D
026D:  NOP
.................... 	if (input(rx)==1) 
026E:  BSF    03.5
026F:  BSF    06.0
0270:  BCF    03.5
0271:  BTFSS  06.0
0272:  GOTO   279
.................... 	{ 
.................... 		output_bit(tx,1); 
0273:  BSF    05.2
0274:  BSF    03.5
0275:  BCF    05.2
.................... 		txmit_error = 1; 
0276:  BCF    03.5
0277:  BSF    2F.6
.................... 		return; 
0278:  GOTO   2AE
.................... 	}			   
.................... 	delay_us(290);//345 
0279:  MOVLW  60
027A:  MOVWF  77
027B:  DECFSZ 77,F
027C:  GOTO   27B
027D:  NOP
.................... 	if (input(rx)==0) 
027E:  BSF    03.5
027F:  BSF    06.0
0280:  BCF    03.5
0281:  BTFSC  06.0
0282:  GOTO   288
.................... 	{ 
.................... 		output_bit(tx,1); 
0283:  BSF    05.2
0284:  BSF    03.5
0285:  BCF    05.2
.................... 	} 
0286:  GOTO   28F
0287:  BCF    03.5
.................... 	else 
.................... 	{ 
.................... 		output_bit(tx,1); 
0288:  BSF    05.2
0289:  BSF    03.5
028A:  BCF    05.2
.................... 		txmit_error = 1; 
028B:  BCF    03.5
028C:  BSF    2F.6
.................... 		return; 
028D:  GOTO   2AE
028E:  BSF    03.5
.................... 	} 
.................... 	delay_us(79); 
028F:  MOVLW  19
0290:  MOVWF  77
0291:  DECFSZ 77,F
0292:  GOTO   291
0293:  GOTO   294
0294:  NOP
.................... 	if (input(rx)==0) 
0295:  BSF    06.0
0296:  BCF    03.5
0297:  BTFSC  06.0
0298:  GOTO   29F
.................... 	{ 
.................... 		output_bit(tx,1); 
0299:  BSF    05.2
029A:  BSF    03.5
029B:  BCF    05.2
.................... 		txmit_error = 1; 
029C:  BCF    03.5
029D:  BSF    2F.6
.................... 		return; 
029E:  GOTO   2AE
.................... 	} 
....................     delay_us(290); 
029F:  MOVLW  60
02A0:  MOVWF  77
02A1:  DECFSZ 77,F
02A2:  GOTO   2A1
02A3:  NOP
.................... 	if (input(rx)==0) 
02A4:  BSF    03.5
02A5:  BSF    06.0
02A6:  BCF    03.5
02A7:  BTFSC  06.0
02A8:  GOTO   2AE
.................... 	{ 
.................... 		output_bit(tx,1); 
02A9:  BSF    05.2
02AA:  BSF    03.5
02AB:  BCF    05.2
.................... 		txmit_error = 1; 
02AC:  BCF    03.5
02AD:  BSF    2F.6
.................... 		return; 
.................... 	} 
....................     return; 
02AE:  RETURN
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... //         transmission of 0 to the bus      // 
.................... /********************************************************************* 
....................  * Function:       void txmit0(void); 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          transmission of  0 bit to the bus	 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
.................... **********************************************************************/ 
....................  
.................... void txmit0(void) 
....................  
.................... { 
.................... 	txmit_error = 0;	 
*
02EB:  BCF    2F.6
.................... 	output_bit(tx,1); 
02EC:  BSF    05.2
02ED:  BSF    03.5
02EE:  BCF    05.2
.................... 	delay_us(79); 
02EF:  MOVLW  19
02F0:  MOVWF  77
02F1:  DECFSZ 77,F
02F2:  GOTO   2F1
02F3:  GOTO   2F4
02F4:  NOP
.................... 	if (input(rx)!=1) 
02F5:  BSF    06.0
02F6:  BCF    03.5
02F7:  BTFSC  06.0
02F8:  GOTO   2FB
.................... 	{		 
.................... 		txmit_error = 1; 
02F9:  BSF    2F.6
.................... 		return; 
02FA:  GOTO   328
.................... 	}    
.................... 	delay_us(290); 
02FB:  MOVLW  60
02FC:  MOVWF  77
02FD:  DECFSZ 77,F
02FE:  GOTO   2FD
02FF:  NOP
.................... 	if (input(rx)==1) 
0300:  BSF    03.5
0301:  BSF    06.0
0302:  BCF    03.5
0303:  BTFSS  06.0
0304:  GOTO   30A
.................... 	{ 
.................... 		output_bit(tx,0); 
0305:  BCF    05.2
0306:  BSF    03.5
0307:  BCF    05.2
.................... 	} 
0308:  GOTO   311
0309:  BCF    03.5
....................     else 
.................... 	{ 
.................... 		output_bit(tx,1); 
030A:  BSF    05.2
030B:  BSF    03.5
030C:  BCF    05.2
.................... 		txmit_error = 1; 
030D:  BCF    03.5
030E:  BSF    2F.6
.................... 		return; 
030F:  GOTO   328
0310:  BSF    03.5
.................... 	} 
....................     delay_us(79); 
0311:  MOVLW  19
0312:  MOVWF  77
0313:  DECFSZ 77,F
0314:  GOTO   313
0315:  GOTO   316
0316:  NOP
....................     if (input(rx)==1) 
0317:  BSF    06.0
0318:  BCF    03.5
0319:  BTFSS  06.0
031A:  GOTO   31D
.................... 	{		 
.................... 		txmit_error = 1; 
031B:  BSF    2F.6
.................... 		return; 
031C:  GOTO   328
.................... 	} 
....................     delay_us(290); 
031D:  MOVLW  60
031E:  MOVWF  77
031F:  DECFSZ 77,F
0320:  GOTO   31F
0321:  NOP
.................... 	if (input(rx)==1) 
0322:  BSF    03.5
0323:  BSF    06.0
0324:  BCF    03.5
0325:  BTFSS  06.0
0326:  GOTO   328
.................... 	{		 
.................... 		txmit_error = 1; 
0327:  BSF    2F.6
.................... 		return; 
.................... 	} 
....................     return; 
.................... } 
.................... //----------------------------------------------------------------------------- 
....................                    // txmit2 bit 
.................... //----------------------------------------------------------------------------- 
....................  
.................... void txmit(char priority,char length) 
.................... {  
....................      j= 8*length; 
*
02CE:  RLF    65,W
02CF:  MOVWF  3C
02D0:  RLF    3C,F
02D1:  RLF    3C,F
02D2:  MOVLW  F8
02D3:  ANDWF  3C,F
.................... 	 while (settling_time < 12+priority);      // priority 
02D4:  MOVLW  0C
02D5:  ADDWF  64,W
02D6:  SUBWF  39,W
02D7:  BTFSS  03.0
02D8:  GOTO   2D4
....................      disable_interrupts(global); 
02D9:  BCF    0B.6
02DA:  BCF    0B.7
02DB:  BTFSC  0B.7
02DC:  GOTO   2DA
....................      txmit1();        // start bit   
02DD:  CALL   25E
....................      for(i=0;i<j;i++) 
02DE:  CLRF   3A
02DF:  MOVF   3C,W
02E0:  SUBWF  3A,W
02E1:  BTFSC  03.0
02E2:  GOTO   32C
....................          { 
....................             if (shift_left(tx_buffer,3,1)==1) 
02E3:  BSF    03.0
02E4:  RLF    3D,F
02E5:  RLF    3E,F
02E6:  RLF    3F,F
02E7:  BTFSS  03.0
02E8:  GOTO   2EB
....................             { 
....................                  txmit1(); 
02E9:  CALL   25E
....................             } 
02EA:  GOTO   328
....................             else 
....................             { 
....................                   txmit0(); 
....................             } 
....................             if (txmit_error ==1) 
*
0328:  BTFSC  2F.6
....................             { 
....................                goto rr; 
0329:  GOTO   330
....................             }		 
032A:  INCF   3A,F
032B:  GOTO   2DF
....................          }         
....................      stopbit();     
032C:  CALL   2AF
....................      stopbit();  
032D:  CALL   2AF
.................... 	stopbit(); stopbit(); 
032E:  CALL   2AF
032F:  CALL   2AF
.................... rr:  output_bit(tx,1); 
0330:  BSF    05.2
0331:  BSF    03.5
0332:  BCF    05.2
.................... 	 settling_time = 0; 
0333:  BCF    03.5
0334:  CLRF   39
....................      intf =0; 
0335:  BCF    0B.1
....................      enable_interrupts(global);	 
0336:  MOVLW  C0
0337:  IORWF  0B,F
.................... 	 enable_interrupts(INT_RTCC); 
0338:  BSF    0B.5
....................      return; 
0339:  RETURN
.................... } 
....................  
.................... //-------------------------------------------------------------------------- 
....................           // stop bit function // 
.................... //-------------------------------------------------------------------------- 
.................... void  stopbit(void) 
.................... { 
....................       output_bit(tx,1); 
*
02AF:  BSF    05.2
02B0:  BSF    03.5
02B1:  BCF    05.2
.................... 	  restart_wdt();  
02B2:  CLRWDT
....................       delay_us(830); 
02B3:  MOVLW  05
02B4:  BCF    03.5
02B5:  MOVWF  66
02B6:  MOVLW  A3
02B7:  MOVWF  67
*
02CB:  DECFSZ 66,F
02CC:  GOTO   2B6
....................       return; 
02CD:  RETURN
.................... } 
....................  
.................... //-------------------------------------------------------------------------- 
....................  
....................  
.................... void readData(void) 
.................... { 
.................... 	restart_wdt();  
*
00BC:  CLRWDT
....................       error_flag=0; 
00BD:  BCF    2F.4
....................       datacount++; 
00BE:  INCF   30,F
....................       forwrdFrameFlag = 0; 
00BF:  BCF    4A.0
.................... 	  backwardFrameFlag =0; 
00C0:  BCF    4A.1
....................       if(datacount< 27) 
00C1:  MOVF   30,W
00C2:  SUBLW  1A
00C3:  BTFSS  03.0
00C4:  GOTO   113
....................       { 
....................          if((a==0 )&& (b==1)) 
00C5:  BTFSC  2F.1
00C6:  GOTO   0CE
00C7:  BTFSS  2F.3
00C8:  GOTO   0CE
....................          { 
....................             shift_left(data,3,1);  // a one  detewcted on bus  
00C9:  BSF    03.0
00CA:  RLF    31,F
00CB:  RLF    32,F
00CC:  RLF    33,F
....................          } 
00CD:  GOTO   112
....................          else if((a==1)&&(b==0)) 
00CE:  BTFSS  2F.1
00CF:  GOTO   0D7
00D0:  BTFSC  2F.3
00D1:  GOTO   0D7
....................          { 
....................             shift_left(data,3,0);  // a zero is  deted on the bus  
00D2:  BCF    03.0
00D3:  RLF    31,F
00D4:  RLF    32,F
00D5:  RLF    33,F
....................          } 
00D6:  GOTO   112
....................          else if ( a==1 && b==1) 
00D7:  BTFSS  2F.1
00D8:  GOTO   10D
00D9:  BTFSS  2F.3
00DA:  GOTO   10D
....................          { 
....................             switch (datacount) 
00DB:  MOVF   30,W
00DC:  XORLW  11
00DD:  BTFSC  03.2
00DE:  GOTO   0E9
00DF:  XORLW  03
00E0:  BTFSC  03.2
00E1:  GOTO   0EB
00E2:  XORLW  0B
00E3:  BTFSC  03.2
00E4:  GOTO   0F9
00E5:  XORLW  03
00E6:  BTFSC  03.2
00E7:  GOTO   0FB
00E8:  GOTO   108
....................             { 
....................                case 17: 
....................                { 
....................                      stopBitCount ++; 
00E9:  INCF   46,F
....................                      break; 
00EA:  GOTO   10C
....................                } 
....................                case 18: 
....................                { 
....................                   stopBitCount ++; 
00EB:  INCF   46,F
....................                   if(stopBitCount == 2) 
00EC:  MOVF   46,W
00ED:  SUBLW  02
00EE:  BTFSS  03.2
00EF:  GOTO   0F7
....................                   { 
....................                         r_a=1;  
00F0:  MOVLW  01
00F1:  MOVWF  40
....................                         copyData(); 
00F2:  CALL   052
....................                         forwrdFrameFlag = 1; 
00F3:  BSF    4A.0
....................                         masterflag = 0; 
00F4:  BCF    4A.2
....................                         backwardFrameFlag =0; 
00F5:  BCF    4A.1
....................  
....................                   } 
00F6:  GOTO   0F8
....................                   else 
....................                   { 
.................... 						error_flag =1; 
00F7:  BSF    2F.4
....................                   } 
....................                   break; 
00F8:  GOTO   10C
....................                } 
....................               	case 25: 
.................... 				{ 
.................... 					stopBitCount ++; 
00F9:  INCF   46,F
.................... 					break; 
00FA:  GOTO   10C
.................... 				} 
....................               	case 26:  
.................... 				{ 
.................... 					stopBitCount ++; 
00FB:  INCF   46,F
.................... 					if(stopBitCount == 2) 
00FC:  MOVF   46,W
00FD:  SUBLW  02
00FE:  BTFSS  03.2
00FF:  GOTO   106
.................... 					{ 
.................... 						r_a=0;  
0100:  CLRF   40
.................... 						copyData(); 
0101:  CALL   052
.................... 						forwrdFrameFlag =0; 
0102:  BCF    4A.0
.................... 						masterflag = 1; 
0103:  BSF    4A.2
.................... 						backwardFrameFlag =0; 
0104:  BCF    4A.1
.................... 					} 
0105:  GOTO   107
.................... 					else 
.................... 					{ 
.................... 						error_flag =1; 
0106:  BSF    2F.4
.................... 					} 
.................... 					break; 
0107:  GOTO   10C
.................... 				} 
....................                 default: 
....................                 { 
....................                       error_flag=1; 
0108:  BSF    2F.4
....................                       timerOnOff=0; 
0109:  BCF    10.0
....................                       enable_interrupts(INT_EXT); 
010A:  BSF    0B.4
....................                       settling_time = 0; 
010B:  CLRF   39
....................                       break; 
....................                 } 
....................              }    
....................           }  
010C:  GOTO   112
.................... 		else 
.................... 		{ 
.................... 			error_flag=1;     
010D:  BSF    2F.4
.................... 			settling_time = 0; 
010E:  CLRF   39
.................... 			timerOnOff=0;        
010F:  BCF    10.0
.................... 			enable_interrupts(INT_EXT);        
0110:  BSF    0B.4
.................... 			enable_interrupts(INT_RTCC);          
0111:  BSF    0B.5
.................... 		} 
....................       } 
0112:  GOTO   118
.................... 	else  // the  data count grater than 27  
.................... 	{ 
.................... 		over_flowflag =1 ; 
0113:  BSF    2F.5
.................... 		settling_time = 0; 
0114:  CLRF   39
.................... 		timerOnOff=0;        
0115:  BCF    10.0
.................... 		enable_interrupts(INT_EXT);        
0116:  BSF    0B.4
.................... 		enable_interrupts(INT_RTCC);          
0117:  BSF    0B.5
.................... 	} 
....................     return; 
.................... } 
....................  
....................  
....................  
....................  
.................... void copyData(void) 
.................... {  
.................... 	restart_wdt();  
*
0052:  CLRWDT
.................... 	dataReady =1;     
0053:  BSF    2F.7
.................... 	if( r_a==1) 
0054:  DECFSZ 40,W
0055:  GOTO   05B
.................... 	{ 
.................... 		address = data[1]; 
0056:  MOVF   32,W
0057:  MOVWF  47
.................... 		command =data[0];						 
0058:  MOVF   31,W
0059:  MOVWF  48
.................... 	} 
005A:  GOTO   064
.................... 	else if( r_a==0) 
005B:  MOVF   40,F
005C:  BTFSS  03.2
005D:  GOTO   064
.................... 	{	 
.................... 		address = data[2]; 
005E:  MOVF   33,W
005F:  MOVWF  47
.................... 		command =data[1]; 
0060:  MOVF   32,W
0061:  MOVWF  48
.................... 		databyte=data[0];  
0062:  MOVF   31,W
0063:  MOVWF  49
.................... 	}        
....................     timerOnOff=0; 
0064:  BCF    10.0
....................     intf =0; 
0065:  BCF    0B.1
....................     enable_interrupts(INT_EXT); 
0066:  BSF    0B.4
....................     disable_interrupts(int_timer1); 
0067:  BSF    03.5
0068:  BCF    0C.0
....................     enable_interrupts(INT_RTCC); 
0069:  BCF    03.5
006A:  BSF    0B.5
....................     settling_time = 0; 
006B:  CLRF   39
....................     return; 
006C:  RETURN
.................... } 
....................  
....................  
.................... void commands(void) 
.................... {  
.................... 	command_st =0;	 
*
033A:  CLRF   42
.................... 	switch(command) 
033B:  MOVF   48,W
033C:  XORLW  2A
033D:  BTFSC  03.2
033E:  GOTO   364
033F:  XORLW  02
0340:  BTFSC  03.2
0341:  GOTO   379
0342:  XORLW  01
0343:  BTFSC  03.2
0344:  GOTO   380
0345:  XORLW  C3
0346:  BTFSC  03.2
0347:  GOTO   386
0348:  XORLW  0D
0349:  BTFSC  03.2
034A:  GOTO   3A1
034B:  XORLW  EE
034C:  BTFSC  03.2
034D:  GOTO   3C9
034E:  XORLW  2B
034F:  BTFSC  03.2
0350:  GOTO   48C
0351:  XORLW  01
0352:  BTFSC  03.2
0353:  GOTO   4B0
0354:  XORLW  07
0355:  BTFSC  03.2
0356:  GOTO   4B5
0357:  XORLW  01
0358:  BTFSC  03.2
0359:  GOTO   4DC
035A:  XORLW  03
035B:  BTFSC  03.2
035C:  GOTO   4E5
035D:  XORLW  01
035E:  BTFSC  03.2
035F:  GOTO   4F4
0360:  XORLW  16
0361:  BTFSC  03.2
0362:  GOTO   502
0363:  GOTO   50B
.................... 	{ 
.................... 	   	case 42:	// goto  level  
.................... 		{   
.................... 			 
.................... 			if(databyte > MaximumLevel ) 
0364:  MOVF   49,W
0365:  SUBWF  53,W
0366:  BTFSC  03.0
0367:  GOTO   36B
.................... 			{ 
....................  
....................                 curtain_duty=MaximumLevel; 
0368:  MOVF   53,W
0369:  MOVWF  36
.................... 			} 
036A:  GOTO   374
.................... 			else if(databyte< MinimumLevel ) 
036B:  MOVF   52,W
036C:  SUBWF  49,W
036D:  BTFSC  03.0
036E:  GOTO   372
.................... 		    { 
.................... 			 
....................                 curtain_duty=MinimumLevel; 
036F:  MOVF   52,W
0370:  MOVWF  36
.................... 			} 
0371:  GOTO   374
.................... 			else 
.................... 			{ 
.................... 		 
....................                 curtain_duty=databyte; 
0372:  MOVF   49,W
0373:  MOVWF  36
.................... 			} 		 
.................... 			goto_position(curtain_duty);	 
0374:  CLRF   65
0375:  MOVF   36,W
0376:  MOVWF  64
0377:  CALL   241
.................... 										 
.................... 			break; 
0378:  GOTO   50D
.................... 		} 
.................... 		case 40:	// on 
.................... 		{  		 
....................             curtain_duty=100;			 
0379:  MOVLW  64
037A:  MOVWF  36
.................... 			goto_position(curtain_duty);						 
037B:  CLRF   65
037C:  MOVF   36,W
037D:  MOVWF  64
037E:  CALL   241
.................... 			break; 
037F:  GOTO   50D
.................... 		} 
.................... 		case 41:	//off 
.................... 		{  	 
.................... 	 
....................          curtain_duty=0; 
0380:  CLRF   36
.................... 		goto_position(curtain_duty); 
0381:  CLRF   65
0382:  MOVF   36,W
0383:  MOVWF  64
0384:  CALL   241
.................... 			break; 
0385:  GOTO   50D
.................... 		} 
.................... 	/*	case 216:	//dim 
.................... 		case 241:		//ZONE DIM 
.................... 		{ 
.................... 			if(l_st==1) 
.................... 			{				 
.................... 				if(duty>MinimumLevel) 
.................... 				{							 
.................... 					duty--; 
.................... 					SetDimmLevel(duty);					 
.................... 				} 
.................... 			} 
.................... 			break; 
.................... 		} 
.................... 		case 220:	//bright 
.................... 		case 240:  //zone  bright 
.................... 		{ 
.................... 			if(l_st==1) 
.................... 			{			 
.................... 				if(duty < MaximumLevel) 
.................... 				{									 
.................... 					duty++; 
.................... 					SetDimmLevel(duty);			 
.................... 				} 
.................... 			} 
.................... 			break; 
.................... 		}*/	 
.................... 	 
.................... 		case 234: // scene select  
.................... 		{ 
.................... 			 
.................... 			if(databyte < 17) 
0386:  MOVF   49,W
0387:  SUBLW  10
0388:  BTFSS  03.0
0389:  GOTO   39C
.................... 			{				 
.................... 				currentSceen = databyte;			 
038A:  MOVF   49,W
038B:  MOVWF  41
.................... 		        curtain_duty = read_EEPROM (currentSceen+SceneStore);	 
038C:  MOVLW  09
038D:  ADDWF  41,W
038E:  MOVWF  64
038F:  MOVF   64,W
0390:  BSF    03.5
0391:  MOVWF  1B
0392:  BCF    1C.7
0393:  BSF    1C.0
0394:  MOVF   1A,W
0395:  BCF    03.5
0396:  MOVWF  36
.................... 			     	if(curtain_duty<=MinimumLevel) 
0397:  MOVF   36,W
0398:  SUBWF  52,W
0399:  BTFSS  03.0
039A:  GOTO   39C
.................... 					{ 
.................... 					   	curtain_duty=0;					 
039B:  CLRF   36
.................... 					 
.................... 					} 
.................... 					else 
.................... 					{								 
.................... 							 
.................... 					}			 
.................... 			} 
.................... 			goto_position(curtain_duty); 
039C:  CLRF   65
039D:  MOVF   36,W
039E:  MOVWF  64
039F:  CALL   241
.................... 			break; 
03A0:  GOTO   50D
.................... 		 } 
.................... 		case 231:  // store sceen  
.................... 		{ 
....................  
.................... 			if(databyte < 17) 
03A1:  MOVF   49,W
03A2:  SUBLW  10
03A3:  BTFSS  03.0
03A4:  GOTO   3C8
.................... 			{				 
.................... 				disable_interrupts (global); 
03A5:  BCF    0B.6
03A6:  BCF    0B.7
03A7:  BTFSC  0B.7
03A8:  GOTO   3A6
.................... 				write_eeprom(databyte+SceneStore,curtain_duty); 
03A9:  MOVLW  09
03AA:  ADDWF  49,W
03AB:  MOVWF  64
03AC:  MOVF   0B,W
03AD:  MOVWF  77
03AE:  BCF    0B.7
03AF:  MOVF   64,W
03B0:  BSF    03.5
03B1:  MOVWF  1B
03B2:  BCF    03.5
03B3:  MOVF   36,W
03B4:  BSF    03.5
03B5:  MOVWF  1A
03B6:  BCF    1C.7
03B7:  BSF    1C.2
03B8:  MOVLW  55
03B9:  MOVWF  1D
03BA:  MOVLW  AA
03BB:  MOVWF  1D
03BC:  BSF    1C.1
03BD:  BTFSC  1C.1
03BE:  GOTO   3BD
03BF:  BCF    1C.2
03C0:  MOVF   77,W
03C1:  BCF    03.5
03C2:  IORWF  0B,F
.................... 				delay_us(5);			 
03C3:  GOTO   3C4
03C4:  GOTO   3C5
03C5:  NOP
.................... 				enable_interrupts(global);	 
03C6:  MOVLW  C0
03C7:  IORWF  0B,F
.................... 			} 
.................... 			 
.................... 			break; 
03C8:  GOTO   50D
.................... 		} 
.................... 		case 0x09: 
.................... 		{		 
.................... 				GroupSelectReg = MAKE16(read_EEPROM (Group_815Store ),read_EEPROM (Group_07Store));	 
03C9:  MOVLW  08
03CA:  BSF    03.5
03CB:  MOVWF  1B
03CC:  BCF    1C.7
03CD:  BSF    1C.0
03CE:  MOVF   1A,W
03CF:  BCF    03.5
03D0:  MOVWF  64
03D1:  MOVLW  07
03D2:  BSF    03.5
03D3:  MOVWF  1B
03D4:  BCF    1C.7
03D5:  BSF    1C.0
03D6:  MOVF   1A,W
03D7:  BCF    03.5
03D8:  MOVWF  65
03D9:  MOVF   64,W
03DA:  MOVWF  4E
03DB:  MOVF   65,W
03DC:  MOVWF  4D
.................... 				gindex = databyte &0x0f;				 
03DD:  MOVF   49,W
03DE:  ANDLW  0F
03DF:  MOVWF  4F
.................... 				switch (databyte & 0x10) 
03E0:  MOVF   49,W
03E1:  ANDLW  10
03E2:  BTFSC  03.2
03E3:  GOTO   3E8
03E4:  XORLW  10
03E5:  BTFSC  03.2
03E6:  GOTO   43C
03E7:  GOTO   48B
.................... 				{ 
.................... 					case 0: 
.................... 						{ 
.................... 							bit_clear(GroupSelectReg,gindex); 
03E8:  CLRF   7A
03E9:  MOVLW  01
03EA:  MOVWF  79
03EB:  MOVF   4F,W
03EC:  MOVWF  77
03ED:  BTFSC  03.2
03EE:  GOTO   3F4
03EF:  BCF    03.0
03F0:  RLF    79,F
03F1:  RLF    7A,F
03F2:  DECFSZ 77,F
03F3:  GOTO   3EF
03F4:  MOVF   79,W
03F5:  XORLW  FF
03F6:  MOVWF  77
03F7:  MOVLW  FF
03F8:  XORWF  7A,F
03F9:  MOVF   77,W
03FA:  ANDWF  4D,F
03FB:  MOVF   7A,W
03FC:  ANDWF  4E,F
.................... 							write_eeprom(Group_07Store  ,make8(GroupSelectReg,0)); 
03FD:  MOVF   4D,W
03FE:  MOVWF  64
03FF:  MOVF   0B,W
0400:  MOVWF  77
0401:  BCF    0B.7
0402:  MOVLW  07
0403:  BSF    03.5
0404:  MOVWF  1B
0405:  BCF    03.5
0406:  MOVF   4D,W
0407:  BSF    03.5
0408:  MOVWF  1A
0409:  BCF    1C.7
040A:  BSF    1C.2
040B:  MOVLW  55
040C:  MOVWF  1D
040D:  MOVLW  AA
040E:  MOVWF  1D
040F:  BSF    1C.1
0410:  BTFSC  1C.1
0411:  GOTO   410
0412:  BCF    1C.2
0413:  MOVF   77,W
0414:  BCF    03.5
0415:  IORWF  0B,F
.................... 							delay_us(10); 
0416:  MOVLW  02
0417:  MOVWF  77
0418:  DECFSZ 77,F
0419:  GOTO   418
041A:  GOTO   41B
041B:  NOP
.................... 							write_eeprom(Group_815Store,make8(GroupSelectReg,1)); 
041C:  MOVF   4E,W
041D:  MOVWF  64
041E:  MOVF   0B,W
041F:  MOVWF  77
0420:  BCF    0B.7
0421:  MOVLW  08
0422:  BSF    03.5
0423:  MOVWF  1B
0424:  BCF    03.5
0425:  MOVF   4E,W
0426:  BSF    03.5
0427:  MOVWF  1A
0428:  BCF    1C.7
0429:  BSF    1C.2
042A:  MOVLW  55
042B:  MOVWF  1D
042C:  MOVLW  AA
042D:  MOVWF  1D
042E:  BSF    1C.1
042F:  BTFSC  1C.1
0430:  GOTO   42F
0431:  BCF    1C.2
0432:  MOVF   77,W
0433:  BCF    03.5
0434:  IORWF  0B,F
....................  							delay_us(10); 
0435:  MOVLW  02
0436:  MOVWF  77
0437:  DECFSZ 77,F
0438:  GOTO   437
0439:  GOTO   43A
043A:  NOP
.................... 							break; 
043B:  GOTO   48B
.................... 						} 
.................... 					case 16: 
.................... 						{ 
.................... 							bit_set(GroupSelectReg,gindex); 
043C:  CLRF   7A
043D:  MOVLW  01
043E:  MOVWF  79
043F:  MOVF   4F,W
0440:  MOVWF  77
0441:  BTFSC  03.2
0442:  GOTO   448
0443:  BCF    03.0
0444:  RLF    79,F
0445:  RLF    7A,F
0446:  DECFSZ 77,F
0447:  GOTO   443
0448:  MOVF   79,W
0449:  IORWF  4D,F
044A:  MOVF   7A,W
044B:  IORWF  4E,F
.................... 							write_eeprom(Group_07Store  ,make8(GroupSelectReg,0)); 
044C:  MOVF   4D,W
044D:  MOVWF  64
044E:  MOVF   0B,W
044F:  MOVWF  77
0450:  BCF    0B.7
0451:  MOVLW  07
0452:  BSF    03.5
0453:  MOVWF  1B
0454:  BCF    03.5
0455:  MOVF   4D,W
0456:  BSF    03.5
0457:  MOVWF  1A
0458:  BCF    1C.7
0459:  BSF    1C.2
045A:  MOVLW  55
045B:  MOVWF  1D
045C:  MOVLW  AA
045D:  MOVWF  1D
045E:  BSF    1C.1
045F:  BTFSC  1C.1
0460:  GOTO   45F
0461:  BCF    1C.2
0462:  MOVF   77,W
0463:  BCF    03.5
0464:  IORWF  0B,F
.................... 							delay_us(10); 
0465:  MOVLW  02
0466:  MOVWF  77
0467:  DECFSZ 77,F
0468:  GOTO   467
0469:  GOTO   46A
046A:  NOP
.................... 							write_eeprom(Group_815Store,make8(GroupSelectReg,1)); 
046B:  MOVF   4E,W
046C:  MOVWF  64
046D:  MOVF   0B,W
046E:  MOVWF  77
046F:  BCF    0B.7
0470:  MOVLW  08
0471:  BSF    03.5
0472:  MOVWF  1B
0473:  BCF    03.5
0474:  MOVF   4E,W
0475:  BSF    03.5
0476:  MOVWF  1A
0477:  BCF    1C.7
0478:  BSF    1C.2
0479:  MOVLW  55
047A:  MOVWF  1D
047B:  MOVLW  AA
047C:  MOVWF  1D
047D:  BSF    1C.1
047E:  BTFSC  1C.1
047F:  GOTO   47E
0480:  BCF    1C.2
0481:  MOVF   77,W
0482:  BCF    03.5
0483:  IORWF  0B,F
....................  							delay_us(10); 
0484:  MOVLW  02
0485:  MOVWF  77
0486:  DECFSZ 77,F
0487:  GOTO   486
0488:  GOTO   489
0489:  NOP
.................... 							break; 
048A:  GOTO   48B
.................... 						} 
.................... 					 
.................... 					default: break; 
....................  
.................... 				} 
.................... 				 
.................... 				break ; 
048B:  GOTO   50D
.................... 		} 
.................... 		case 0x22:    // store  short  aress  
.................... 		{ 
.................... 			if(databyte <64) 
048C:  MOVF   49,W
048D:  SUBLW  3F
048E:  BTFSS  03.0
048F:  GOTO   4AF
.................... 			{ 
.................... 					lampid = databyte; 
0490:  MOVF   49,W
0491:  MOVWF  63
.................... 					write_eeprom(ShortAddressStore ,lampid); 
0492:  MOVF   0B,W
0493:  MOVWF  77
0494:  BCF    0B.7
0495:  MOVLW  06
0496:  BSF    03.5
0497:  MOVWF  1B
0498:  BCF    03.5
0499:  MOVF   63,W
049A:  BSF    03.5
049B:  MOVWF  1A
049C:  BCF    1C.7
049D:  BSF    1C.2
049E:  MOVLW  55
049F:  MOVWF  1D
04A0:  MOVLW  AA
04A1:  MOVWF  1D
04A2:  BSF    1C.1
04A3:  BTFSC  1C.1
04A4:  GOTO   4A3
04A5:  BCF    1C.2
04A6:  MOVF   77,W
04A7:  BCF    03.5
04A8:  IORWF  0B,F
.................... 					delay_us(10); 
04A9:  MOVLW  02
04AA:  MOVWF  77
04AB:  DECFSZ 77,F
04AC:  GOTO   4AB
04AD:  GOTO   4AE
04AE:  NOP
.................... 			} 
.................... 		 
.................... 			break;		 
04AF:  GOTO   50D
.................... 		} 
.................... 		case 0x23:    // write  DTR  
.................... 		{ 
.................... 					DTR = databyte;	 
04B0:  MOVF   49,W
04B1:  MOVWF  60
.................... 					DTR_Ready =1; 
04B2:  MOVLW  01
04B3:  MOVWF  62
.................... 					break; 
04B4:  GOTO   50D
.................... 		} 
.................... 		case 0x24:    // write  DTR  to  adress  location  in data  byte  
.................... 		{ 
.................... 					 
.................... 				DwriteLocation = databyte;	 
04B5:  MOVF   49,W
04B6:  MOVWF  61
.................... 				if(DTR_Ready ==1 && DwriteLocation<33 ) 
04B7:  DECFSZ 62,W
04B8:  GOTO   4DA
04B9:  MOVF   61,W
04BA:  SUBLW  20
04BB:  BTFSS  03.0
04BC:  GOTO   4DA
.................... 				{ 
.................... 					DTR_Ready =0; 
04BD:  CLRF   62
.................... 					write_eeprom(DwriteLocation,DTR); 
04BE:  MOVF   0B,W
04BF:  MOVWF  77
04C0:  BCF    0B.7
04C1:  MOVF   61,W
04C2:  BSF    03.5
04C3:  MOVWF  1B
04C4:  BCF    03.5
04C5:  MOVF   60,W
04C6:  BSF    03.5
04C7:  MOVWF  1A
04C8:  BCF    1C.7
04C9:  BSF    1C.2
04CA:  MOVLW  55
04CB:  MOVWF  1D
04CC:  MOVLW  AA
04CD:  MOVWF  1D
04CE:  BSF    1C.1
04CF:  BTFSC  1C.1
04D0:  GOTO   4CF
04D1:  BCF    1C.2
04D2:  MOVF   77,W
04D3:  BCF    03.5
04D4:  IORWF  0B,F
.................... 					DELAY_US(20); 
04D5:  MOVLW  06
04D6:  MOVWF  77
04D7:  DECFSZ 77,F
04D8:  GOTO   4D7
04D9:  NOP
.................... 				} 
.................... 			init_from_eeprom(); 
04DA:  CALL   129
.................... 			break; 
04DB:  GOTO   50D
.................... 		} 
.................... 		case 0x25:    // Read  DTR  to  adress  location  in data  byte  
.................... 		{ 
.................... 				tx_buffer[2]=lampid;tx_buffer[1]=DTR; txmit(2,2);  /////////priority changed 
04DC:  MOVF   63,W
04DD:  MOVWF  3F
04DE:  MOVF   60,W
04DF:  MOVWF  3E
04E0:  MOVLW  02
04E1:  MOVWF  64
04E2:  MOVWF  65
04E3:  CALL   2CE
.................... 				break;			 
04E4:  GOTO   50D
.................... 		} 
.................... 		case 0x26:    // Read  eeprom  and  store  in dtr   to  adress  location  in data  byte  
.................... 		{ 
.................... 				DwriteLocation = databyte;	 
04E5:  MOVF   49,W
04E6:  MOVWF  61
.................... 				if( DwriteLocation<33 ) 
04E7:  MOVF   61,W
04E8:  SUBLW  20
04E9:  BTFSS  03.0
04EA:  GOTO   4F3
.................... 				{ 
.................... 					DTR=Read_eeprom(DwriteLocation); 
04EB:  MOVF   61,W
04EC:  BSF    03.5
04ED:  MOVWF  1B
04EE:  BCF    1C.7
04EF:  BSF    1C.0
04F0:  MOVF   1A,W
04F1:  BCF    03.5
04F2:  MOVWF  60
.................... 				}	 
.................... 				break;				 
04F3:  GOTO   50D
.................... 		} 
.................... 		case 0x27: 
.................... 		{ 
.................... 			tx_buffer[2]=lampid;tx_buffer[1]=Read_eeprom(0);  
04F4:  MOVF   63,W
04F5:  MOVWF  3F
04F6:  BSF    03.5
04F7:  CLRF   1B
04F8:  BCF    1C.7
04F9:  BSF    1C.0
04FA:  MOVF   1A,W
04FB:  BCF    03.5
04FC:  MOVWF  3E
.................... 	    	txmit(2,2); 
04FD:  MOVLW  02
04FE:  MOVWF  64
04FF:  MOVWF  65
0500:  CALL   2CE
.................... 		 
.................... 			break; 
0501:  GOTO   50D
....................  
.................... 		} 
.................... 		case 0x31: //////////////// case for device type query ///////////////// 
.................... 		{ 
.................... 			tx_buffer[2]=lampid;tx_buffer[1]=device_type;  
0502:  MOVF   63,W
0503:  MOVWF  3F
0504:  MOVLW  03
0505:  MOVWF  3E
.................... 			txmit(2,2); 
0506:  MOVLW  02
0507:  MOVWF  64
0508:  MOVWF  65
0509:  CALL   2CE
.................... 					 
.................... 			 
.................... 			break; 
050A:  GOTO   50D
....................  
.................... 		} 
.................... 		default: 
.................... 		{ 
.................... 			command_st=1; 
050B:  MOVLW  01
050C:  MOVWF  42
.................... 			break; 
.................... 		} 
.................... 	} 
.................... 	if(command_st==0) 
050D:  MOVF   42,F
050E:  BTFSS  03.2
050F:  GOTO   526
.................... 	{ 		 
.................... 		  write_eeprom(PowerOnLevelStore,curtain_duty);		 
0510:  MOVF   0B,W
0511:  MOVWF  77
0512:  BCF    0B.7
0513:  BSF    03.5
0514:  CLRF   1B
0515:  BCF    03.5
0516:  MOVF   36,W
0517:  BSF    03.5
0518:  MOVWF  1A
0519:  BCF    1C.7
051A:  BSF    1C.2
051B:  MOVLW  55
051C:  MOVWF  1D
051D:  MOVLW  AA
051E:  MOVWF  1D
051F:  BSF    1C.1
0520:  BTFSC  1C.1
0521:  GOTO   520
0522:  BCF    1C.2
0523:  MOVF   77,W
0524:  BCF    03.5
0525:  IORWF  0B,F
.................... 	} 
....................  
....................  
.................... return; 
.................... } 
....................  
....................  
....................  
.................... void goto_position(int16 position) 
.................... { 
....................  
.................... 	faderate=2; 
*
0241:  CLRF   56
0242:  MOVLW  02
0243:  MOVWF  55
.................... 	curtain_time=position * faderate * 10; 
0244:  MOVF   65,W
0245:  MOVWF  69
0246:  MOVF   64,W
0247:  MOVWF  68
0248:  MOVF   56,W
0249:  MOVWF  6B
024A:  MOVF   55,W
024B:  MOVWF  6A
024C:  CALL   22C
024D:  MOVF   79,W
024E:  MOVWF  67
024F:  MOVF   78,W
0250:  MOVWF  66
0251:  MOVF   79,W
0252:  MOVWF  69
0253:  MOVF   78,W
0254:  MOVWF  68
0255:  CLRF   6B
0256:  MOVLW  0A
0257:  MOVWF  6A
0258:  CALL   22C
0259:  MOVF   79,W
025A:  MOVWF  38
025B:  MOVF   78,W
025C:  MOVWF  37
.................... 	 
.................... /*	if(position == 0) 
.................... 	{ 
.................... 	output_high(curtain_close_pin); 
.................... 	delay_ms(100); 
.................... 	output_low(curtain_close_pin); 
.................... 	} 
.................... 	else if(position==100) 
.................... 	{ 
.................... 	output_high(curtain_open_pin); 
.................... 	delay_ms(100); 
.................... 	output_low(curtain_open_pin); 
.................... 	} 
.................... 	else if(position>0 && position <100) 
.................... 	{ 
.................... 	// code to go to position 0 
.................... 	output_high(curtain_close_pin); 
.................... 	delay_ms(100); 
.................... 	output_low(curtain_close_pin); 
.................... 	delay_ms(3000); 
....................  
.................... 	// code to go to desired position 
.................... 	output_high(curtain_open_pin); 
.................... 	delay_ms(100); 
.................... 	output_low(curtain_open_pin); 
.................... 	delay_ms(curtain_time); 
.................... 	output_high(curtain_open_pin); 
.................... 	delay_ms(100); 
.................... 	output_low(curtain_open_pin); 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 	output_high(curtain_close_pin); 
.................... 	delay_ms(100); 
.................... 	output_low(curtain_close_pin); 
.................... 	} 
.................... 	*/ 
.................... 	return; 
025D:  RETURN
....................  
....................  
.................... } 
....................  
.................... void init_from_eeprom(void) 
.................... { 
.................... GroupSelectReg = MAKE16(read_EEPROM (Group_815Store ),read_EEPROM (Group_07Store));	 
*
0129:  MOVLW  08
012A:  BSF    03.5
012B:  MOVWF  1B
012C:  BCF    1C.7
012D:  BSF    1C.0
012E:  MOVF   1A,W
012F:  BCF    03.5
0130:  MOVWF  64
0131:  MOVLW  07
0132:  BSF    03.5
0133:  MOVWF  1B
0134:  BCF    1C.7
0135:  BSF    1C.0
0136:  MOVF   1A,W
0137:  BCF    03.5
0138:  MOVWF  65
0139:  MOVF   64,W
013A:  MOVWF  4E
013B:  MOVF   65,W
013C:  MOVWF  4D
.................... delay_us(10); 
013D:  MOVLW  02
013E:  MOVWF  77
013F:  DECFSZ 77,F
0140:  GOTO   13F
0141:  GOTO   142
0142:  NOP
.................... PowerOnLevel 		= read_EEPROM (PowerOnLevelStore); 
0143:  BSF    03.5
0144:  CLRF   1B
0145:  BCF    1C.7
0146:  BSF    1C.0
0147:  MOVF   1A,W
0148:  BCF    03.5
0149:  MOVWF  5F
.................... delay_us(10);  
014A:  MOVLW  02
014B:  MOVWF  77
014C:  DECFSZ 77,F
014D:  GOTO   14C
014E:  GOTO   14F
014F:  NOP
.................... SystemFailureLevel	= read_EEPROM ( SystemFailureLevelStore );  
0150:  MOVLW  01
0151:  BSF    03.5
0152:  MOVWF  1B
0153:  BCF    1C.7
0154:  BSF    1C.0
0155:  MOVF   1A,W
0156:  BCF    03.5
0157:  MOVWF  54
.................... delay_us(10);	     
0158:  MOVLW  02
0159:  MOVWF  77
015A:  DECFSZ 77,F
015B:  GOTO   15A
015C:  GOTO   15D
015D:  NOP
.................... MinimumLevel		= read_EEPROM ( MinimumLevelStore );    
015E:  MOVLW  02
015F:  BSF    03.5
0160:  MOVWF  1B
0161:  BCF    1C.7
0162:  BSF    1C.0
0163:  MOVF   1A,W
0164:  BCF    03.5
0165:  MOVWF  52
.................... delay_us(10);       	 
0166:  MOVLW  02
0167:  MOVWF  77
0168:  DECFSZ 77,F
0169:  GOTO   168
016A:  GOTO   16B
016B:  NOP
.................... MaximumLevel 		= read_EEPROM ( MaximumLevelStore);  
016C:  MOVLW  03
016D:  BSF    03.5
016E:  MOVWF  1B
016F:  BCF    1C.7
0170:  BSF    1C.0
0171:  MOVF   1A,W
0172:  BCF    03.5
0173:  MOVWF  53
.................... delay_us(10);  		 
0174:  MOVLW  02
0175:  MOVWF  77
0176:  DECFSZ 77,F
0177:  GOTO   176
0178:  GOTO   179
0179:  NOP
.................... FadeRate 			= read_EEPROM ( FadeRateStore); 
017A:  MOVLW  04
017B:  BSF    03.5
017C:  MOVWF  1B
017D:  BCF    1C.7
017E:  BSF    1C.0
017F:  MOVF   1A,W
0180:  BCF    03.5
0181:  CLRF   56
0182:  MOVWF  55
.................... delay_us(10); 
0183:  MOVLW  02
0184:  MOVWF  77
0185:  DECFSZ 77,F
0186:  GOTO   185
0187:  GOTO   188
0188:  NOP
.................... FadeTime 			= read_EEPROM ( FadeTimeStore ); 
0189:  MOVLW  05
018A:  BSF    03.5
018B:  MOVWF  1B
018C:  BCF    1C.7
018D:  BSF    1C.0
018E:  MOVF   1A,W
018F:  BCF    03.5
0190:  MOVWF  57
.................... delay_us(10); 
0191:  MOVLW  02
0192:  MOVWF  77
0193:  DECFSZ 77,F
0194:  GOTO   193
0195:  GOTO   196
0196:  NOP
.................... lampid 				= read_EEPROM ( ShortAddressStore ); 
0197:  MOVLW  06
0198:  BSF    03.5
0199:  MOVWF  1B
019A:  BCF    1C.7
019B:  BSF    1C.0
019C:  MOVF   1A,W
019D:  BCF    03.5
019E:  MOVWF  63
.................... delay_us(10); 
019F:  MOVLW  02
01A0:  MOVWF  77
01A1:  DECFSZ 77,F
01A2:  GOTO   1A1
01A3:  GOTO   1A4
01A4:  NOP
....................  
.................... RandomAddress0 		= read_EEPROM ( RandomAddressStore0);  
01A5:  MOVLW  19
01A6:  BSF    03.5
01A7:  MOVWF  1B
01A8:  BCF    1C.7
01A9:  BSF    1C.0
01AA:  MOVF   1A,W
01AB:  BCF    03.5
01AC:  MOVWF  58
.................... delay_us(10);   
01AD:  MOVLW  02
01AE:  MOVWF  77
01AF:  DECFSZ 77,F
01B0:  GOTO   1AF
01B1:  GOTO   1B2
01B2:  NOP
.................... RandomAddress1 		= read_EEPROM ( RandomAddressStore1);  
01B3:  MOVLW  1A
01B4:  BSF    03.5
01B5:  MOVWF  1B
01B6:  BCF    1C.7
01B7:  BSF    1C.0
01B8:  MOVF   1A,W
01B9:  BCF    03.5
01BA:  MOVWF  59
.................... delay_us(10); 
01BB:  MOVLW  02
01BC:  MOVWF  77
01BD:  DECFSZ 77,F
01BE:  GOTO   1BD
01BF:  GOTO   1C0
01C0:  NOP
.................... RandomAddress2 		= read_EEPROM ( RandomAddressStore2); 
01C1:  MOVLW  1B
01C2:  BSF    03.5
01C3:  MOVWF  1B
01C4:  BCF    1C.7
01C5:  BSF    1C.0
01C6:  MOVF   1A,W
01C7:  BCF    03.5
01C8:  MOVWF  5A
.................... delay_us(10); 
01C9:  MOVLW  02
01CA:  MOVWF  77
01CB:  DECFSZ 77,F
01CC:  GOTO   1CB
01CD:  GOTO   1CE
01CE:  NOP
....................   		 
.................... FastFadeTime 		= read_EEPROM ( FastFadeTimeStore);  
01CF:  MOVLW  1C
01D0:  BSF    03.5
01D1:  MOVWF  1B
01D2:  BCF    1C.7
01D3:  BSF    1C.0
01D4:  MOVF   1A,W
01D5:  BCF    03.5
01D6:  MOVWF  5B
.................... delay_us(10); 		 
01D7:  MOVLW  02
01D8:  MOVWF  77
01D9:  DECFSZ 77,F
01DA:  GOTO   1D9
01DB:  GOTO   1DC
01DC:  NOP
.................... FailureStatus 		= read_EEPROM ( FailureStatusStore);  
01DD:  MOVLW  1D
01DE:  BSF    03.5
01DF:  MOVWF  1B
01E0:  BCF    1C.7
01E1:  BSF    1C.0
01E2:  MOVF   1A,W
01E3:  BCF    03.5
01E4:  MOVWF  5C
.................... delay_us(10);  
01E5:  MOVLW  02
01E6:  MOVWF  77
01E7:  DECFSZ 77,F
01E8:  GOTO   1E7
01E9:  GOTO   1EA
01EA:  NOP
.................... OperatingMode 		= read_EEPROM ( OperatingModeStore);  
01EB:  MOVLW  1E
01EC:  BSF    03.5
01ED:  MOVWF  1B
01EE:  BCF    1C.7
01EF:  BSF    1C.0
01F0:  MOVF   1A,W
01F1:  BCF    03.5
01F2:  MOVWF  5D
.................... delay_us(10); 
01F3:  MOVLW  02
01F4:  MOVWF  77
01F5:  DECFSZ 77,F
01F6:  GOTO   1F5
01F7:  GOTO   1F8
01F8:  NOP
.................... DimmingCurv 		= read_EEPROM ( DimmingCurveStore); 
01F9:  MOVLW  1F
01FA:  BSF    03.5
01FB:  MOVWF  1B
01FC:  BCF    1C.7
01FD:  BSF    1C.0
01FE:  MOVF   1A,W
01FF:  BCF    03.5
0200:  MOVWF  5E
.................... delay_us(10);  
0201:  MOVLW  02
0202:  MOVWF  77
0203:  DECFSZ 77,F
0204:  GOTO   203
0205:  GOTO   206
0206:  NOP
.................... zoneid=read_EEPROM(zoneidstore); 
0207:  MOVLW  20
0208:  BSF    03.5
0209:  MOVWF  1B
020A:  BCF    1C.7
020B:  BSF    1C.0
020C:  MOVF   1A,W
020D:  BCF    03.5
020E:  MOVWF  45
020F:  RETURN
....................  
.................... } 
....................  
....................  

Configuration Fuses:
   Word  1: 1F74   WDT PUT INTRC_IO MCLR BROWNOUT NOLVP NOCPD PROTECT

ROM data:
002100: 0064 0032 0000 0064 0005 0006 0041 0001 
002108: 0000 0006 0007 0008 

002120: 00FF 
