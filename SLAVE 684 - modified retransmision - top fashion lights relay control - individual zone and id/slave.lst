CCS PCM C Compiler, Version 5.015, 5967               16-Jun-21 19:24

               Filename:   D:\home automation codes\curtain slave\curtain slave\SLAVE 684 - modified retransmision - top fashion lights relay control - individual zone and id\slave.lst

               ROM used:   1770 words (86%)
                           Largest free fragment is 278
               RAM used:   75 (59%) at main() level
                           92 (72%) worst case
               Stack used: 5 locations (3 in main + 2 for interrupts)
               Stack size: 8

*
0000:  MOVLW  06
0001:  MOVWF  0A
0002:  GOTO   649
0003:  NOP
0004:  BTFSC  03.5
0005:  GOTO   00A
0006:  MOVWF  24
0007:  SWAPF  03,W
0008:  MOVWF  25
0009:  GOTO   00F
000A:  BCF    03.5
000B:  MOVWF  24
000C:  SWAPF  03,W
000D:  MOVWF  25
000E:  BSF    25.1
000F:  MOVF   0A,W
0010:  MOVWF  2B
0011:  CLRF   0A
0012:  BCF    03.7
0013:  SWAPF  24,F
0014:  MOVF   04,W
0015:  MOVWF  26
0016:  MOVF   20,W
0017:  MOVWF  27
0018:  MOVF   21,W
0019:  MOVWF  28
001A:  MOVF   22,W
001B:  MOVWF  29
001C:  MOVF   23,W
001D:  MOVWF  2A
001E:  BCF    03.5
001F:  BTFSS  0B.5
0020:  GOTO   023
0021:  BTFSC  0B.2
0022:  GOTO   124
0023:  BTFSS  0B.4
0024:  GOTO   027
0025:  BTFSC  0B.1
0026:  GOTO   040
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.0
002A:  GOTO   02D
002B:  BTFSC  0C.0
002C:  GOTO   074
002D:  MOVF   26,W
002E:  MOVWF  04
002F:  MOVF   27,W
0030:  MOVWF  20
0031:  MOVF   28,W
0032:  MOVWF  21
0033:  MOVF   29,W
0034:  MOVWF  22
0035:  MOVF   2A,W
0036:  MOVWF  23
0037:  MOVF   2B,W
0038:  MOVWF  0A
0039:  SWAPF  25,W
003A:  MOVWF  03
003B:  BCF    03.5
003C:  SWAPF  24,W
003D:  BTFSC  25.1
003E:  BSF    03.5
003F:  RETFIE
.................... #include <slave.h> 
.................... #include <16F684.h> 
.................... //////////// Standard Header file for the PIC16F684 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F684 
....................  
.................... #list 
....................  
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES INTRC_IO                     	//Crystal osc <= 4mhz for PCM/PCH , 3mhz to 10 mhz for PCD 
.................... //#FUSES XT 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES BROWNOUT              	//Reset when brownout detected 
.................... #FUSES NOMCLR                  	//Master Clear pin enabled 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOIESO                	//Internal External Switch Over mode disabled 
.................... #FUSES NOFCMEN               	//Fail-safe clock monitor disabled 
....................  
.................... #use delay(clock=4000000) 
....................  
.................... #include<math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  #include <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
066C:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #use delay(clock=4000000) 
*
029D:  MOVLW  12
029E:  SUBWF  6C,F
029F:  BTFSS  03.0
02A0:  GOTO   2AF
02A1:  MOVLW  6C
02A2:  MOVWF  04
02A3:  MOVLW  FC
02A4:  ANDWF  00,F
02A5:  BCF    03.0
02A6:  RRF    00,F
02A7:  RRF    00,F
02A8:  MOVF   00,W
02A9:  BTFSC  03.2
02AA:  GOTO   2AF
02AB:  GOTO   2AD
02AC:  NOP
02AD:  DECFSZ 00,F
02AE:  GOTO   2AC
*
0634:  MOVLW  69
0635:  MOVWF  04
0636:  MOVF   00,W
0637:  BTFSC  03.2
0638:  GOTO   647
0639:  MOVLW  01
063A:  MOVWF  21
063B:  CLRF   20
063C:  DECFSZ 20,F
063D:  GOTO   63C
063E:  DECFSZ 21,F
063F:  GOTO   63B
0640:  MOVLW  4A
0641:  MOVWF  20
0642:  DECFSZ 20,F
0643:  GOTO   642
0644:  GOTO   645
0645:  DECFSZ 00,F
0646:  GOTO   639
....................  
.................... /////////// Driver details /////////////////// 
.................... /* 
.................... fan driver 
....................  
.................... */ 
.................... ///////////////////////////////////////////////// 
....................  
.................... #define device_type 3 /////////// setting device type  
....................  
.................... #define light1_pin pin_c3 
.................... #define light2_pin pin_c2 
....................  
....................  
.................... #define Fixlampid 5                // LAMP ADDRESS // 
.................... #define Fixlampid2 6 
.................... #define zoneid_init   211 // zone address // 1-6 192//,5-8 193//,9-12 194//,13-16 195// 
.................... #define G1 0b00000001 
.................... #define G2 0b00000000 
.................... #define rx pin_a2 
.................... #define tx pin_a0 
.................... #define self 0x01 
....................  
.................... #define MaxDuty  100 //254 1 led 53,2- 58,3-95 
.................... #define MinDuty  0//10  
....................  
....................  
.................... /////////////////////////////////////////////////////////////// 
....................  
.................... #define PowerOnLevelStore    		0           //[0] 
.................... #define SystemFailureLevelStore  	    1           //[1] 
.................... #define MinimumLevelStore           	2			// [2] 
.................... #define MaximumLevelStore  			3 			// [3] 
.................... #define FadeRateStore      			4  			//[4] 
.................... #define FadeTimeStore       			5			//[5] 
.................... #define ShortAddressStore  			6  			//[6] 
.................... #define Group_07Store    			7			//[7] 
.................... #define Group_815Store  			8			///15 [8] 
.................... #define SceneStore  				9			//15 [9-24]/ 
.................... #define RandomAddressStore0  			25			//[25-27] 
.................... #define RandomAddressStore1  			26			//[25-27] 
.................... #define RandomAddressStore2  			27			//[25-27] 
.................... #define FastFadeTimeStore  			28			//[28] 
.................... #define FailureStatusStore  			29			//[29] 
.................... #define OperatingModeStore  30 //[30] 
.................... #define DimmingCurveStore  31   //[31]      
.................... #define ZoneIDStore 32 
.................... #define PowerOnLevelStore2    		33           //[0] 
.................... #define SceneStore2  				34			//15 [9-24]/ 
....................  
....................  
....................  
.................... ////////////////// Device types //////////////////////// 
.................... /* 
.................... 	lamp =1 
.................... 	fan=2 
.................... 	curtain=3 
.................... 	strip=4 
.................... */ 
.................... //////////////////////////////////////////////////////// 
....................  
.................... #byte dutyreg = 0x15 
....................   
.................... #bit intf = 0x0b.1 
.................... #bit timerOnOff =0x10.0 
....................  
.................... int1 oddevenbit,a,atmp,b,error_flag,over_flowflag; 
.................... unsigned int8 dataCount; 
.................... char data[3],bitcount,tout; 
....................  
....................  
.................... unsigned char light1_duty=0,light2_duty=0; 
.................... unsigned char curtain2_duty=0; 
.................... int16 curtain_time=0;	 
....................  
....................  
.................... char settling_time,i,dly=4,j; 
.................... int1 txmit_error; 
.................... char tx_buffer[3]; 
.................... char r_a,currentSceen; 
.................... char command_st,RetryCount; 
.................... char FadeRateCount=1; 
....................  
.................... char zoneid=zoneid_init; 
....................  
....................  
.................... char stopBitCount,address ,command,databyte; 
.................... int1 dataready,forwrdFrameFlag,backwardFrameFlag ,masterFlag ; 
.................... int16 readDly=300; 
.................... int16 GroupSelectReg; 
.................... char gindex; 
.................... /////// new  ////// 
.................... int txmit_count=0; 
.................... int error_value=0; 
.................... /////////////////// 
....................  
.................... char MinimumLevel; 
.................... char MaximumLevel; 
.................... char SystemFailureLevel; 
.................... int16 FadeRate; 
.................... char FadeTime; 
.................... char RandomAddress0; 
.................... char RandomAddress1; 
.................... char RandomAddress2; 
.................... char FastFadeTime; 
.................... char FailureStatus; 
.................... char OperatingMode; 
.................... char DimmingCurv; 
.................... char PowerOnLevel; 
.................... char PowerOnLevel2; 
.................... char DTR,DwriteLocation,DTR_Ready; 
....................  
.................... char lampid  = Fixlampid; 
....................  
.................... void readData(void); 
.................... void init(void); 
.................... void handle(void ); 
.................... void copyData(void); 
.................... void commands(void); 
.................... void txmit(char priority,char length); 
.................... void txmit1(void); 
.................... void txmit0(void); 
.................... void stopbit(void); 
.................... void lamp_on(void); 
.................... void lamp_off(void); 
.................... void startBit(void); 
.................... void init_from_eeprom(void); 
.................... void goto_position(int16); 
....................  
....................  
....................  
....................  
.................... #rom  0x2100={MaxDuty,50,MinDuty,Maxduty,5,6,Fixlampid,G1,G2,6,7,8} 
....................  
.................... #rom  0x2120={zoneid_init} 
....................  
....................  
.................... #int_EXT 
.................... EXT_isr()  
.................... { 
.................... 		restart_wdt(); 		 
*
0040:  CLRWDT
....................             disable_interrupts(int_ext); 
0041:  BCF    0B.4
....................             disable_interrupts(INT_RTCC); 
0042:  BCF    0B.5
....................             bitcount=0; 
0043:  CLRF   36
....................             setup_timer_1(T1_internal|T1_div_by_1); 
0044:  MOVLW  05
0045:  MOVWF  10
....................             set_timer1(0xffff-840); //858  880///old value 923 
0046:  CLRF   0E
0047:  MOVLW  FC
0048:  MOVWF  0F
0049:  MOVLW  B7
004A:  MOVWF  0E
....................             enable_interrupts(int_timer1); 
004B:  BSF    03.5
004C:  BSF    0C.0
....................             stopBitCount = 0; 
004D:  BCF    03.5
004E:  CLRF   4A
....................             oddevenbit=1; 
004F:  BSF    31.0
....................             data[0]=0; 
0050:  CLRF   33
....................             data[1]=0; 
0051:  CLRF   34
....................             data[2]=0; 
0052:  CLRF   35
....................             tout=0 ; 
0053:  CLRF   37
....................             datacount = 0;    
0054:  CLRF   32
.................... 			settling_time = 0;  
0055:  CLRF   3D
.................... } 
....................  
....................  
....................  
....................  
0056:  BCF    0B.1
0057:  BCF    0A.3
0058:  GOTO   02D
.................... #int_TIMER1 
.................... TIMER1_isr() 
.................... { 
....................  
....................  
.................... readDly=20; 
*
0074:  CLRF   50
0075:  MOVLW  14
0076:  MOVWF  4F
.................... error_flag=0; 
0077:  BCF    31.4
.................... 	if(oddevenbit==1) 
0078:  BTFSS  31.0
0079:  GOTO   0B5
.................... 	{ 
.................... 	//	output_high( ); 
.................... 		a=input(rx);  
007A:  BSF    03.5
007B:  BSF    05.2
007C:  BCF    03.5
007D:  BCF    31.1
007E:  BTFSC  05.2
007F:  BSF    31.1
.................... 		atmp=a ;           
0080:  BCF    31.2
0081:  BTFSC  31.1
0082:  BSF    31.2
.................... 		oddevenbit=0 ; 
0083:  BCF    31.0
.................... 		 
.................... 				if(atmp) 
0084:  BTFSS  31.2
0085:  GOTO   09C
.................... 				{ 
.................... 					while(atmp) 
0086:  BTFSS  31.2
0087:  GOTO   09B
.................... 						{ 
.................... 							atmp=input(rx); 
0088:  BSF    03.5
0089:  BSF    05.2
008A:  BCF    03.5
008B:  BCF    31.2
008C:  BTFSC  05.2
008D:  BSF    31.2
.................... 							if(readDly>0) 
008E:  MOVF   4F,F
008F:  BTFSS  03.2
0090:  GOTO   094
0091:  MOVF   50,F
0092:  BTFSC  03.2
0093:  GOTO   099
.................... 								readDly--; 
0094:  MOVF   4F,W
0095:  BTFSC  03.2
0096:  DECF   50,F
0097:  DECF   4F,F
0098:  GOTO   09A
.................... 							else 
.................... 								atmp=0; 
0099:  BCF    31.2
009A:  GOTO   086
.................... 								 
.................... 						} 
.................... 				}          
009B:  GOTO   0AD
.................... 				else 
.................... 				{ 
.................... 					while(!atmp) 
009C:  BTFSC  31.2
009D:  GOTO   0AD
.................... 						{ 
.................... 							atmp=input(rx); 
009E:  BSF    03.5
009F:  BSF    05.2
00A0:  BCF    03.5
00A1:  BCF    31.2
00A2:  BTFSC  05.2
00A3:  BSF    31.2
.................... 							readDly--; 
00A4:  MOVF   4F,W
00A5:  BTFSC  03.2
00A6:  DECF   50,F
00A7:  DECFSZ 4F,F
.................... 								if(readdly==0) 
00A8:  GOTO   0AC
00A9:  MOVF   50,F
00AA:  BTFSC  03.2
.................... 									{ 
.................... 									atmp=1; 
00AB:  BSF    31.2
.................... 									}	 
00AC:  GOTO   09C
.................... 						} 
.................... 				} 
....................  
.................... 			setup_timer_1(T1_internal|T1_div_by_1);//settimer1with1us least count 
00AD:  MOVLW  05
00AE:  MOVWF  10
.................... 			set_timer1(0xffff-150);  //374  //  355             350////old value 150 
00AF:  CLRF   0E
00B0:  MOVLW  FF
00B1:  MOVWF  0F
00B2:  MOVLW  69
00B3:  MOVWF  0E
.................... 	} 
00B4:  GOTO   11F
.................... 	else 
.................... 	{  
.................... 	//	output_low(pin_c3); 
.................... 		b=input(rx) ; // store data line status in the second half 
00B5:  BSF    03.5
00B6:  BSF    05.2
00B7:  BCF    03.5
00B8:  BCF    31.3
00B9:  BTFSC  05.2
00BA:  BSF    31.3
.................... 		oddevenbit=1; 
00BB:  BSF    31.0
.................... 		setup_timer_1(T1_internal|T1_div_by_1); 
00BC:  MOVLW  05
00BD:  MOVWF  10
.................... 		set_timer1(0xffff-350);  // delay  till the next call st to 73 us/////old value 350 
00BE:  CLRF   0E
00BF:  MOVLW  FE
00C0:  MOVWF  0F
00C1:  MOVLW  A1
00C2:  MOVWF  0E
.................... 		readData();  // function  get the dat from the conditions of a and b 
.................... 					 
.................... 	} 
.................... return(0); 
*
011F:  MOVLW  00
0120:  MOVWF  21
....................  
....................  
....................  
....................  
....................  
.................... } 
....................  
0121:  BCF    0C.0
0122:  BCF    0A.3
0123:  GOTO   02D
.................... #int_RTCC 
.................... RTCC_isr() 
.................... {	 
....................  
.................... 	restart_wdt();  
0124:  CLRWDT
.................... 	dly--; 
0125:  DECFSZ 3F,F
....................   	if (dly == 0) 
0126:  GOTO   12D
....................   	{	 
....................       dly = 4; 
0127:  MOVLW  04
0128:  MOVWF  3F
....................       if(settling_time < 25) 
0129:  MOVF   3D,W
012A:  SUBLW  18
012B:  BTFSC  03.0
....................       { 
....................           settling_time++; 
012C:  INCF   3D,F
....................       }               
....................    }    
....................  
012D:  BCF    0B.2
012E:  BCF    0A.3
012F:  GOTO   02D
.................... } 
....................  
....................  
.................... void main(void) 
*
0649:  MOVF   03,W
064A:  ANDLW  1F
064B:  MOVWF  03
064C:  MOVLW  61
064D:  BSF    03.5
064E:  MOVWF  0F
064F:  MOVF   0F,W
0650:  BCF    03.5
0651:  CLRF   38
0652:  CLRF   39
0653:  CLRF   3A
0654:  CLRF   3C
0655:  CLRF   3B
0656:  MOVLW  04
0657:  MOVWF  3F
0658:  MOVLW  01
0659:  MOVWF  48
065A:  MOVLW  D3
065B:  MOVWF  49
065C:  MOVLW  01
065D:  MOVWF  50
065E:  MOVLW  2C
065F:  MOVWF  4F
0660:  CLRF   54
0661:  CLRF   55
0662:  MOVLW  05
0663:  MOVWF  68
0664:  BCF    1F.6
0665:  MOVLW  00
0666:  BSF    03.5
0667:  MOVWF  11
0668:  BCF    03.5
0669:  CLRF   1A
066A:  MOVLW  07
066B:  MOVWF  19
....................  
.................... { 
.................... 	init_from_eeprom(); 
*
066D:  CALL   130
.................... 	init();		 
066E:  GOTO   225
.................... 	GroupSelectReg = MAKE16(read_EEPROM (Group_815Store ),read_EEPROM (Group_07Store));	 
066F:  MOVLW  08
0670:  BSF    03.5
0671:  MOVWF  1B
0672:  BCF    1C.7
0673:  BSF    1C.0
0674:  MOVF   1A,W
0675:  BCF    03.5
0676:  MOVWF  69
0677:  MOVLW  07
0678:  BSF    03.5
0679:  MOVWF  1B
067A:  BCF    1C.7
067B:  BSF    1C.0
067C:  MOVF   1A,W
067D:  BCF    03.5
067E:  MOVWF  6A
067F:  MOVF   69,W
0680:  MOVWF  52
0681:  MOVF   6A,W
0682:  MOVWF  51
....................  
.................... PowerOnLevel = read_EEPROM (PowerOnLevelStore); 
0683:  BSF    03.5
0684:  CLRF   1B
0685:  BCF    1C.7
0686:  BSF    1C.0
0687:  MOVF   1A,W
0688:  BCF    03.5
0689:  MOVWF  63
.................... PowerOnLevel2 = read_EEPROM (PowerOnLevelStore2); 
068A:  MOVLW  21
068B:  BSF    03.5
068C:  MOVWF  1B
068D:  BCF    1C.7
068E:  BSF    1C.0
068F:  MOVF   1A,W
0690:  BCF    03.5
0691:  MOVWF  64
....................  
.................... if(PowerOnLevel==100) 
0692:  MOVF   63,W
0693:  SUBLW  64
0694:  BTFSS  03.2
0695:  GOTO   69D
.................... { 
.................... 	output_low(light1_pin); 
0696:  BSF    03.5
0697:  BCF    07.3
0698:  BCF    03.5
0699:  BCF    07.3
.................... 	light1_duty=100; 
069A:  MOVLW  64
069B:  MOVWF  38
.................... } 
069C:  GOTO   6A2
.................... else 
.................... { 
.................... 	output_high(light1_pin); 
069D:  BSF    03.5
069E:  BCF    07.3
069F:  BCF    03.5
06A0:  BSF    07.3
.................... 	light1_duty=0; 
06A1:  CLRF   38
.................... } 
....................  
.................... if(PowerOnLevel2==100) 
06A2:  MOVF   64,W
06A3:  SUBLW  64
06A4:  BTFSS  03.2
06A5:  GOTO   6AD
.................... { 
.................... 	output_low(light2_pin); 
06A6:  BSF    03.5
06A7:  BCF    07.2
06A8:  BCF    03.5
06A9:  BCF    07.2
.................... 	light2_duty=100; 
06AA:  MOVLW  64
06AB:  MOVWF  39
.................... } 
06AC:  GOTO   6B2
.................... else 
.................... { 
.................... 	output_high(light2_pin); 
06AD:  BSF    03.5
06AE:  BCF    07.2
06AF:  BCF    03.5
06B0:  BSF    07.2
.................... 	light2_duty=0; 
06B1:  CLRF   39
.................... } 
....................  
....................  
.................... faderate=3; 
06B2:  CLRF   5A
06B3:  MOVLW  03
06B4:  MOVWF  59
.................... start: 
.................... //output_toggle(pin_C3); 
.................... 	restart_wdt(); 	 
06B5:  CLRWDT
.................... 	if (dataReady ==1) 
06B6:  BTFSS  31.7
06B7:  GOTO   6E8
.................... 	{ 
.................... 		if(address == 0xff) 
06B8:  INCFSZ 4B,W
06B9:  GOTO   6BC
.................... 		{ 
.................... 			handle();  
06BA:  CALL   322
.................... 		}		 
06BB:  GOTO   6E7
.................... 		else if(address==lampid || address==Fixlampid2)		{ 
06BC:  MOVF   68,W
06BD:  SUBWF  4B,W
06BE:  BTFSC  03.2
06BF:  GOTO   6C4
06C0:  MOVF   4B,W
06C1:  SUBLW  06
06C2:  BTFSS  03.2
06C3:  GOTO   6C6
.................... 			 
.................... 			handle();  
06C4:  CALL   322
.................... 		}		 
06C5:  GOTO   6E7
....................     	else if(address == zoneid) 
06C6:  MOVF   49,W
06C7:  SUBWF  4B,W
06C8:  BTFSS  03.2
06C9:  GOTO   6CC
.................... 		{ 
.................... 			handle();	 
06CA:  CALL   322
.................... 		} 
06CB:  GOTO   6E7
.................... 		else if(address>191 && address<209) 
06CC:  MOVF   4B,W
06CD:  SUBLW  BF
06CE:  BTFSC  03.0
06CF:  GOTO   6E7
06D0:  MOVF   4B,W
06D1:  SUBLW  D0
06D2:  BTFSS  03.0
06D3:  GOTO   6E7
.................... 		{	 
.................... 			gindex = address &0x0F; 
06D4:  MOVF   4B,W
06D5:  ANDLW  0F
06D6:  MOVWF  53
.................... 			if ( bit_test (GroupSelectReg, gindex)==1) 
06D7:  MOVF   52,W
06D8:  MOVWF  23
06D9:  MOVF   51,W
06DA:  MOVWF  22
06DB:  MOVF   53,W
06DC:  MOVWF  20
06DD:  BTFSC  03.2
06DE:  GOTO   6E4
06DF:  BCF    03.0
06E0:  RRF    23,F
06E1:  RRF    22,F
06E2:  DECFSZ 20,F
06E3:  GOTO   6DF
06E4:  MOVF   22,W
06E5:  BTFSC  22.0
.................... 			{ 				 
.................... 				handle(); 
06E6:  CALL   322
.................... 			}	 
.................... 		} 
.................... 		dataReady =0; 
06E7:  BCF    31.7
.................... 	} 
.................... /*	if(txmit_error==1&&txmit_count<64) 
.................... 	{ 
.................... 		txmit_count++; 
.................... 		txmit(2,2); 
.................... 	}	 
.................... 	else 
.................... 	{ 
.................... 		txmit_count=0; 
.................... 	} 
.................... */ 
.................... 	goto start; 
06E8:  GOTO   6B5
.................... } 
....................  
06E9:  SLEEP
.................... void init(void) 
....................  
.................... { 
.................... //	setup_timer_2(T2_OFF);		//26.0 us overflow, 26.0 us interrupt 
....................  	setup_ccp1(CCP_OFF); 
*
0225:  MOVLW  F0
0226:  ANDWF  15,F
.................... //	set_pwm1_duty((int16)10);	 
.................... 	setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1); 
0227:  BSF    03.5
0228:  MOVF   01,W
0229:  ANDLW  C7
022A:  IORLW  08
022B:  MOVWF  01
.................... 	//setup_wdt(WDT_2304MS|WDT_DIV_16); 
.................... 	setup_timer_1(T1_internal|T1_div_by_1); 
022C:  MOVLW  05
022D:  BCF    03.5
022E:  MOVWF  10
.................... 	timerOnOff=0; 
022F:  BCF    10.0
.................... 	ext_int_edge( H_TO_L ); 
0230:  BSF    03.5
0231:  BCF    01.6
.................... 	enable_interrupts(INT_EXT); 
0232:  BCF    03.5
0233:  BSF    0B.4
.................... 	enable_interrupts(INT_RTCC); 
0234:  BSF    0B.5
.................... 	disable_interrupts(INT_TIMER2); 
0235:  BSF    03.5
0236:  BCF    0C.1
.................... 	enable_interrupts(global);	 
0237:  MOVLW  C0
0238:  BCF    03.5
0239:  IORWF  0B,F
.................... 	settling_time =23; 
023A:  MOVLW  17
023B:  MOVWF  3D
.................... 	dataReady =0; 
023C:  BCF    31.7
.................... 	//set_pwm1_duty(0); 
.................... 	     
.................... 	faderate=3; 
023D:  CLRF   5A
023E:  MOVLW  03
023F:  MOVWF  59
.................... /* 
.................... 	output_high(light1_pin); 
.................... 	delay_ms(500); 
.................... 	output_low(light1_pin); 
.................... 	delay_ms(2000); 
.................... 	output_high(light2_pin); 
.................... 	delay_ms(500); 
.................... 	output_low(light2_pin); 
.................... 	delay_ms(500); 
.................... */ 
.................... 	 
.................... 	return; 
0240:  GOTO   66F (RETURN)
.................... } 
....................  
....................  
....................  
.................... void handle(void ) 
....................  
.................... { 
.................... 	commands(); 
.................... 	delay_ms(2); 
*
0632:  MOVLW  02
0633:  MOVWF  69
.................... 	RetryCount =0; 
*
0647:  CLRF   47
....................  
.................... return; 
0648:  RETURN
....................  
.................... } 
....................  
....................  
.................... //				trnsmission of  bit 1			// 
.................... /********************************************************************* 
....................  * Function:       void txmit0(void); 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          transmission of  bit 1 to the bus	 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
.................... **********************************************************************/ 
....................  
.................... void txmit1(void) 
....................  
.................... {      
....................   	txmit_error = 0; 
*
0241:  BCF    31.6
.................... 	if (input(rx)==1) 
0242:  BSF    03.5
0243:  BSF    05.2
0244:  BCF    03.5
0245:  BTFSS  05.2
0246:  GOTO   24B
.................... 	{   
.................... 		output_bit(tx,0); 
0247:  BCF    05.0
0248:  BSF    03.5
0249:  BCF    05.0
024A:  BCF    03.5
.................... 	} 
.................... 	delay_us(79); 
024B:  MOVLW  19
024C:  MOVWF  20
024D:  DECFSZ 20,F
024E:  GOTO   24D
024F:  GOTO   250
0250:  NOP
.................... 	if (input(rx)==1) 
0251:  BSF    03.5
0252:  BSF    05.2
0253:  BCF    03.5
0254:  BTFSS  05.2
0255:  GOTO   25C
.................... 	{ 
.................... 		output_bit(tx,1); 
0256:  BSF    05.0
0257:  BSF    03.5
0258:  BCF    05.0
.................... 		txmit_error = 1; 
0259:  BCF    03.5
025A:  BSF    31.6
.................... 		return; 
025B:  GOTO   293
.................... 	}			   
.................... 	delay_us(290);//345 
025C:  MOVLW  60
025D:  MOVWF  20
025E:  DECFSZ 20,F
025F:  GOTO   25E
0260:  NOP
.................... 	if (input(rx)==0) 
0261:  BSF    03.5
0262:  BSF    05.2
0263:  BCF    03.5
0264:  BTFSC  05.2
0265:  GOTO   26B
.................... 	{ 
.................... 		output_bit(tx,1); 
0266:  BSF    05.0
0267:  BSF    03.5
0268:  BCF    05.0
.................... 	} 
0269:  GOTO   272
026A:  BCF    03.5
.................... 	else 
.................... 	{ 
.................... 		output_bit(tx,1); 
026B:  BSF    05.0
026C:  BSF    03.5
026D:  BCF    05.0
.................... 		txmit_error = 1; 
026E:  BCF    03.5
026F:  BSF    31.6
.................... 		return; 
0270:  GOTO   293
0271:  BSF    03.5
.................... 	} 
.................... 	delay_us(79); 
0272:  MOVLW  19
0273:  BCF    03.5
0274:  MOVWF  20
0275:  DECFSZ 20,F
0276:  GOTO   275
0277:  GOTO   278
0278:  NOP
.................... 	if (input(rx)==0) 
0279:  BSF    03.5
027A:  BSF    05.2
027B:  BCF    03.5
027C:  BTFSC  05.2
027D:  GOTO   284
.................... 	{ 
.................... 		output_bit(tx,1); 
027E:  BSF    05.0
027F:  BSF    03.5
0280:  BCF    05.0
.................... 		txmit_error = 1; 
0281:  BCF    03.5
0282:  BSF    31.6
.................... 		return; 
0283:  GOTO   293
.................... 	} 
....................     delay_us(290); 
0284:  MOVLW  60
0285:  MOVWF  20
0286:  DECFSZ 20,F
0287:  GOTO   286
0288:  NOP
.................... 	if (input(rx)==0) 
0289:  BSF    03.5
028A:  BSF    05.2
028B:  BCF    03.5
028C:  BTFSC  05.2
028D:  GOTO   293
.................... 	{ 
.................... 		output_bit(tx,1); 
028E:  BSF    05.0
028F:  BSF    03.5
0290:  BCF    05.0
.................... 		txmit_error = 1; 
0291:  BCF    03.5
0292:  BSF    31.6
.................... 		return; 
.................... 	} 
....................     return; 
0293:  RETURN
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... //         transmission of 0 to the bus      // 
.................... /********************************************************************* 
....................  * Function:       void txmit0(void); 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          transmission of  0 bit to the bus	 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
.................... **********************************************************************/ 
....................  
.................... void txmit0(void) 
....................  
.................... { 
.................... 	txmit_error = 0;	 
*
02CF:  BCF    31.6
.................... 	output_bit(tx,1); 
02D0:  BSF    05.0
02D1:  BSF    03.5
02D2:  BCF    05.0
.................... 	delay_us(79); 
02D3:  MOVLW  19
02D4:  BCF    03.5
02D5:  MOVWF  20
02D6:  DECFSZ 20,F
02D7:  GOTO   2D6
02D8:  GOTO   2D9
02D9:  NOP
.................... 	if (input(rx)!=1) 
02DA:  BSF    03.5
02DB:  BSF    05.2
02DC:  BCF    03.5
02DD:  BTFSC  05.2
02DE:  GOTO   2E1
.................... 	{		 
.................... 		txmit_error = 1; 
02DF:  BSF    31.6
.................... 		return; 
02E0:  GOTO   310
.................... 	}    
.................... 	delay_us(290); 
02E1:  MOVLW  60
02E2:  MOVWF  20
02E3:  DECFSZ 20,F
02E4:  GOTO   2E3
02E5:  NOP
.................... 	if (input(rx)==1) 
02E6:  BSF    03.5
02E7:  BSF    05.2
02E8:  BCF    03.5
02E9:  BTFSS  05.2
02EA:  GOTO   2F0
.................... 	{ 
.................... 		output_bit(tx,0); 
02EB:  BCF    05.0
02EC:  BSF    03.5
02ED:  BCF    05.0
.................... 	} 
02EE:  GOTO   2F7
02EF:  BCF    03.5
....................     else 
.................... 	{ 
.................... 		output_bit(tx,1); 
02F0:  BSF    05.0
02F1:  BSF    03.5
02F2:  BCF    05.0
.................... 		txmit_error = 1; 
02F3:  BCF    03.5
02F4:  BSF    31.6
.................... 		return; 
02F5:  GOTO   310
02F6:  BSF    03.5
.................... 	} 
....................     delay_us(79); 
02F7:  MOVLW  19
02F8:  BCF    03.5
02F9:  MOVWF  20
02FA:  DECFSZ 20,F
02FB:  GOTO   2FA
02FC:  GOTO   2FD
02FD:  NOP
....................     if (input(rx)==1) 
02FE:  BSF    03.5
02FF:  BSF    05.2
0300:  BCF    03.5
0301:  BTFSS  05.2
0302:  GOTO   305
.................... 	{		 
.................... 		txmit_error = 1; 
0303:  BSF    31.6
.................... 		return; 
0304:  GOTO   310
.................... 	} 
....................     delay_us(290); 
0305:  MOVLW  60
0306:  MOVWF  20
0307:  DECFSZ 20,F
0308:  GOTO   307
0309:  NOP
.................... 	if (input(rx)==1) 
030A:  BSF    03.5
030B:  BSF    05.2
030C:  BCF    03.5
030D:  BTFSS  05.2
030E:  GOTO   310
.................... 	{		 
.................... 		txmit_error = 1; 
030F:  BSF    31.6
.................... 		return; 
.................... 	} 
....................     return; 
.................... } 
.................... //----------------------------------------------------------------------------- 
....................                    // txmit2 bit 
.................... //----------------------------------------------------------------------------- 
....................  
.................... void txmit(char priority,char length) 
.................... {  
....................      j= 8*length; 
*
02B2:  RLF    6A,W
02B3:  MOVWF  40
02B4:  RLF    40,F
02B5:  RLF    40,F
02B6:  MOVLW  F8
02B7:  ANDWF  40,F
.................... 	 while (settling_time < 12+priority);      // priority 
02B8:  MOVLW  0C
02B9:  ADDWF  69,W
02BA:  SUBWF  3D,W
02BB:  BTFSS  03.0
02BC:  GOTO   2B8
....................      disable_interrupts(global); 
02BD:  BCF    0B.6
02BE:  BCF    0B.7
02BF:  BTFSC  0B.7
02C0:  GOTO   2BE
....................      txmit1();        // start bit   
02C1:  CALL   241
....................      for(i=0;i<j;i++) 
02C2:  CLRF   3E
02C3:  MOVF   40,W
02C4:  SUBWF  3E,W
02C5:  BTFSC  03.0
02C6:  GOTO   314
....................          { 
....................             if (shift_left(tx_buffer,3,1)==1) 
02C7:  BSF    03.0
02C8:  RLF    41,F
02C9:  RLF    42,F
02CA:  RLF    43,F
02CB:  BTFSS  03.0
02CC:  GOTO   2CF
....................             { 
....................                  txmit1(); 
02CD:  CALL   241
....................             } 
02CE:  GOTO   310
....................             else 
....................             { 
....................                   txmit0(); 
....................             } 
....................             if (txmit_error ==1) 
*
0310:  BTFSC  31.6
....................             { 
....................                goto rr; 
0311:  GOTO   318
....................             }		 
0312:  INCF   3E,F
0313:  GOTO   2C3
....................          }         
....................      stopbit();     
0314:  CALL   294
....................      stopbit();  
0315:  CALL   294
.................... 	stopbit(); stopbit(); 
0316:  CALL   294
0317:  CALL   294
.................... rr:  output_bit(tx,1); 
0318:  BSF    05.0
0319:  BSF    03.5
031A:  BCF    05.0
.................... 	 settling_time = 0; 
031B:  BCF    03.5
031C:  CLRF   3D
....................      intf =0; 
031D:  BCF    0B.1
....................      enable_interrupts(global);	 
031E:  MOVLW  C0
031F:  IORWF  0B,F
.................... 	 enable_interrupts(INT_RTCC); 
0320:  BSF    0B.5
....................      return; 
0321:  RETURN
.................... } 
....................  
.................... //-------------------------------------------------------------------------- 
....................           // stop bit function // 
.................... //-------------------------------------------------------------------------- 
.................... void  stopbit(void) 
.................... { 
....................       output_bit(tx,1); 
*
0294:  BSF    05.0
0295:  BSF    03.5
0296:  BCF    05.0
.................... 	  restart_wdt();  
0297:  CLRWDT
....................       delay_us(830); 
0298:  MOVLW  05
0299:  BCF    03.5
029A:  MOVWF  6B
029B:  MOVLW  A3
029C:  MOVWF  6C
*
02AF:  DECFSZ 6B,F
02B0:  GOTO   29B
....................       return; 
02B1:  RETURN
.................... } 
....................  
.................... //-------------------------------------------------------------------------- 
....................  
....................  
.................... void readData(void) 
.................... { 
.................... 	restart_wdt();  
*
00C3:  CLRWDT
....................       error_flag=0; 
00C4:  BCF    31.4
....................       datacount++; 
00C5:  INCF   32,F
....................       forwrdFrameFlag = 0; 
00C6:  BCF    4E.0
.................... 	  backwardFrameFlag =0; 
00C7:  BCF    4E.1
....................       if(datacount< 27) 
00C8:  MOVF   32,W
00C9:  SUBLW  1A
00CA:  BTFSS  03.0
00CB:  GOTO   11A
....................       { 
....................          if((a==0 )&& (b==1)) 
00CC:  BTFSC  31.1
00CD:  GOTO   0D5
00CE:  BTFSS  31.3
00CF:  GOTO   0D5
....................          { 
....................             shift_left(data,3,1);  // a one  detewcted on bus  
00D0:  BSF    03.0
00D1:  RLF    33,F
00D2:  RLF    34,F
00D3:  RLF    35,F
....................          } 
00D4:  GOTO   119
....................          else if((a==1)&&(b==0)) 
00D5:  BTFSS  31.1
00D6:  GOTO   0DE
00D7:  BTFSC  31.3
00D8:  GOTO   0DE
....................          { 
....................             shift_left(data,3,0);  // a zero is  deted on the bus  
00D9:  BCF    03.0
00DA:  RLF    33,F
00DB:  RLF    34,F
00DC:  RLF    35,F
....................          } 
00DD:  GOTO   119
....................          else if ( a==1 && b==1) 
00DE:  BTFSS  31.1
00DF:  GOTO   114
00E0:  BTFSS  31.3
00E1:  GOTO   114
....................          { 
....................             switch (datacount) 
00E2:  MOVF   32,W
00E3:  XORLW  11
00E4:  BTFSC  03.2
00E5:  GOTO   0F0
00E6:  XORLW  03
00E7:  BTFSC  03.2
00E8:  GOTO   0F2
00E9:  XORLW  0B
00EA:  BTFSC  03.2
00EB:  GOTO   100
00EC:  XORLW  03
00ED:  BTFSC  03.2
00EE:  GOTO   102
00EF:  GOTO   10F
....................             { 
....................                case 17: 
....................                { 
....................                      stopBitCount ++; 
00F0:  INCF   4A,F
....................                      break; 
00F1:  GOTO   113
....................                } 
....................                case 18: 
....................                { 
....................                   stopBitCount ++; 
00F2:  INCF   4A,F
....................                   if(stopBitCount == 2) 
00F3:  MOVF   4A,W
00F4:  SUBLW  02
00F5:  BTFSS  03.2
00F6:  GOTO   0FE
....................                   { 
....................                         r_a=1;  
00F7:  MOVLW  01
00F8:  MOVWF  44
....................                         copyData(); 
00F9:  CALL   059
....................                         forwrdFrameFlag = 1; 
00FA:  BSF    4E.0
....................                         masterflag = 0; 
00FB:  BCF    4E.2
....................                         backwardFrameFlag =0; 
00FC:  BCF    4E.1
....................  
....................                   } 
00FD:  GOTO   0FF
....................                   else 
....................                   { 
.................... 						error_flag =1; 
00FE:  BSF    31.4
....................                   } 
....................                   break; 
00FF:  GOTO   113
....................                } 
....................               	case 25: 
.................... 				{ 
.................... 					stopBitCount ++; 
0100:  INCF   4A,F
.................... 					break; 
0101:  GOTO   113
.................... 				} 
....................               	case 26:  
.................... 				{ 
.................... 					stopBitCount ++; 
0102:  INCF   4A,F
.................... 					if(stopBitCount == 2) 
0103:  MOVF   4A,W
0104:  SUBLW  02
0105:  BTFSS  03.2
0106:  GOTO   10D
.................... 					{ 
.................... 						r_a=0;  
0107:  CLRF   44
.................... 						copyData(); 
0108:  CALL   059
.................... 						forwrdFrameFlag =0; 
0109:  BCF    4E.0
.................... 						masterflag = 1; 
010A:  BSF    4E.2
.................... 						backwardFrameFlag =0; 
010B:  BCF    4E.1
.................... 					} 
010C:  GOTO   10E
.................... 					else 
.................... 					{ 
.................... 						error_flag =1; 
010D:  BSF    31.4
.................... 					} 
.................... 					break; 
010E:  GOTO   113
.................... 				} 
....................                 default: 
....................                 { 
....................                       error_flag=1; 
010F:  BSF    31.4
....................                       timerOnOff=0; 
0110:  BCF    10.0
....................                       enable_interrupts(INT_EXT); 
0111:  BSF    0B.4
....................                       settling_time = 0; 
0112:  CLRF   3D
....................                       break; 
....................                 } 
....................              }    
....................           }  
0113:  GOTO   119
.................... 		else 
.................... 		{ 
.................... 			error_flag=1;     
0114:  BSF    31.4
.................... 			settling_time = 0; 
0115:  CLRF   3D
.................... 			timerOnOff=0;        
0116:  BCF    10.0
.................... 			enable_interrupts(INT_EXT);        
0117:  BSF    0B.4
.................... 			enable_interrupts(INT_RTCC);          
0118:  BSF    0B.5
.................... 		} 
....................       } 
0119:  GOTO   11F
.................... 	else  // the  data count grater than 27  
.................... 	{ 
.................... 		over_flowflag =1 ; 
011A:  BSF    31.5
.................... 		settling_time = 0; 
011B:  CLRF   3D
.................... 		timerOnOff=0;        
011C:  BCF    10.0
.................... 		enable_interrupts(INT_EXT);        
011D:  BSF    0B.4
.................... 		enable_interrupts(INT_RTCC);          
011E:  BSF    0B.5
.................... 	} 
....................     return; 
.................... } 
....................  
....................  
....................  
....................  
.................... void copyData(void) 
.................... {  
.................... 	restart_wdt();  
*
0059:  CLRWDT
.................... 	dataReady =1;     
005A:  BSF    31.7
.................... 	if( r_a==1) 
005B:  DECFSZ 44,W
005C:  GOTO   062
.................... 	{ 
.................... 		address = data[1]; 
005D:  MOVF   34,W
005E:  MOVWF  4B
.................... 		command =data[0];						 
005F:  MOVF   33,W
0060:  MOVWF  4C
.................... 	} 
0061:  GOTO   06B
.................... 	else if( r_a==0) 
0062:  MOVF   44,F
0063:  BTFSS  03.2
0064:  GOTO   06B
.................... 	{	 
.................... 		address = data[2]; 
0065:  MOVF   35,W
0066:  MOVWF  4B
.................... 		command =data[1]; 
0067:  MOVF   34,W
0068:  MOVWF  4C
.................... 		databyte=data[0];  
0069:  MOVF   33,W
006A:  MOVWF  4D
.................... 	}        
....................     timerOnOff=0; 
006B:  BCF    10.0
....................     intf =0; 
006C:  BCF    0B.1
....................     enable_interrupts(INT_EXT); 
006D:  BSF    0B.4
....................     disable_interrupts(int_timer1); 
006E:  BSF    03.5
006F:  BCF    0C.0
....................     enable_interrupts(INT_RTCC); 
0070:  BCF    03.5
0071:  BSF    0B.5
....................     settling_time = 0; 
0072:  CLRF   3D
....................     return; 
0073:  RETURN
.................... } 
....................  
....................  
.................... void commands(void) 
.................... {  
.................... 	command_st =0;	 
*
0322:  CLRF   46
.................... 	switch(command) 
0323:  MOVF   4C,W
0324:  XORLW  D0
0325:  BTFSC  03.2
0326:  GOTO   34C
0327:  XORLW  04
0328:  BTFSC  03.2
0329:  GOTO   36E
032A:  XORLW  1D
032B:  BTFSC  03.2
032C:  GOTO   38D
032D:  XORLW  23
032E:  BTFSC  03.2
032F:  GOTO   3D5
0330:  XORLW  0D
0331:  BTFSC  03.2
0332:  GOTO   430
0333:  XORLW  EE
0334:  BTFSC  03.2
0335:  GOTO   4B8
0336:  XORLW  2B
0337:  BTFSC  03.2
0338:  GOTO   57B
0339:  XORLW  01
033A:  BTFSC  03.2
033B:  GOTO   59F
033C:  XORLW  07
033D:  BTFSC  03.2
033E:  GOTO   5A4
033F:  XORLW  01
0340:  BTFSC  03.2
0341:  GOTO   5CB
0342:  XORLW  03
0343:  BTFSC  03.2
0344:  GOTO   5D4
0345:  XORLW  01
0346:  BTFSC  03.2
0347:  GOTO   5E3
0348:  XORLW  16
0349:  BTFSC  03.2
034A:  GOTO   5F1
034B:  GOTO   5FA
.................... 	{ 
.................... 		case 208: 
.................... 		{ 
.................... 		if(address==lampid) 
034C:  MOVF   68,W
034D:  SUBWF  4B,W
034E:  BTFSS  03.2
034F:  GOTO   357
.................... 		{ 
.................... 			output_low(light1_pin); 
0350:  BSF    03.5
0351:  BCF    07.3
0352:  BCF    03.5
0353:  BCF    07.3
.................... 			light1_duty=100; 
0354:  MOVLW  64
0355:  MOVWF  38
.................... 		} 
0356:  GOTO   36D
.................... 		else if(address==Fixlampid2) 
0357:  MOVF   4B,W
0358:  SUBLW  06
0359:  BTFSS  03.2
035A:  GOTO   362
.................... 		{ 
.................... 			output_low(light2_pin); 
035B:  BSF    03.5
035C:  BCF    07.2
035D:  BCF    03.5
035E:  BCF    07.2
.................... 			light2_duty=100; 
035F:  MOVLW  64
0360:  MOVWF  39
.................... 		}	 
0361:  GOTO   36D
.................... 		else 
.................... 				{ 
.................... 					output_low(light1_pin); 
0362:  BSF    03.5
0363:  BCF    07.3
0364:  BCF    03.5
0365:  BCF    07.3
.................... 					output_low(light2_pin); 
0366:  BSF    03.5
0367:  BCF    07.2
0368:  BCF    03.5
0369:  BCF    07.2
.................... 					light1_duty=100; 
036A:  MOVLW  64
036B:  MOVWF  38
.................... 					light2_duty=100; 
036C:  MOVWF  39
.................... 				}	 
.................... 		break; 
036D:  GOTO   5FC
.................... 		} 
.................... 		case 212: 
.................... 		{ 
.................... 			if(address==lampid) 
036E:  MOVF   68,W
036F:  SUBWF  4B,W
0370:  BTFSS  03.2
0371:  GOTO   378
.................... 			{ 
.................... 				output_high(light1_pin); 
0372:  BSF    03.5
0373:  BCF    07.3
0374:  BCF    03.5
0375:  BSF    07.3
.................... 				light1_duty=0; 
0376:  CLRF   38
.................... 			} 
0377:  GOTO   38C
.................... 			else if(address==Fixlampid2) 
0378:  MOVF   4B,W
0379:  SUBLW  06
037A:  BTFSS  03.2
037B:  GOTO   382
.................... 			{ 
.................... 				output_high(light2_pin); 
037C:  BSF    03.5
037D:  BCF    07.2
037E:  BCF    03.5
037F:  BSF    07.2
.................... 				light2_duty=0; 
0380:  CLRF   39
.................... 			} 
0381:  GOTO   38C
.................... 			else 
.................... 			{ 
.................... 				output_high(light1_pin); 
0382:  BSF    03.5
0383:  BCF    07.3
0384:  BCF    03.5
0385:  BSF    07.3
.................... 				output_high(light2_pin); 
0386:  BSF    03.5
0387:  BCF    07.2
0388:  BCF    03.5
0389:  BSF    07.2
.................... 				light1_duty=0; 
038A:  CLRF   38
.................... 				light2_duty=0; 
038B:  CLRF   39
.................... 			} 
.................... 		break; 
038C:  GOTO   5FC
.................... 		} 
.................... 		case 201: 
.................... 		{ 
.................... 			if(databyte==100) 
038D:  MOVF   4D,W
038E:  SUBLW  64
038F:  BTFSS  03.2
0390:  GOTO   3B3
.................... 			{ 
.................... 				if(address==lampid) 
0391:  MOVF   68,W
0392:  SUBWF  4B,W
0393:  BTFSS  03.2
0394:  GOTO   39C
.................... 				{ 
.................... 					output_low(light1_pin); 
0395:  BSF    03.5
0396:  BCF    07.3
0397:  BCF    03.5
0398:  BCF    07.3
.................... 					light1_duty=100; 
0399:  MOVLW  64
039A:  MOVWF  38
.................... 				} 
039B:  GOTO   3B2
.................... 				else if(address==Fixlampid2) 
039C:  MOVF   4B,W
039D:  SUBLW  06
039E:  BTFSS  03.2
039F:  GOTO   3A7
.................... 				{ 
.................... 					output_low(light2_pin); 
03A0:  BSF    03.5
03A1:  BCF    07.2
03A2:  BCF    03.5
03A3:  BCF    07.2
.................... 					light2_duty=100; 
03A4:  MOVLW  64
03A5:  MOVWF  39
.................... 				} 
03A6:  GOTO   3B2
.................... 				else 
.................... 				{ 
.................... 					output_low(light1_pin); 
03A7:  BSF    03.5
03A8:  BCF    07.3
03A9:  BCF    03.5
03AA:  BCF    07.3
.................... 					output_low(light2_pin); 
03AB:  BSF    03.5
03AC:  BCF    07.2
03AD:  BCF    03.5
03AE:  BCF    07.2
.................... 					light1_duty=100; 
03AF:  MOVLW  64
03B0:  MOVWF  38
.................... 					light2_duty=100; 
03B1:  MOVWF  39
.................... 				} 
.................... 			 
.................... 			} 
03B2:  GOTO   3D4
.................... 			else if(databyte==0) 
03B3:  MOVF   4D,F
03B4:  BTFSS  03.2
03B5:  GOTO   3D4
.................... 			{ 
.................... 			if(address==lampid) 
03B6:  MOVF   68,W
03B7:  SUBWF  4B,W
03B8:  BTFSS  03.2
03B9:  GOTO   3C0
.................... 				{ 
.................... 					output_high(light1_pin); 
03BA:  BSF    03.5
03BB:  BCF    07.3
03BC:  BCF    03.5
03BD:  BSF    07.3
.................... 					light1_duty=0; 
03BE:  CLRF   38
.................... 				} 
03BF:  GOTO   3D4
.................... 			 else if(address==Fixlampid2) 
03C0:  MOVF   4B,W
03C1:  SUBLW  06
03C2:  BTFSS  03.2
03C3:  GOTO   3CA
.................... 				{ 
.................... 					output_high(light2_pin); 
03C4:  BSF    03.5
03C5:  BCF    07.2
03C6:  BCF    03.5
03C7:  BSF    07.2
.................... 					light2_duty=0; 
03C8:  CLRF   39
.................... 				} 
03C9:  GOTO   3D4
.................... 			else 
.................... 				{ 
.................... 					output_high(light1_pin); 
03CA:  BSF    03.5
03CB:  BCF    07.3
03CC:  BCF    03.5
03CD:  BSF    07.3
.................... 					output_high(light2_pin); 
03CE:  BSF    03.5
03CF:  BCF    07.2
03D0:  BCF    03.5
03D1:  BSF    07.2
.................... 					light1_duty=0; 
03D2:  CLRF   38
.................... 					light2_duty=0; 
03D3:  CLRF   39
.................... 				} 
.................... 			}	 
.................... 			break;	 
03D4:  GOTO   5FC
.................... 		} 
.................... 	/*	case 216:	//dim 
.................... 		case 241:		//ZONE DIM 
.................... 		{ 
.................... 			if(l_st==1) 
.................... 			{				 
.................... 				if(duty>MinimumLevel) 
.................... 				{							 
.................... 					duty--; 
.................... 					SetDimmLevel(duty);					 
.................... 				} 
.................... 			} 
.................... 			break; 
.................... 		} 
.................... 		case 220:	//bright 
.................... 		case 240:  //zone  bright 
.................... 		{ 
.................... 			if(l_st==1) 
.................... 			{			 
.................... 				if(duty < MaximumLevel) 
.................... 				{									 
.................... 					duty++; 
.................... 					SetDimmLevel(duty);			 
.................... 				} 
.................... 			} 
.................... 			break; 
.................... 		}*/	 
.................... 	 
.................... 		case 234: // scene select  
.................... 		{ 
.................... 			 
.................... 			if(databyte < 17) 
03D5:  MOVF   4D,W
03D6:  SUBLW  10
03D7:  BTFSS  03.0
03D8:  GOTO   42F
.................... 			{				 
.................... 				currentSceen = databyte; 
03D9:  MOVF   4D,W
03DA:  MOVWF  45
.................... 							 
.................... 		        light1_duty = read_EEPROM (currentSceen+SceneStore); 
03DB:  MOVLW  09
03DC:  ADDWF  45,W
03DD:  MOVWF  69
03DE:  MOVF   69,W
03DF:  BSF    03.5
03E0:  MOVWF  1B
03E1:  BCF    1C.7
03E2:  BSF    1C.0
03E3:  MOVF   1A,W
03E4:  BCF    03.5
03E5:  MOVWF  38
.................... 				light2_duty= read_EEPROM (currentSceen+SceneStore2); 
03E6:  MOVLW  22
03E7:  ADDWF  45,W
03E8:  MOVWF  69
03E9:  MOVF   69,W
03EA:  BSF    03.5
03EB:  MOVWF  1B
03EC:  BCF    1C.7
03ED:  BSF    1C.0
03EE:  MOVF   1A,W
03EF:  BCF    03.5
03F0:  MOVWF  39
.................... 				if(address==lampid) 
03F1:  MOVF   68,W
03F2:  SUBWF  4B,W
03F3:  BTFSS  03.2
03F4:  GOTO   403
.................... 				{ 
.................... 					if(light1_duty==100) 
03F5:  MOVF   38,W
03F6:  SUBLW  64
03F7:  BTFSS  03.2
03F8:  GOTO   3FE
.................... 					{ 
.................... 						output_low(light1_pin); 
03F9:  BSF    03.5
03FA:  BCF    07.3
03FB:  BCF    03.5
03FC:  BCF    07.3
.................... 					}	 
03FD:  GOTO   402
.................... 					else  
.................... 					{ 
.................... 						output_high(light1_pin); 
03FE:  BSF    03.5
03FF:  BCF    07.3
0400:  BCF    03.5
0401:  BSF    07.3
.................... 					} 
.................... 				} 
0402:  GOTO   42F
.................... 				else if(address==Fixlampid2) 
0403:  MOVF   4B,W
0404:  SUBLW  06
0405:  BTFSS  03.2
0406:  GOTO   415
.................... 				{ 
.................... 					if(light2_duty==100) 
0407:  MOVF   39,W
0408:  SUBLW  64
0409:  BTFSS  03.2
040A:  GOTO   410
.................... 					{ 
.................... 						output_low(light2_pin); 
040B:  BSF    03.5
040C:  BCF    07.2
040D:  BCF    03.5
040E:  BCF    07.2
.................... 					}	 
040F:  GOTO   414
.................... 					else  
.................... 					{ 
.................... 						output_high(light2_pin); 
0410:  BSF    03.5
0411:  BCF    07.2
0412:  BCF    03.5
0413:  BSF    07.2
.................... 					} 
.................... 				} 
0414:  GOTO   42F
.................... 				else 
.................... 				{ 
.................... 					if(light1_duty==100) 
0415:  MOVF   38,W
0416:  SUBLW  64
0417:  BTFSS  03.2
0418:  GOTO   41E
.................... 					{ 
.................... 						output_low(light1_pin); 
0419:  BSF    03.5
041A:  BCF    07.3
041B:  BCF    03.5
041C:  BCF    07.3
.................... 					}	 
041D:  GOTO   422
.................... 					else  
.................... 					{ 
.................... 						output_high(light1_pin); 
041E:  BSF    03.5
041F:  BCF    07.3
0420:  BCF    03.5
0421:  BSF    07.3
.................... 					} 
.................... 					if(light2_duty==100) 
0422:  MOVF   39,W
0423:  SUBLW  64
0424:  BTFSS  03.2
0425:  GOTO   42B
.................... 					{ 
.................... 						output_low(light2_pin); 
0426:  BSF    03.5
0427:  BCF    07.2
0428:  BCF    03.5
0429:  BCF    07.2
.................... 					}	 
042A:  GOTO   42F
.................... 					else  
.................... 					{ 
.................... 						output_high(light2_pin); 
042B:  BSF    03.5
042C:  BCF    07.2
042D:  BCF    03.5
042E:  BSF    07.2
.................... 					} 
....................  
.................... 				} 
.................... 			     /*	if(light1_duty<=MinimumLevel) 
.................... 					{ 
.................... 					   	light1_duty=0;					 
.................... 					 
.................... 					} 
.................... 					else 
.................... 					{								 
.................... 							 
.................... 					}	*/		 
.................... 			} 
.................... 			 
.................... 			break; 
042F:  GOTO   5FC
.................... 		 } 
.................... 		case 231:  // store sceen  
.................... 		{ 
....................  
.................... 			if(databyte < 17) 
0430:  MOVF   4D,W
0431:  SUBLW  10
0432:  BTFSS  03.0
0433:  GOTO   4B7
.................... 			{				 
.................... 				disable_interrupts (global); 
0434:  BCF    0B.6
0435:  BCF    0B.7
0436:  BTFSC  0B.7
0437:  GOTO   435
.................... 				if(address==lampid) 
0438:  MOVF   68,W
0439:  SUBWF  4B,W
043A:  BTFSS  03.2
043B:  GOTO   459
.................... 				{ 
.................... 				write_eeprom(databyte+SceneStore,light1_duty); 
043C:  MOVLW  09
043D:  ADDWF  4D,W
043E:  MOVWF  69
043F:  MOVF   0B,W
0440:  MOVWF  20
0441:  BCF    0B.7
0442:  MOVF   69,W
0443:  BSF    03.5
0444:  MOVWF  1B
0445:  BCF    03.5
0446:  MOVF   38,W
0447:  BSF    03.5
0448:  MOVWF  1A
0449:  BCF    1C.7
044A:  BSF    1C.2
044B:  MOVLW  55
044C:  MOVWF  1D
044D:  MOVLW  AA
044E:  MOVWF  1D
044F:  BSF    1C.1
0450:  BTFSC  1C.1
0451:  GOTO   450
0452:  BCF    1C.2
0453:  BCF    03.5
0454:  MOVF   20,W
0455:  IORWF  0B,F
.................... 				delay_us(5);		 
0456:  GOTO   457
0457:  GOTO   458
0458:  NOP
.................... 				} 
.................... 				if(address==Fixlampid2) 
0459:  MOVF   4B,W
045A:  SUBLW  06
045B:  BTFSS  03.2
045C:  GOTO   47B
.................... 				{ 
.................... 				write_eeprom(databyte+SceneStore2,light2_duty); 
045D:  MOVLW  22
045E:  ADDWF  4D,W
045F:  MOVWF  69
0460:  MOVF   0B,W
0461:  MOVWF  20
0462:  BCF    0B.7
0463:  MOVF   69,W
0464:  BSF    03.5
0465:  MOVWF  1B
0466:  BCF    03.5
0467:  MOVF   39,W
0468:  BSF    03.5
0469:  MOVWF  1A
046A:  BCF    1C.7
046B:  BSF    1C.2
046C:  MOVLW  55
046D:  MOVWF  1D
046E:  MOVLW  AA
046F:  MOVWF  1D
0470:  BSF    1C.1
0471:  BTFSC  1C.1
0472:  GOTO   471
0473:  BCF    1C.2
0474:  BCF    03.5
0475:  MOVF   20,W
0476:  IORWF  0B,F
.................... 				delay_us(5); 
0477:  GOTO   478
0478:  GOTO   479
0479:  NOP
.................... 				}	 
047A:  GOTO   4B5
.................... 				else 
.................... 				{ 
.................... 				write_eeprom(databyte+SceneStore,light1_duty); 
047B:  MOVLW  09
047C:  ADDWF  4D,W
047D:  MOVWF  69
047E:  MOVF   0B,W
047F:  MOVWF  20
0480:  BCF    0B.7
0481:  MOVF   69,W
0482:  BSF    03.5
0483:  MOVWF  1B
0484:  BCF    03.5
0485:  MOVF   38,W
0486:  BSF    03.5
0487:  MOVWF  1A
0488:  BCF    1C.7
0489:  BSF    1C.2
048A:  MOVLW  55
048B:  MOVWF  1D
048C:  MOVLW  AA
048D:  MOVWF  1D
048E:  BSF    1C.1
048F:  BTFSC  1C.1
0490:  GOTO   48F
0491:  BCF    1C.2
0492:  BCF    03.5
0493:  MOVF   20,W
0494:  IORWF  0B,F
.................... 				delay_us(5); 
0495:  GOTO   496
0496:  GOTO   497
0497:  NOP
.................... 				write_eeprom(databyte+SceneStore2,light2_duty); 
0498:  MOVLW  22
0499:  ADDWF  4D,W
049A:  MOVWF  69
049B:  MOVF   0B,W
049C:  MOVWF  20
049D:  BCF    0B.7
049E:  MOVF   69,W
049F:  BSF    03.5
04A0:  MOVWF  1B
04A1:  BCF    03.5
04A2:  MOVF   39,W
04A3:  BSF    03.5
04A4:  MOVWF  1A
04A5:  BCF    1C.7
04A6:  BSF    1C.2
04A7:  MOVLW  55
04A8:  MOVWF  1D
04A9:  MOVLW  AA
04AA:  MOVWF  1D
04AB:  BSF    1C.1
04AC:  BTFSC  1C.1
04AD:  GOTO   4AC
04AE:  BCF    1C.2
04AF:  BCF    03.5
04B0:  MOVF   20,W
04B1:  IORWF  0B,F
.................... 				delay_us(5); 
04B2:  GOTO   4B3
04B3:  GOTO   4B4
04B4:  NOP
.................... 				}			 
.................... 				enable_interrupts(global);	 
04B5:  MOVLW  C0
04B6:  IORWF  0B,F
.................... 			} 
.................... 			 
.................... 			break; 
04B7:  GOTO   5FC
.................... 		} 
.................... 		case 0x09: 
.................... 		{		 
.................... 				GroupSelectReg = MAKE16(read_EEPROM (Group_815Store ),read_EEPROM (Group_07Store));	 
04B8:  MOVLW  08
04B9:  BSF    03.5
04BA:  MOVWF  1B
04BB:  BCF    1C.7
04BC:  BSF    1C.0
04BD:  MOVF   1A,W
04BE:  BCF    03.5
04BF:  MOVWF  69
04C0:  MOVLW  07
04C1:  BSF    03.5
04C2:  MOVWF  1B
04C3:  BCF    1C.7
04C4:  BSF    1C.0
04C5:  MOVF   1A,W
04C6:  BCF    03.5
04C7:  MOVWF  6A
04C8:  MOVF   69,W
04C9:  MOVWF  52
04CA:  MOVF   6A,W
04CB:  MOVWF  51
.................... 				gindex = databyte &0x0f;				 
04CC:  MOVF   4D,W
04CD:  ANDLW  0F
04CE:  MOVWF  53
.................... 				switch (databyte & 0x10) 
04CF:  MOVF   4D,W
04D0:  ANDLW  10
04D1:  BTFSC  03.2
04D2:  GOTO   4D7
04D3:  XORLW  10
04D4:  BTFSC  03.2
04D5:  GOTO   52B
04D6:  GOTO   57A
.................... 				{ 
.................... 					case 0: 
.................... 						{ 
.................... 							bit_clear(GroupSelectReg,gindex); 
04D7:  CLRF   23
04D8:  MOVLW  01
04D9:  MOVWF  22
04DA:  MOVF   53,W
04DB:  MOVWF  20
04DC:  BTFSC  03.2
04DD:  GOTO   4E3
04DE:  BCF    03.0
04DF:  RLF    22,F
04E0:  RLF    23,F
04E1:  DECFSZ 20,F
04E2:  GOTO   4DE
04E3:  MOVF   22,W
04E4:  XORLW  FF
04E5:  MOVWF  20
04E6:  MOVLW  FF
04E7:  XORWF  23,F
04E8:  MOVF   20,W
04E9:  ANDWF  51,F
04EA:  MOVF   23,W
04EB:  ANDWF  52,F
.................... 							write_eeprom(Group_07Store  ,make8(GroupSelectReg,0)); 
04EC:  MOVF   51,W
04ED:  MOVWF  69
04EE:  MOVF   0B,W
04EF:  MOVWF  20
04F0:  BCF    0B.7
04F1:  MOVLW  07
04F2:  BSF    03.5
04F3:  MOVWF  1B
04F4:  BCF    03.5
04F5:  MOVF   51,W
04F6:  BSF    03.5
04F7:  MOVWF  1A
04F8:  BCF    1C.7
04F9:  BSF    1C.2
04FA:  MOVLW  55
04FB:  MOVWF  1D
04FC:  MOVLW  AA
04FD:  MOVWF  1D
04FE:  BSF    1C.1
04FF:  BTFSC  1C.1
0500:  GOTO   4FF
0501:  BCF    1C.2
0502:  BCF    03.5
0503:  MOVF   20,W
0504:  IORWF  0B,F
.................... 							delay_us(10); 
0505:  MOVLW  02
0506:  MOVWF  20
0507:  DECFSZ 20,F
0508:  GOTO   507
0509:  GOTO   50A
050A:  NOP
.................... 							write_eeprom(Group_815Store,make8(GroupSelectReg,1)); 
050B:  MOVF   52,W
050C:  MOVWF  69
050D:  MOVF   0B,W
050E:  MOVWF  20
050F:  BCF    0B.7
0510:  MOVLW  08
0511:  BSF    03.5
0512:  MOVWF  1B
0513:  BCF    03.5
0514:  MOVF   52,W
0515:  BSF    03.5
0516:  MOVWF  1A
0517:  BCF    1C.7
0518:  BSF    1C.2
0519:  MOVLW  55
051A:  MOVWF  1D
051B:  MOVLW  AA
051C:  MOVWF  1D
051D:  BSF    1C.1
051E:  BTFSC  1C.1
051F:  GOTO   51E
0520:  BCF    1C.2
0521:  BCF    03.5
0522:  MOVF   20,W
0523:  IORWF  0B,F
....................  							delay_us(10); 
0524:  MOVLW  02
0525:  MOVWF  20
0526:  DECFSZ 20,F
0527:  GOTO   526
0528:  GOTO   529
0529:  NOP
.................... 							break; 
052A:  GOTO   57A
.................... 						} 
.................... 					case 16: 
.................... 						{ 
.................... 							bit_set(GroupSelectReg,gindex); 
052B:  CLRF   23
052C:  MOVLW  01
052D:  MOVWF  22
052E:  MOVF   53,W
052F:  MOVWF  20
0530:  BTFSC  03.2
0531:  GOTO   537
0532:  BCF    03.0
0533:  RLF    22,F
0534:  RLF    23,F
0535:  DECFSZ 20,F
0536:  GOTO   532
0537:  MOVF   22,W
0538:  IORWF  51,F
0539:  MOVF   23,W
053A:  IORWF  52,F
.................... 							write_eeprom(Group_07Store  ,make8(GroupSelectReg,0)); 
053B:  MOVF   51,W
053C:  MOVWF  69
053D:  MOVF   0B,W
053E:  MOVWF  20
053F:  BCF    0B.7
0540:  MOVLW  07
0541:  BSF    03.5
0542:  MOVWF  1B
0543:  BCF    03.5
0544:  MOVF   51,W
0545:  BSF    03.5
0546:  MOVWF  1A
0547:  BCF    1C.7
0548:  BSF    1C.2
0549:  MOVLW  55
054A:  MOVWF  1D
054B:  MOVLW  AA
054C:  MOVWF  1D
054D:  BSF    1C.1
054E:  BTFSC  1C.1
054F:  GOTO   54E
0550:  BCF    1C.2
0551:  BCF    03.5
0552:  MOVF   20,W
0553:  IORWF  0B,F
.................... 							delay_us(10); 
0554:  MOVLW  02
0555:  MOVWF  20
0556:  DECFSZ 20,F
0557:  GOTO   556
0558:  GOTO   559
0559:  NOP
.................... 							write_eeprom(Group_815Store,make8(GroupSelectReg,1)); 
055A:  MOVF   52,W
055B:  MOVWF  69
055C:  MOVF   0B,W
055D:  MOVWF  20
055E:  BCF    0B.7
055F:  MOVLW  08
0560:  BSF    03.5
0561:  MOVWF  1B
0562:  BCF    03.5
0563:  MOVF   52,W
0564:  BSF    03.5
0565:  MOVWF  1A
0566:  BCF    1C.7
0567:  BSF    1C.2
0568:  MOVLW  55
0569:  MOVWF  1D
056A:  MOVLW  AA
056B:  MOVWF  1D
056C:  BSF    1C.1
056D:  BTFSC  1C.1
056E:  GOTO   56D
056F:  BCF    1C.2
0570:  BCF    03.5
0571:  MOVF   20,W
0572:  IORWF  0B,F
....................  							delay_us(10); 
0573:  MOVLW  02
0574:  MOVWF  20
0575:  DECFSZ 20,F
0576:  GOTO   575
0577:  GOTO   578
0578:  NOP
.................... 							break; 
0579:  GOTO   57A
.................... 						} 
.................... 					 
.................... 					default: break; 
....................  
.................... 				} 
.................... 				 
.................... 				break ; 
057A:  GOTO   5FC
.................... 		} 
.................... 		case 0x22:    // store  short  aress  
.................... 		{ 
.................... 			if(databyte <64) 
057B:  MOVF   4D,W
057C:  SUBLW  3F
057D:  BTFSS  03.0
057E:  GOTO   59E
.................... 			{ 
.................... 					lampid = databyte; 
057F:  MOVF   4D,W
0580:  MOVWF  68
.................... 					write_eeprom(ShortAddressStore ,lampid); 
0581:  MOVF   0B,W
0582:  MOVWF  20
0583:  BCF    0B.7
0584:  MOVLW  06
0585:  BSF    03.5
0586:  MOVWF  1B
0587:  BCF    03.5
0588:  MOVF   68,W
0589:  BSF    03.5
058A:  MOVWF  1A
058B:  BCF    1C.7
058C:  BSF    1C.2
058D:  MOVLW  55
058E:  MOVWF  1D
058F:  MOVLW  AA
0590:  MOVWF  1D
0591:  BSF    1C.1
0592:  BTFSC  1C.1
0593:  GOTO   592
0594:  BCF    1C.2
0595:  BCF    03.5
0596:  MOVF   20,W
0597:  IORWF  0B,F
.................... 					delay_us(10); 
0598:  MOVLW  02
0599:  MOVWF  20
059A:  DECFSZ 20,F
059B:  GOTO   59A
059C:  GOTO   59D
059D:  NOP
.................... 			} 
.................... 		 
.................... 			break;		 
059E:  GOTO   5FC
.................... 		} 
.................... 		case 0x23:    // write  DTR  
.................... 		{ 
.................... 					DTR = databyte;	 
059F:  MOVF   4D,W
05A0:  MOVWF  65
.................... 					DTR_Ready =1; 
05A1:  MOVLW  01
05A2:  MOVWF  67
.................... 					break; 
05A3:  GOTO   5FC
.................... 		} 
.................... 		case 0x24:    // write  DTR  to  adress  location  in data  byte  
.................... 		{ 
.................... 					 
.................... 				DwriteLocation = databyte;	 
05A4:  MOVF   4D,W
05A5:  MOVWF  66
.................... 				if(DTR_Ready ==1 && DwriteLocation<33 ) 
05A6:  DECFSZ 67,W
05A7:  GOTO   5C9
05A8:  MOVF   66,W
05A9:  SUBLW  20
05AA:  BTFSS  03.0
05AB:  GOTO   5C9
.................... 				{ 
.................... 					DTR_Ready =0; 
05AC:  CLRF   67
.................... 					write_eeprom(DwriteLocation,DTR); 
05AD:  MOVF   0B,W
05AE:  MOVWF  20
05AF:  BCF    0B.7
05B0:  MOVF   66,W
05B1:  BSF    03.5
05B2:  MOVWF  1B
05B3:  BCF    03.5
05B4:  MOVF   65,W
05B5:  BSF    03.5
05B6:  MOVWF  1A
05B7:  BCF    1C.7
05B8:  BSF    1C.2
05B9:  MOVLW  55
05BA:  MOVWF  1D
05BB:  MOVLW  AA
05BC:  MOVWF  1D
05BD:  BSF    1C.1
05BE:  BTFSC  1C.1
05BF:  GOTO   5BE
05C0:  BCF    1C.2
05C1:  BCF    03.5
05C2:  MOVF   20,W
05C3:  IORWF  0B,F
.................... 					DELAY_US(20); 
05C4:  MOVLW  06
05C5:  MOVWF  20
05C6:  DECFSZ 20,F
05C7:  GOTO   5C6
05C8:  NOP
.................... 				} 
.................... 			init_from_eeprom(); 
05C9:  CALL   130
.................... 			break; 
05CA:  GOTO   5FC
.................... 		} 
.................... 		case 0x25:    // Read  DTR  to  adress  location  in data  byte  
.................... 		{ 
.................... 				tx_buffer[2]=lampid;tx_buffer[1]=DTR; txmit(2,2);  /////////priority changed 
05CB:  MOVF   68,W
05CC:  MOVWF  43
05CD:  MOVF   65,W
05CE:  MOVWF  42
05CF:  MOVLW  02
05D0:  MOVWF  69
05D1:  MOVWF  6A
05D2:  CALL   2B2
.................... 				break;			 
05D3:  GOTO   5FC
.................... 		} 
.................... 		case 0x26:    // Read  eeprom  and  store  in dtr   to  adress  location  in data  byte  
.................... 		{ 
.................... 				DwriteLocation = databyte;	 
05D4:  MOVF   4D,W
05D5:  MOVWF  66
.................... 				if( DwriteLocation<33 ) 
05D6:  MOVF   66,W
05D7:  SUBLW  20
05D8:  BTFSS  03.0
05D9:  GOTO   5E2
.................... 				{ 
.................... 					DTR=Read_eeprom(DwriteLocation); 
05DA:  MOVF   66,W
05DB:  BSF    03.5
05DC:  MOVWF  1B
05DD:  BCF    1C.7
05DE:  BSF    1C.0
05DF:  MOVF   1A,W
05E0:  BCF    03.5
05E1:  MOVWF  65
.................... 				}	 
.................... 				break;				 
05E2:  GOTO   5FC
.................... 		} 
.................... 		case 0x27: 
.................... 		{ 
.................... 			tx_buffer[2]=lampid;tx_buffer[1]=Read_eeprom(0);  
05E3:  MOVF   68,W
05E4:  MOVWF  43
05E5:  BSF    03.5
05E6:  CLRF   1B
05E7:  BCF    1C.7
05E8:  BSF    1C.0
05E9:  MOVF   1A,W
05EA:  BCF    03.5
05EB:  MOVWF  42
.................... 	    	txmit(2,2); 
05EC:  MOVLW  02
05ED:  MOVWF  69
05EE:  MOVWF  6A
05EF:  CALL   2B2
.................... 		 
.................... 			break; 
05F0:  GOTO   5FC
....................  
.................... 		} 
.................... 		case 0x31: //////////////// case for device type query ///////////////// 
.................... 		{ 
.................... 			tx_buffer[2]=lampid;tx_buffer[1]=device_type;  
05F1:  MOVF   68,W
05F2:  MOVWF  43
05F3:  MOVLW  03
05F4:  MOVWF  42
.................... 			txmit(2,2); 
05F5:  MOVLW  02
05F6:  MOVWF  69
05F7:  MOVWF  6A
05F8:  CALL   2B2
.................... 					 
.................... 			 
.................... 			break; 
05F9:  GOTO   5FC
....................  
.................... 		} 
.................... 		default: 
.................... 		{ 
.................... 			command_st=1; 
05FA:  MOVLW  01
05FB:  MOVWF  46
.................... 			break; 
.................... 		} 
.................... 	} 
.................... 	if(command_st==0) 
05FC:  MOVF   46,F
05FD:  BTFSS  03.2
05FE:  GOTO   632
.................... 	{ 		 
.................... 		  write_eeprom(PowerOnLevelStore,light1_duty); 
05FF:  MOVF   0B,W
0600:  MOVWF  20
0601:  BCF    0B.7
0602:  BSF    03.5
0603:  CLRF   1B
0604:  BCF    03.5
0605:  MOVF   38,W
0606:  BSF    03.5
0607:  MOVWF  1A
0608:  BCF    1C.7
0609:  BSF    1C.2
060A:  MOVLW  55
060B:  MOVWF  1D
060C:  MOVLW  AA
060D:  MOVWF  1D
060E:  BSF    1C.1
060F:  BTFSC  1C.1
0610:  GOTO   60F
0611:  BCF    1C.2
0612:  BCF    03.5
0613:  MOVF   20,W
0614:  IORWF  0B,F
.................... 			delay_us(10);		 
0615:  MOVLW  02
0616:  MOVWF  20
0617:  DECFSZ 20,F
0618:  GOTO   617
0619:  GOTO   61A
061A:  NOP
.................... 			write_eeprom(PowerOnLevelStore2,light2_duty); 
061B:  MOVF   0B,W
061C:  MOVWF  20
061D:  BCF    0B.7
061E:  MOVLW  21
061F:  BSF    03.5
0620:  MOVWF  1B
0621:  BCF    03.5
0622:  MOVF   39,W
0623:  BSF    03.5
0624:  MOVWF  1A
0625:  BCF    1C.7
0626:  BSF    1C.2
0627:  MOVLW  55
0628:  MOVWF  1D
0629:  MOVLW  AA
062A:  MOVWF  1D
062B:  BSF    1C.1
062C:  BTFSC  1C.1
062D:  GOTO   62C
062E:  BCF    1C.2
062F:  BCF    03.5
0630:  MOVF   20,W
0631:  IORWF  0B,F
.................... 	} 
....................  
....................  
.................... return; 
.................... } 
....................  
....................  
.................... /* 
.................... void goto_position(int16 position) 
.................... { 
....................  
.................... 	faderate=2; 
.................... 	curtain_time=position * faderate * 10; 
.................... 	 
.................... 	if(position == 0) 
.................... 	{ 
.................... 	output_high(light2_pin); 
.................... 	delay_ms(100); 
.................... 	output_low(light2_pin); 
.................... 	} 
.................... 	else if(position==100) 
.................... 	{ 
.................... 	output_high(light1_pin); 
.................... 	delay_ms(100); 
.................... 	output_low(light1_pin); 
.................... 	} 
.................... 	else if(position>0 && position <100) 
.................... 	{ 
.................... 	// code to go to position 0 
.................... 	output_high(light2_pin); 
.................... 	delay_ms(100); 
.................... 	output_low(light2_pin); 
.................... 	delay_ms(3000); 
....................  
.................... 	// code to go to desired position 
.................... 	output_high(light1_pin); 
.................... 	delay_ms(100); 
.................... 	output_low(light1_pin); 
.................... 	delay_ms(curtain_time); 
.................... 	output_high(light1_pin); 
.................... 	delay_ms(100); 
.................... 	output_low(light1_pin); 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 	output_high(light2_pin); 
.................... 	delay_ms(100); 
.................... 	output_low(light2_pin); 
.................... 	} 
.................... 	 
.................... 	return; 
....................  
....................  
.................... } 
.................... */ 
....................  
.................... void init_from_eeprom(void) 
.................... { 
.................... GroupSelectReg = MAKE16(read_EEPROM (Group_815Store ),read_EEPROM (Group_07Store));	 
*
0130:  MOVLW  08
0131:  BSF    03.5
0132:  MOVWF  1B
0133:  BCF    1C.7
0134:  BSF    1C.0
0135:  MOVF   1A,W
0136:  BCF    03.5
0137:  MOVWF  69
0138:  MOVLW  07
0139:  BSF    03.5
013A:  MOVWF  1B
013B:  BCF    1C.7
013C:  BSF    1C.0
013D:  MOVF   1A,W
013E:  BCF    03.5
013F:  MOVWF  6A
0140:  MOVF   69,W
0141:  MOVWF  52
0142:  MOVF   6A,W
0143:  MOVWF  51
.................... delay_us(10); 
0144:  MOVLW  02
0145:  MOVWF  20
0146:  DECFSZ 20,F
0147:  GOTO   146
0148:  GOTO   149
0149:  NOP
.................... PowerOnLevel 		= read_EEPROM (PowerOnLevelStore); 
014A:  BSF    03.5
014B:  CLRF   1B
014C:  BCF    1C.7
014D:  BSF    1C.0
014E:  MOVF   1A,W
014F:  BCF    03.5
0150:  MOVWF  63
.................... delay_us(10);  
0151:  MOVLW  02
0152:  MOVWF  20
0153:  DECFSZ 20,F
0154:  GOTO   153
0155:  GOTO   156
0156:  NOP
.................... SystemFailureLevel	= read_EEPROM ( SystemFailureLevelStore );  
0157:  MOVLW  01
0158:  BSF    03.5
0159:  MOVWF  1B
015A:  BCF    1C.7
015B:  BSF    1C.0
015C:  MOVF   1A,W
015D:  BCF    03.5
015E:  MOVWF  58
.................... delay_us(10);	     
015F:  MOVLW  02
0160:  MOVWF  20
0161:  DECFSZ 20,F
0162:  GOTO   161
0163:  GOTO   164
0164:  NOP
.................... MinimumLevel		= read_EEPROM ( MinimumLevelStore );    
0165:  MOVLW  02
0166:  BSF    03.5
0167:  MOVWF  1B
0168:  BCF    1C.7
0169:  BSF    1C.0
016A:  MOVF   1A,W
016B:  BCF    03.5
016C:  MOVWF  56
.................... delay_us(10);       	 
016D:  MOVLW  02
016E:  MOVWF  20
016F:  DECFSZ 20,F
0170:  GOTO   16F
0171:  GOTO   172
0172:  NOP
.................... MaximumLevel 		= read_EEPROM ( MaximumLevelStore);  
0173:  MOVLW  03
0174:  BSF    03.5
0175:  MOVWF  1B
0176:  BCF    1C.7
0177:  BSF    1C.0
0178:  MOVF   1A,W
0179:  BCF    03.5
017A:  MOVWF  57
.................... delay_us(10);  		 
017B:  MOVLW  02
017C:  MOVWF  20
017D:  DECFSZ 20,F
017E:  GOTO   17D
017F:  GOTO   180
0180:  NOP
.................... FadeRate 			= read_EEPROM ( FadeRateStore); 
0181:  MOVLW  04
0182:  BSF    03.5
0183:  MOVWF  1B
0184:  BCF    1C.7
0185:  BSF    1C.0
0186:  MOVF   1A,W
0187:  BCF    03.5
0188:  CLRF   5A
0189:  MOVWF  59
.................... delay_us(10); 
018A:  MOVLW  02
018B:  MOVWF  20
018C:  DECFSZ 20,F
018D:  GOTO   18C
018E:  GOTO   18F
018F:  NOP
.................... FadeTime 			= read_EEPROM ( FadeTimeStore ); 
0190:  MOVLW  05
0191:  BSF    03.5
0192:  MOVWF  1B
0193:  BCF    1C.7
0194:  BSF    1C.0
0195:  MOVF   1A,W
0196:  BCF    03.5
0197:  MOVWF  5B
.................... delay_us(10); 
0198:  MOVLW  02
0199:  MOVWF  20
019A:  DECFSZ 20,F
019B:  GOTO   19A
019C:  GOTO   19D
019D:  NOP
.................... lampid 				= read_EEPROM ( ShortAddressStore ); 
019E:  MOVLW  06
019F:  BSF    03.5
01A0:  MOVWF  1B
01A1:  BCF    1C.7
01A2:  BSF    1C.0
01A3:  MOVF   1A,W
01A4:  BCF    03.5
01A5:  MOVWF  68
.................... delay_us(10); 
01A6:  MOVLW  02
01A7:  MOVWF  20
01A8:  DECFSZ 20,F
01A9:  GOTO   1A8
01AA:  GOTO   1AB
01AB:  NOP
....................  
.................... RandomAddress0 		= read_EEPROM ( RandomAddressStore0);  
01AC:  MOVLW  19
01AD:  BSF    03.5
01AE:  MOVWF  1B
01AF:  BCF    1C.7
01B0:  BSF    1C.0
01B1:  MOVF   1A,W
01B2:  BCF    03.5
01B3:  MOVWF  5C
.................... delay_us(10);   
01B4:  MOVLW  02
01B5:  MOVWF  20
01B6:  DECFSZ 20,F
01B7:  GOTO   1B6
01B8:  GOTO   1B9
01B9:  NOP
.................... RandomAddress1 		= read_EEPROM ( RandomAddressStore1);  
01BA:  MOVLW  1A
01BB:  BSF    03.5
01BC:  MOVWF  1B
01BD:  BCF    1C.7
01BE:  BSF    1C.0
01BF:  MOVF   1A,W
01C0:  BCF    03.5
01C1:  MOVWF  5D
.................... delay_us(10); 
01C2:  MOVLW  02
01C3:  MOVWF  20
01C4:  DECFSZ 20,F
01C5:  GOTO   1C4
01C6:  GOTO   1C7
01C7:  NOP
.................... RandomAddress2 		= read_EEPROM ( RandomAddressStore2); 
01C8:  MOVLW  1B
01C9:  BSF    03.5
01CA:  MOVWF  1B
01CB:  BCF    1C.7
01CC:  BSF    1C.0
01CD:  MOVF   1A,W
01CE:  BCF    03.5
01CF:  MOVWF  5E
.................... delay_us(10); 
01D0:  MOVLW  02
01D1:  MOVWF  20
01D2:  DECFSZ 20,F
01D3:  GOTO   1D2
01D4:  GOTO   1D5
01D5:  NOP
....................   		 
.................... FastFadeTime 		= read_EEPROM ( FastFadeTimeStore);  
01D6:  MOVLW  1C
01D7:  BSF    03.5
01D8:  MOVWF  1B
01D9:  BCF    1C.7
01DA:  BSF    1C.0
01DB:  MOVF   1A,W
01DC:  BCF    03.5
01DD:  MOVWF  5F
.................... delay_us(10); 		 
01DE:  MOVLW  02
01DF:  MOVWF  20
01E0:  DECFSZ 20,F
01E1:  GOTO   1E0
01E2:  GOTO   1E3
01E3:  NOP
.................... FailureStatus 		= read_EEPROM ( FailureStatusStore);  
01E4:  MOVLW  1D
01E5:  BSF    03.5
01E6:  MOVWF  1B
01E7:  BCF    1C.7
01E8:  BSF    1C.0
01E9:  MOVF   1A,W
01EA:  BCF    03.5
01EB:  MOVWF  60
.................... delay_us(10);  
01EC:  MOVLW  02
01ED:  MOVWF  20
01EE:  DECFSZ 20,F
01EF:  GOTO   1EE
01F0:  GOTO   1F1
01F1:  NOP
.................... OperatingMode 		= read_EEPROM ( OperatingModeStore);  
01F2:  MOVLW  1E
01F3:  BSF    03.5
01F4:  MOVWF  1B
01F5:  BCF    1C.7
01F6:  BSF    1C.0
01F7:  MOVF   1A,W
01F8:  BCF    03.5
01F9:  MOVWF  61
.................... delay_us(10); 
01FA:  MOVLW  02
01FB:  MOVWF  20
01FC:  DECFSZ 20,F
01FD:  GOTO   1FC
01FE:  GOTO   1FF
01FF:  NOP
.................... DimmingCurv 		= read_EEPROM ( DimmingCurveStore); 
0200:  MOVLW  1F
0201:  BSF    03.5
0202:  MOVWF  1B
0203:  BCF    1C.7
0204:  BSF    1C.0
0205:  MOVF   1A,W
0206:  BCF    03.5
0207:  MOVWF  62
.................... delay_us(10);  
0208:  MOVLW  02
0209:  MOVWF  20
020A:  DECFSZ 20,F
020B:  GOTO   20A
020C:  GOTO   20D
020D:  NOP
.................... zoneid=read_EEPROM(zoneidstore); 
020E:  MOVLW  20
020F:  BSF    03.5
0210:  MOVWF  1B
0211:  BCF    1C.7
0212:  BSF    1C.0
0213:  MOVF   1A,W
0214:  BCF    03.5
0215:  MOVWF  49
....................  
.................... PowerOnLevel2 		= read_EEPROM (PowerOnLevelStore2); 
0216:  MOVLW  21
0217:  BSF    03.5
0218:  MOVWF  1B
0219:  BCF    1C.7
021A:  BSF    1C.0
021B:  MOVF   1A,W
021C:  BCF    03.5
021D:  MOVWF  64
.................... delay_us(10);  
021E:  MOVLW  02
021F:  MOVWF  20
0220:  DECFSZ 20,F
0221:  GOTO   220
0222:  GOTO   223
0223:  NOP
0224:  RETURN
....................  
.................... } 
....................  
....................  

Configuration Fuses:
   Word  1: 33D4   INTRC_IO NOWDT NOPUT NOMCLR NOPROTECT NOCPD BROWNOUT NOIESO NOFCMEN

ROM data:
002100: 0064 0032 0000 0064 0005 0006 0005 0001 
002108: 0000 0006 0007 0008 

002120: 00D3 
